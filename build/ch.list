
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000200 	.word	0x20000200
 8000004:	08000191 	.word	0x08000191
 8000008:	08003601 	.word	0x08003601
 800000c:	08000193 	.word	0x08000193
 8000010:	08000193 	.word	0x08000193
 8000014:	08000193 	.word	0x08000193
 8000018:	08000193 	.word	0x08000193
 800001c:	08000193 	.word	0x08000193
 8000020:	08000193 	.word	0x08000193
 8000024:	08000193 	.word	0x08000193
 8000028:	08000193 	.word	0x08000193
 800002c:	08000193 	.word	0x08000193
 8000030:	08000193 	.word	0x08000193
 8000034:	08000193 	.word	0x08000193
 8000038:	08000193 	.word	0x08000193
 800003c:	08000193 	.word	0x08000193
 8000040:	08000193 	.word	0x08000193
 8000044:	08000193 	.word	0x08000193
 8000048:	08000193 	.word	0x08000193
 800004c:	08000193 	.word	0x08000193
 8000050:	08000193 	.word	0x08000193
 8000054:	08000193 	.word	0x08000193
 8000058:	08000193 	.word	0x08000193
 800005c:	08000193 	.word	0x08000193
 8000060:	08000193 	.word	0x08000193
 8000064:	080040e1 	.word	0x080040e1
 8000068:	08004711 	.word	0x08004711
 800006c:	080045f1 	.word	0x080045f1
 8000070:	08004371 	.word	0x08004371
 8000074:	08000193 	.word	0x08000193
 8000078:	08000193 	.word	0x08000193
 800007c:	08000193 	.word	0x08000193
 8000080:	08003aa1 	.word	0x08003aa1
 8000084:	08000193 	.word	0x08000193
 8000088:	08000193 	.word	0x08000193
 800008c:	08000193 	.word	0x08000193
 8000090:	08000193 	.word	0x08000193
 8000094:	08000193 	.word	0x08000193
 8000098:	08000193 	.word	0x08000193
 800009c:	08003c71 	.word	0x08003c71
 80000a0:	08000193 	.word	0x08000193
 80000a4:	08000193 	.word	0x08000193
 80000a8:	08000193 	.word	0x08000193
 80000ac:	08000193 	.word	0x08000193
 80000b0:	08000193 	.word	0x08000193
 80000b4:	08000193 	.word	0x08000193
 80000b8:	08000193 	.word	0x08000193
 80000bc:	08000193 	.word	0x08000193

Disassembly of section .text:

080000c0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80000c0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80000c2:	4824      	ldr	r0, [pc, #144]	; (8000154 <endfiniloop+0x6>)
                msr     MSP, r0
 80000c4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80000c8:	4823      	ldr	r0, [pc, #140]	; (8000158 <endfiniloop+0xa>)
                msr     PSP, r0
 80000ca:	f380 8809 	msr	PSP, r0

                /* CPU mode initialization as configured.*/
                movs    r0, #CRT0_CONTROL_INIT
 80000ce:	2002      	movs	r0, #2
                msr     CONTROL, r0
 80000d0:	f380 8814 	msr	CONTROL, r0
                isb
 80000d4:	f3bf 8f6f 	isb	sy
                str     r0, [r1]
#endif

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 80000d8:	f004 fc0a 	bl	80048f0 <__core_init>
#endif

                /* Early initialization..*/
                bl      __early_init
 80000dc:	f003 fc38 	bl	8003950 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80000e0:	481e      	ldr	r0, [pc, #120]	; (800015c <endfiniloop+0xe>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80000e2:	491f      	ldr	r1, [pc, #124]	; (8000160 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 80000e4:	4a1b      	ldr	r2, [pc, #108]	; (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
msloop:
                cmp     r1, r2
 80000e6:	4291      	cmp	r1, r2
                bge     endmsloop
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
                str     r0, [r1]
 80000ea:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000ec:	3104      	adds	r1, #4
                b       msloop
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
endmsloop:
                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80000f0:	491c      	ldr	r1, [pc, #112]	; (8000164 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 80000f2:	4a19      	ldr	r2, [pc, #100]	; (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
psloop:
                cmp     r1, r2
 80000f4:	4291      	cmp	r1, r2
                bge     endpsloop
 80000f6:	da02      	bge.n	80000fe <endpsloop>
                str     r0, [r1]
 80000f8:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000fa:	3104      	adds	r1, #4
                b       psloop
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata
 80000fe:	491a      	ldr	r1, [pc, #104]	; (8000168 <endfiniloop+0x1a>)
                ldr     r2, =_data
 8000100:	4a1a      	ldr	r2, [pc, #104]	; (800016c <endfiniloop+0x1e>)
                ldr     r3, =_edata
 8000102:	4b1b      	ldr	r3, [pc, #108]	; (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
dloop:
                cmp     r2, r3
 8000104:	429a      	cmp	r2, r3
                bge     enddloop
 8000106:	da04      	bge.n	8000112 <enddloop>
                ldr     r0, [r1]
 8000108:	6808      	ldr	r0, [r1, #0]
                str     r0, [r2]
 800010a:	6010      	str	r0, [r2, #0]
                adds    r1, #4
 800010c:	3104      	adds	r1, #4
                adds    r2, #4
 800010e:	3204      	adds	r2, #4
                b       dloop
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000112:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000114:	4917      	ldr	r1, [pc, #92]	; (8000174 <endfiniloop+0x26>)
                ldr     r2, =_bss_end
 8000116:	4a18      	ldr	r2, [pc, #96]	; (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
bloop:
                cmp     r1, r2
 8000118:	4291      	cmp	r1, r2
                bge     endbloop
 800011a:	da02      	bge.n	8000122 <endbloop>
                str     r0, [r1]
 800011c:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 800011e:	3104      	adds	r1, #4
                b       bloop
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
endbloop:
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000122:	f004 fbad 	bl	8004880 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000126:	f004 fbdb 	bl	80048e0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800012a:	4c14      	ldr	r4, [pc, #80]	; (800017c <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end
 800012c:	4d14      	ldr	r5, [pc, #80]	; (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
initloop:
                cmp     r4, r5
 800012e:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000130:	da03      	bge.n	800013a <endinitloop>
                ldr     r1, [r4]
 8000132:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000134:	4788      	blx	r1
                adds    r4, #4
 8000136:	3404      	adds	r4, #4
                b       initloop
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 800013a:	f001 fdc9 	bl	8001cd0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800013e:	4c11      	ldr	r4, [pc, #68]	; (8000184 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end
 8000140:	4d11      	ldr	r5, [pc, #68]	; (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
finiloop:
                cmp     r4, r5
 8000142:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000144:	da03      	bge.n	800014e <endfiniloop>
                ldr     r1, [r4]
 8000146:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000148:	4788      	blx	r1
                adds    r4, #4
 800014a:	3404      	adds	r4, #4
                b       finiloop
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                ldr     r1, =__default_exit
 800014e:	490f      	ldr	r1, [pc, #60]	; (800018c <endfiniloop+0x3e>)
                bx      r1
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
                /* Interrupts are globally masked initially.*/
                cpsid   i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000154:	20000200 	.word	0x20000200
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000158:	20000400 	.word	0x20000400

                /* Early initialization..*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800015c:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000160:	20000000 	.word	0x20000000
                b       msloop
endmsloop:
                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000164:	20000200 	.word	0x20000200
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata
 8000168:	08005b30 	.word	0x08005b30
                ldr     r2, =_data
 800016c:	20000400 	.word	0x20000400
                ldr     r3, =_edata
 8000170:	20000400 	.word	0x20000400

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 8000174:	20000400 	.word	0x20000400
                ldr     r2, =_bss_end
 8000178:	20000fb8 	.word	0x20000fb8
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800017c:	080000c0 	.word	0x080000c0
                ldr     r5, =__init_array_end
 8000180:	080000c0 	.word	0x080000c0
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000184:	080000c0 	.word	0x080000c0
                ldr     r5, =__fini_array_end
 8000188:	080000c0 	.word	0x080000c0
                b       finiloop
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                ldr     r1, =__default_exit
 800018c:	080048d1 	.word	0x080048d1

08000190 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000190:	e796      	b.n	80000c0 <_crt0_entry>

08000192 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000192:	f000 f800 	bl	8000196 <_unhandled_exception>

08000196 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000196:	e7fe      	b.n	8000196 <_unhandled_exception>

08000198 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, lr}
 8000198:	b5f0      	push	{r4, r5, r6, r7, lr}
                mov     r4, r8
 800019a:	4644      	mov	r4, r8
                mov     r5, r9
 800019c:	464d      	mov	r5, r9
                mov     r6, r10
 800019e:	4656      	mov	r6, sl
                mov     r7, r11
 80001a0:	465f      	mov	r7, fp
                push    {r4, r5, r6, r7}
 80001a2:	b4f0      	push	{r4, r5, r6, r7}
                
                mov     r3, sp
 80001a4:	466b      	mov	r3, sp
                str     r3, [r1, #CONTEXT_OFFSET]
 80001a6:	60cb      	str	r3, [r1, #12]
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80001a8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80001aa:	469d      	mov	sp, r3
                
                pop     {r4, r5, r6, r7}
 80001ac:	bcf0      	pop	{r4, r5, r6, r7}
                mov     r8, r4
 80001ae:	46a0      	mov	r8, r4
                mov     r9, r5
 80001b0:	46a9      	mov	r9, r5
                mov     r10, r6
 80001b2:	46b2      	mov	sl, r6
                mov     r11, r7
 80001b4:	46bb      	mov	fp, r7
                pop     {r4, r5, r6, r7, pc}
 80001b6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b8 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80001b8:	f002 fbf2 	bl	80029a0 <_dbg_check_unlock>
#endif
#if CH_DBG_STATISTICS
                bl      _stats_stop_measure_crit_thd
#endif
                cpsie   i
 80001bc:	b662      	cpsie	i
                mov     r0, r5
 80001be:	1c28      	adds	r0, r5, #0
                blx     r4
 80001c0:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80001c2:	2000      	movs	r0, #0
                bl      chThdExit
 80001c4:	f002 fd94 	bl	8002cf0 <chThdExit>

080001c8 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 80001c8:	f002 fc12 	bl	80029f0 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 80001cc:	f002 fe10 	bl	8002df0 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80001d0:	f002 fbe6 	bl	80029a0 <_dbg_check_unlock>

080001d4 <_port_exit_from_isr>:
#if CH_DBG_STATISTICS
                bl      _stats_stop_measure_crit_thd
#endif
                .globl  _port_exit_from_isr
_port_exit_from_isr:
                ldr     r2, .L2
 80001d4:	4a01      	ldr	r2, [pc, #4]	; (80001dc <_port_exit_from_isr+0x8>)
                ldr     r3, .L3
 80001d6:	4b02      	ldr	r3, [pc, #8]	; (80001e0 <_port_exit_from_isr+0xc>)
                str     r3, [r2, #0]
 80001d8:	6013      	str	r3, [r2, #0]
#if CORTEX_ALTERNATE_SWITCH
                cpsie   i
#endif
.L1:            b       .L1
 80001da:	e7fe      	b.n	80001da <_port_exit_from_isr+0x6>
 80001dc:	e000ed04 	.word	0xe000ed04
 80001e0:	80000000 	.word	0x80000000

080001e4 <__aeabi_fdiv>:
 80001e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001e6:	4656      	mov	r6, sl
 80001e8:	464d      	mov	r5, r9
 80001ea:	465f      	mov	r7, fp
 80001ec:	4644      	mov	r4, r8
 80001ee:	b4f0      	push	{r4, r5, r6, r7}
 80001f0:	0243      	lsls	r3, r0, #9
 80001f2:	0045      	lsls	r5, r0, #1
 80001f4:	0fc7      	lsrs	r7, r0, #31
 80001f6:	b083      	sub	sp, #12
 80001f8:	468a      	mov	sl, r1
 80001fa:	0a5c      	lsrs	r4, r3, #9
 80001fc:	0e2e      	lsrs	r6, r5, #24
 80001fe:	46b9      	mov	r9, r7
 8000200:	d041      	beq.n	8000286 <__aeabi_fdiv+0xa2>
 8000202:	2eff      	cmp	r6, #255	; 0xff
 8000204:	d026      	beq.n	8000254 <__aeabi_fdiv+0x70>
 8000206:	2380      	movs	r3, #128	; 0x80
 8000208:	041b      	lsls	r3, r3, #16
 800020a:	4323      	orrs	r3, r4
 800020c:	00dc      	lsls	r4, r3, #3
 800020e:	2300      	movs	r3, #0
 8000210:	4698      	mov	r8, r3
 8000212:	469b      	mov	fp, r3
 8000214:	3e7f      	subs	r6, #127	; 0x7f
 8000216:	4653      	mov	r3, sl
 8000218:	025b      	lsls	r3, r3, #9
 800021a:	0a5d      	lsrs	r5, r3, #9
 800021c:	4653      	mov	r3, sl
 800021e:	005a      	lsls	r2, r3, #1
 8000220:	0fdb      	lsrs	r3, r3, #31
 8000222:	0e12      	lsrs	r2, r2, #24
 8000224:	469a      	mov	sl, r3
 8000226:	d039      	beq.n	800029c <__aeabi_fdiv+0xb8>
 8000228:	2aff      	cmp	r2, #255	; 0xff
 800022a:	d033      	beq.n	8000294 <__aeabi_fdiv+0xb0>
 800022c:	2380      	movs	r3, #128	; 0x80
 800022e:	041b      	lsls	r3, r3, #16
 8000230:	432b      	orrs	r3, r5
 8000232:	00dd      	lsls	r5, r3, #3
 8000234:	2300      	movs	r3, #0
 8000236:	3a7f      	subs	r2, #127	; 0x7f
 8000238:	4651      	mov	r1, sl
 800023a:	1ab2      	subs	r2, r6, r2
 800023c:	4646      	mov	r6, r8
 800023e:	4079      	eors	r1, r7
 8000240:	1c08      	adds	r0, r1, #0
 8000242:	9201      	str	r2, [sp, #4]
 8000244:	431e      	orrs	r6, r3
 8000246:	2e0f      	cmp	r6, #15
 8000248:	d900      	bls.n	800024c <__aeabi_fdiv+0x68>
 800024a:	e076      	b.n	800033a <__aeabi_fdiv+0x156>
 800024c:	4a7e      	ldr	r2, [pc, #504]	; (8000448 <__aeabi_fdiv+0x264>)
 800024e:	00b6      	lsls	r6, r6, #2
 8000250:	5996      	ldr	r6, [r2, r6]
 8000252:	46b7      	mov	pc, r6
 8000254:	2c00      	cmp	r4, #0
 8000256:	d130      	bne.n	80002ba <__aeabi_fdiv+0xd6>
 8000258:	2308      	movs	r3, #8
 800025a:	4698      	mov	r8, r3
 800025c:	3b06      	subs	r3, #6
 800025e:	469b      	mov	fp, r3
 8000260:	e7d9      	b.n	8000216 <__aeabi_fdiv+0x32>
 8000262:	2380      	movs	r3, #128	; 0x80
 8000264:	2100      	movs	r1, #0
 8000266:	03db      	lsls	r3, r3, #15
 8000268:	24ff      	movs	r4, #255	; 0xff
 800026a:	025b      	lsls	r3, r3, #9
 800026c:	05e4      	lsls	r4, r4, #23
 800026e:	0a5b      	lsrs	r3, r3, #9
 8000270:	07c9      	lsls	r1, r1, #31
 8000272:	4323      	orrs	r3, r4
 8000274:	430b      	orrs	r3, r1
 8000276:	1c18      	adds	r0, r3, #0
 8000278:	b003      	add	sp, #12
 800027a:	bc3c      	pop	{r2, r3, r4, r5}
 800027c:	4690      	mov	r8, r2
 800027e:	4699      	mov	r9, r3
 8000280:	46a2      	mov	sl, r4
 8000282:	46ab      	mov	fp, r5
 8000284:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000286:	2c00      	cmp	r4, #0
 8000288:	d128      	bne.n	80002dc <__aeabi_fdiv+0xf8>
 800028a:	2304      	movs	r3, #4
 800028c:	4698      	mov	r8, r3
 800028e:	3b03      	subs	r3, #3
 8000290:	469b      	mov	fp, r3
 8000292:	e7c0      	b.n	8000216 <__aeabi_fdiv+0x32>
 8000294:	2d00      	cmp	r5, #0
 8000296:	d11f      	bne.n	80002d8 <__aeabi_fdiv+0xf4>
 8000298:	2302      	movs	r3, #2
 800029a:	e002      	b.n	80002a2 <__aeabi_fdiv+0xbe>
 800029c:	2d00      	cmp	r5, #0
 800029e:	d111      	bne.n	80002c4 <__aeabi_fdiv+0xe0>
 80002a0:	2301      	movs	r3, #1
 80002a2:	1ab2      	subs	r2, r6, r2
 80002a4:	4650      	mov	r0, sl
 80002a6:	4646      	mov	r6, r8
 80002a8:	4078      	eors	r0, r7
 80002aa:	9201      	str	r2, [sp, #4]
 80002ac:	431e      	orrs	r6, r3
 80002ae:	2e0f      	cmp	r6, #15
 80002b0:	d827      	bhi.n	8000302 <__aeabi_fdiv+0x11e>
 80002b2:	4966      	ldr	r1, [pc, #408]	; (800044c <__aeabi_fdiv+0x268>)
 80002b4:	00b6      	lsls	r6, r6, #2
 80002b6:	5989      	ldr	r1, [r1, r6]
 80002b8:	468f      	mov	pc, r1
 80002ba:	230c      	movs	r3, #12
 80002bc:	4698      	mov	r8, r3
 80002be:	3b09      	subs	r3, #9
 80002c0:	469b      	mov	fp, r3
 80002c2:	e7a8      	b.n	8000216 <__aeabi_fdiv+0x32>
 80002c4:	1c28      	adds	r0, r5, #0
 80002c6:	f001 fce1 	bl	8001c8c <__clzsi2>
 80002ca:	2276      	movs	r2, #118	; 0x76
 80002cc:	1f43      	subs	r3, r0, #5
 80002ce:	4252      	negs	r2, r2
 80002d0:	409d      	lsls	r5, r3
 80002d2:	1a12      	subs	r2, r2, r0
 80002d4:	2300      	movs	r3, #0
 80002d6:	e7af      	b.n	8000238 <__aeabi_fdiv+0x54>
 80002d8:	2303      	movs	r3, #3
 80002da:	e7ad      	b.n	8000238 <__aeabi_fdiv+0x54>
 80002dc:	1c20      	adds	r0, r4, #0
 80002de:	f001 fcd5 	bl	8001c8c <__clzsi2>
 80002e2:	1f43      	subs	r3, r0, #5
 80002e4:	409c      	lsls	r4, r3
 80002e6:	2376      	movs	r3, #118	; 0x76
 80002e8:	425b      	negs	r3, r3
 80002ea:	1a1e      	subs	r6, r3, r0
 80002ec:	2300      	movs	r3, #0
 80002ee:	4698      	mov	r8, r3
 80002f0:	469b      	mov	fp, r3
 80002f2:	e790      	b.n	8000216 <__aeabi_fdiv+0x32>
 80002f4:	2500      	movs	r5, #0
 80002f6:	46d1      	mov	r9, sl
 80002f8:	469b      	mov	fp, r3
 80002fa:	465b      	mov	r3, fp
 80002fc:	4648      	mov	r0, r9
 80002fe:	2b02      	cmp	r3, #2
 8000300:	d16f      	bne.n	80003e2 <__aeabi_fdiv+0x1fe>
 8000302:	2101      	movs	r1, #1
 8000304:	24ff      	movs	r4, #255	; 0xff
 8000306:	4001      	ands	r1, r0
 8000308:	2300      	movs	r3, #0
 800030a:	e7ae      	b.n	800026a <__aeabi_fdiv+0x86>
 800030c:	237e      	movs	r3, #126	; 0x7e
 800030e:	9a01      	ldr	r2, [sp, #4]
 8000310:	425b      	negs	r3, r3
 8000312:	1a9b      	subs	r3, r3, r2
 8000314:	2b1b      	cmp	r3, #27
 8000316:	dd6d      	ble.n	80003f4 <__aeabi_fdiv+0x210>
 8000318:	2101      	movs	r1, #1
 800031a:	464b      	mov	r3, r9
 800031c:	4019      	ands	r1, r3
 800031e:	2400      	movs	r4, #0
 8000320:	2300      	movs	r3, #0
 8000322:	e7a2      	b.n	800026a <__aeabi_fdiv+0x86>
 8000324:	2380      	movs	r3, #128	; 0x80
 8000326:	03db      	lsls	r3, r3, #15
 8000328:	421c      	tst	r4, r3
 800032a:	d149      	bne.n	80003c0 <__aeabi_fdiv+0x1dc>
 800032c:	2380      	movs	r3, #128	; 0x80
 800032e:	03db      	lsls	r3, r3, #15
 8000330:	4323      	orrs	r3, r4
 8000332:	025b      	lsls	r3, r3, #9
 8000334:	0a5b      	lsrs	r3, r3, #9
 8000336:	1c39      	adds	r1, r7, #0
 8000338:	e796      	b.n	8000268 <__aeabi_fdiv+0x84>
 800033a:	0163      	lsls	r3, r4, #5
 800033c:	016d      	lsls	r5, r5, #5
 800033e:	42ab      	cmp	r3, r5
 8000340:	d337      	bcc.n	80003b2 <__aeabi_fdiv+0x1ce>
 8000342:	4689      	mov	r9, r1
 8000344:	201a      	movs	r0, #26
 8000346:	2101      	movs	r1, #1
 8000348:	1b5b      	subs	r3, r3, r5
 800034a:	2401      	movs	r4, #1
 800034c:	1c1e      	adds	r6, r3, #0
 800034e:	0049      	lsls	r1, r1, #1
 8000350:	005b      	lsls	r3, r3, #1
 8000352:	2e00      	cmp	r6, #0
 8000354:	db01      	blt.n	800035a <__aeabi_fdiv+0x176>
 8000356:	42ab      	cmp	r3, r5
 8000358:	d301      	bcc.n	800035e <__aeabi_fdiv+0x17a>
 800035a:	1b5b      	subs	r3, r3, r5
 800035c:	4321      	orrs	r1, r4
 800035e:	3801      	subs	r0, #1
 8000360:	2800      	cmp	r0, #0
 8000362:	d1f3      	bne.n	800034c <__aeabi_fdiv+0x168>
 8000364:	1e58      	subs	r0, r3, #1
 8000366:	4183      	sbcs	r3, r0
 8000368:	430b      	orrs	r3, r1
 800036a:	1c1d      	adds	r5, r3, #0
 800036c:	9c01      	ldr	r4, [sp, #4]
 800036e:	347f      	adds	r4, #127	; 0x7f
 8000370:	2c00      	cmp	r4, #0
 8000372:	ddcb      	ble.n	800030c <__aeabi_fdiv+0x128>
 8000374:	076b      	lsls	r3, r5, #29
 8000376:	d004      	beq.n	8000382 <__aeabi_fdiv+0x19e>
 8000378:	230f      	movs	r3, #15
 800037a:	402b      	ands	r3, r5
 800037c:	2b04      	cmp	r3, #4
 800037e:	d000      	beq.n	8000382 <__aeabi_fdiv+0x19e>
 8000380:	3504      	adds	r5, #4
 8000382:	012b      	lsls	r3, r5, #4
 8000384:	d504      	bpl.n	8000390 <__aeabi_fdiv+0x1ac>
 8000386:	9a01      	ldr	r2, [sp, #4]
 8000388:	4b31      	ldr	r3, [pc, #196]	; (8000450 <__aeabi_fdiv+0x26c>)
 800038a:	3280      	adds	r2, #128	; 0x80
 800038c:	1c14      	adds	r4, r2, #0
 800038e:	401d      	ands	r5, r3
 8000390:	2cfe      	cmp	r4, #254	; 0xfe
 8000392:	dd07      	ble.n	80003a4 <__aeabi_fdiv+0x1c0>
 8000394:	464b      	mov	r3, r9
 8000396:	2101      	movs	r1, #1
 8000398:	24ff      	movs	r4, #255	; 0xff
 800039a:	4019      	ands	r1, r3
 800039c:	2300      	movs	r3, #0
 800039e:	e764      	b.n	800026a <__aeabi_fdiv+0x86>
 80003a0:	1c25      	adds	r5, r4, #0
 80003a2:	e7aa      	b.n	80002fa <__aeabi_fdiv+0x116>
 80003a4:	2101      	movs	r1, #1
 80003a6:	464a      	mov	r2, r9
 80003a8:	01ab      	lsls	r3, r5, #6
 80003aa:	0a5b      	lsrs	r3, r3, #9
 80003ac:	b2e4      	uxtb	r4, r4
 80003ae:	4011      	ands	r1, r2
 80003b0:	e75b      	b.n	800026a <__aeabi_fdiv+0x86>
 80003b2:	9a01      	ldr	r2, [sp, #4]
 80003b4:	4689      	mov	r9, r1
 80003b6:	3a01      	subs	r2, #1
 80003b8:	9201      	str	r2, [sp, #4]
 80003ba:	201b      	movs	r0, #27
 80003bc:	2100      	movs	r1, #0
 80003be:	e7c4      	b.n	800034a <__aeabi_fdiv+0x166>
 80003c0:	421d      	tst	r5, r3
 80003c2:	d007      	beq.n	80003d4 <__aeabi_fdiv+0x1f0>
 80003c4:	4323      	orrs	r3, r4
 80003c6:	025b      	lsls	r3, r3, #9
 80003c8:	0a5b      	lsrs	r3, r3, #9
 80003ca:	1c39      	adds	r1, r7, #0
 80003cc:	e74c      	b.n	8000268 <__aeabi_fdiv+0x84>
 80003ce:	2500      	movs	r5, #0
 80003d0:	0263      	lsls	r3, r4, #9
 80003d2:	d5ab      	bpl.n	800032c <__aeabi_fdiv+0x148>
 80003d4:	2380      	movs	r3, #128	; 0x80
 80003d6:	03db      	lsls	r3, r3, #15
 80003d8:	432b      	orrs	r3, r5
 80003da:	025b      	lsls	r3, r3, #9
 80003dc:	0a5b      	lsrs	r3, r3, #9
 80003de:	4651      	mov	r1, sl
 80003e0:	e742      	b.n	8000268 <__aeabi_fdiv+0x84>
 80003e2:	2b03      	cmp	r3, #3
 80003e4:	d025      	beq.n	8000432 <__aeabi_fdiv+0x24e>
 80003e6:	2b01      	cmp	r3, #1
 80003e8:	d1c0      	bne.n	800036c <__aeabi_fdiv+0x188>
 80003ea:	2101      	movs	r1, #1
 80003ec:	2400      	movs	r4, #0
 80003ee:	4001      	ands	r1, r0
 80003f0:	2300      	movs	r3, #0
 80003f2:	e73a      	b.n	800026a <__aeabi_fdiv+0x86>
 80003f4:	1c29      	adds	r1, r5, #0
 80003f6:	40d9      	lsrs	r1, r3
 80003f8:	1c2b      	adds	r3, r5, #0
 80003fa:	9a01      	ldr	r2, [sp, #4]
 80003fc:	329e      	adds	r2, #158	; 0x9e
 80003fe:	4093      	lsls	r3, r2
 8000400:	1e5d      	subs	r5, r3, #1
 8000402:	41ab      	sbcs	r3, r5
 8000404:	430b      	orrs	r3, r1
 8000406:	075a      	lsls	r2, r3, #29
 8000408:	d004      	beq.n	8000414 <__aeabi_fdiv+0x230>
 800040a:	220f      	movs	r2, #15
 800040c:	401a      	ands	r2, r3
 800040e:	2a04      	cmp	r2, #4
 8000410:	d000      	beq.n	8000414 <__aeabi_fdiv+0x230>
 8000412:	3304      	adds	r3, #4
 8000414:	015a      	lsls	r2, r3, #5
 8000416:	d505      	bpl.n	8000424 <__aeabi_fdiv+0x240>
 8000418:	464b      	mov	r3, r9
 800041a:	2101      	movs	r1, #1
 800041c:	2401      	movs	r4, #1
 800041e:	4019      	ands	r1, r3
 8000420:	2300      	movs	r3, #0
 8000422:	e722      	b.n	800026a <__aeabi_fdiv+0x86>
 8000424:	2101      	movs	r1, #1
 8000426:	464a      	mov	r2, r9
 8000428:	019b      	lsls	r3, r3, #6
 800042a:	0a5b      	lsrs	r3, r3, #9
 800042c:	4011      	ands	r1, r2
 800042e:	2400      	movs	r4, #0
 8000430:	e71b      	b.n	800026a <__aeabi_fdiv+0x86>
 8000432:	2380      	movs	r3, #128	; 0x80
 8000434:	2101      	movs	r1, #1
 8000436:	464a      	mov	r2, r9
 8000438:	03db      	lsls	r3, r3, #15
 800043a:	432b      	orrs	r3, r5
 800043c:	025b      	lsls	r3, r3, #9
 800043e:	400a      	ands	r2, r1
 8000440:	0a5b      	lsrs	r3, r3, #9
 8000442:	1c11      	adds	r1, r2, #0
 8000444:	e710      	b.n	8000268 <__aeabi_fdiv+0x84>
 8000446:	46c0      	nop			; (mov r8, r8)
 8000448:	08005624 	.word	0x08005624
 800044c:	08005664 	.word	0x08005664
 8000450:	f7ffffff 	.word	0xf7ffffff

08000454 <__aeabi_fmul>:
 8000454:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000456:	465f      	mov	r7, fp
 8000458:	4656      	mov	r6, sl
 800045a:	464d      	mov	r5, r9
 800045c:	4644      	mov	r4, r8
 800045e:	b4f0      	push	{r4, r5, r6, r7}
 8000460:	0245      	lsls	r5, r0, #9
 8000462:	0046      	lsls	r6, r0, #1
 8000464:	0fc4      	lsrs	r4, r0, #31
 8000466:	b083      	sub	sp, #12
 8000468:	1c0f      	adds	r7, r1, #0
 800046a:	0a6d      	lsrs	r5, r5, #9
 800046c:	0e36      	lsrs	r6, r6, #24
 800046e:	46a3      	mov	fp, r4
 8000470:	d045      	beq.n	80004fe <__aeabi_fmul+0xaa>
 8000472:	2eff      	cmp	r6, #255	; 0xff
 8000474:	d025      	beq.n	80004c2 <__aeabi_fmul+0x6e>
 8000476:	2380      	movs	r3, #128	; 0x80
 8000478:	041b      	lsls	r3, r3, #16
 800047a:	431d      	orrs	r5, r3
 800047c:	2300      	movs	r3, #0
 800047e:	469a      	mov	sl, r3
 8000480:	00ed      	lsls	r5, r5, #3
 8000482:	3e7f      	subs	r6, #127	; 0x7f
 8000484:	9301      	str	r3, [sp, #4]
 8000486:	027b      	lsls	r3, r7, #9
 8000488:	0a5b      	lsrs	r3, r3, #9
 800048a:	4698      	mov	r8, r3
 800048c:	0078      	lsls	r0, r7, #1
 800048e:	0ffb      	lsrs	r3, r7, #31
 8000490:	0e00      	lsrs	r0, r0, #24
 8000492:	4699      	mov	r9, r3
 8000494:	d040      	beq.n	8000518 <__aeabi_fmul+0xc4>
 8000496:	28ff      	cmp	r0, #255	; 0xff
 8000498:	d038      	beq.n	800050c <__aeabi_fmul+0xb8>
 800049a:	2380      	movs	r3, #128	; 0x80
 800049c:	4642      	mov	r2, r8
 800049e:	041b      	lsls	r3, r3, #16
 80004a0:	4313      	orrs	r3, r2
 80004a2:	00db      	lsls	r3, r3, #3
 80004a4:	4698      	mov	r8, r3
 80004a6:	2300      	movs	r3, #0
 80004a8:	387f      	subs	r0, #127	; 0x7f
 80004aa:	464a      	mov	r2, r9
 80004ac:	9f01      	ldr	r7, [sp, #4]
 80004ae:	1830      	adds	r0, r6, r0
 80004b0:	4062      	eors	r2, r4
 80004b2:	1c41      	adds	r1, r0, #1
 80004b4:	431f      	orrs	r7, r3
 80004b6:	2f0f      	cmp	r7, #15
 80004b8:	d869      	bhi.n	800058e <__aeabi_fmul+0x13a>
 80004ba:	4e7d      	ldr	r6, [pc, #500]	; (80006b0 <__aeabi_fmul+0x25c>)
 80004bc:	00bf      	lsls	r7, r7, #2
 80004be:	59f6      	ldr	r6, [r6, r7]
 80004c0:	46b7      	mov	pc, r6
 80004c2:	2d00      	cmp	r5, #0
 80004c4:	d145      	bne.n	8000552 <__aeabi_fmul+0xfe>
 80004c6:	2308      	movs	r3, #8
 80004c8:	9301      	str	r3, [sp, #4]
 80004ca:	3b06      	subs	r3, #6
 80004cc:	469a      	mov	sl, r3
 80004ce:	e7da      	b.n	8000486 <__aeabi_fmul+0x32>
 80004d0:	4693      	mov	fp, r2
 80004d2:	4653      	mov	r3, sl
 80004d4:	2b02      	cmp	r3, #2
 80004d6:	d12f      	bne.n	8000538 <__aeabi_fmul+0xe4>
 80004d8:	465b      	mov	r3, fp
 80004da:	2401      	movs	r4, #1
 80004dc:	2500      	movs	r5, #0
 80004de:	401c      	ands	r4, r3
 80004e0:	23ff      	movs	r3, #255	; 0xff
 80004e2:	026d      	lsls	r5, r5, #9
 80004e4:	05db      	lsls	r3, r3, #23
 80004e6:	0a6d      	lsrs	r5, r5, #9
 80004e8:	07e4      	lsls	r4, r4, #31
 80004ea:	431d      	orrs	r5, r3
 80004ec:	4325      	orrs	r5, r4
 80004ee:	1c28      	adds	r0, r5, #0
 80004f0:	b003      	add	sp, #12
 80004f2:	bc3c      	pop	{r2, r3, r4, r5}
 80004f4:	4690      	mov	r8, r2
 80004f6:	4699      	mov	r9, r3
 80004f8:	46a2      	mov	sl, r4
 80004fa:	46ab      	mov	fp, r5
 80004fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80004fe:	2d00      	cmp	r5, #0
 8000500:	d12c      	bne.n	800055c <__aeabi_fmul+0x108>
 8000502:	2304      	movs	r3, #4
 8000504:	9301      	str	r3, [sp, #4]
 8000506:	3b03      	subs	r3, #3
 8000508:	469a      	mov	sl, r3
 800050a:	e7bc      	b.n	8000486 <__aeabi_fmul+0x32>
 800050c:	4643      	mov	r3, r8
 800050e:	425a      	negs	r2, r3
 8000510:	4153      	adcs	r3, r2
 8000512:	2203      	movs	r2, #3
 8000514:	1ad3      	subs	r3, r2, r3
 8000516:	e7c8      	b.n	80004aa <__aeabi_fmul+0x56>
 8000518:	4642      	mov	r2, r8
 800051a:	2301      	movs	r3, #1
 800051c:	2a00      	cmp	r2, #0
 800051e:	d0c4      	beq.n	80004aa <__aeabi_fmul+0x56>
 8000520:	4640      	mov	r0, r8
 8000522:	f001 fbb3 	bl	8001c8c <__clzsi2>
 8000526:	4642      	mov	r2, r8
 8000528:	1f43      	subs	r3, r0, #5
 800052a:	409a      	lsls	r2, r3
 800052c:	2376      	movs	r3, #118	; 0x76
 800052e:	425b      	negs	r3, r3
 8000530:	1a18      	subs	r0, r3, r0
 8000532:	4690      	mov	r8, r2
 8000534:	2300      	movs	r3, #0
 8000536:	e7b8      	b.n	80004aa <__aeabi_fmul+0x56>
 8000538:	2b03      	cmp	r3, #3
 800053a:	d100      	bne.n	800053e <__aeabi_fmul+0xea>
 800053c:	e0ad      	b.n	800069a <__aeabi_fmul+0x246>
 800053e:	2b01      	cmp	r3, #1
 8000540:	d000      	beq.n	8000544 <__aeabi_fmul+0xf0>
 8000542:	e08c      	b.n	800065e <__aeabi_fmul+0x20a>
 8000544:	465b      	mov	r3, fp
 8000546:	4654      	mov	r4, sl
 8000548:	401c      	ands	r4, r3
 800054a:	b2e4      	uxtb	r4, r4
 800054c:	2300      	movs	r3, #0
 800054e:	2500      	movs	r5, #0
 8000550:	e7c7      	b.n	80004e2 <__aeabi_fmul+0x8e>
 8000552:	230c      	movs	r3, #12
 8000554:	9301      	str	r3, [sp, #4]
 8000556:	3b09      	subs	r3, #9
 8000558:	469a      	mov	sl, r3
 800055a:	e794      	b.n	8000486 <__aeabi_fmul+0x32>
 800055c:	1c28      	adds	r0, r5, #0
 800055e:	f001 fb95 	bl	8001c8c <__clzsi2>
 8000562:	2676      	movs	r6, #118	; 0x76
 8000564:	1f43      	subs	r3, r0, #5
 8000566:	409d      	lsls	r5, r3
 8000568:	2300      	movs	r3, #0
 800056a:	4276      	negs	r6, r6
 800056c:	1a36      	subs	r6, r6, r0
 800056e:	9301      	str	r3, [sp, #4]
 8000570:	469a      	mov	sl, r3
 8000572:	e788      	b.n	8000486 <__aeabi_fmul+0x32>
 8000574:	2580      	movs	r5, #128	; 0x80
 8000576:	2400      	movs	r4, #0
 8000578:	03ed      	lsls	r5, r5, #15
 800057a:	23ff      	movs	r3, #255	; 0xff
 800057c:	e7b1      	b.n	80004e2 <__aeabi_fmul+0x8e>
 800057e:	4645      	mov	r5, r8
 8000580:	46cb      	mov	fp, r9
 8000582:	469a      	mov	sl, r3
 8000584:	e7a5      	b.n	80004d2 <__aeabi_fmul+0x7e>
 8000586:	4645      	mov	r5, r8
 8000588:	4693      	mov	fp, r2
 800058a:	469a      	mov	sl, r3
 800058c:	e7a1      	b.n	80004d2 <__aeabi_fmul+0x7e>
 800058e:	4643      	mov	r3, r8
 8000590:	042c      	lsls	r4, r5, #16
 8000592:	0c1b      	lsrs	r3, r3, #16
 8000594:	469c      	mov	ip, r3
 8000596:	0c23      	lsrs	r3, r4, #16
 8000598:	4644      	mov	r4, r8
 800059a:	0426      	lsls	r6, r4, #16
 800059c:	1c1c      	adds	r4, r3, #0
 800059e:	0c36      	lsrs	r6, r6, #16
 80005a0:	0c2f      	lsrs	r7, r5, #16
 80005a2:	4374      	muls	r4, r6
 80005a4:	1c35      	adds	r5, r6, #0
 80005a6:	4666      	mov	r6, ip
 80005a8:	437d      	muls	r5, r7
 80005aa:	4373      	muls	r3, r6
 80005ac:	4377      	muls	r7, r6
 80005ae:	18eb      	adds	r3, r5, r3
 80005b0:	0c26      	lsrs	r6, r4, #16
 80005b2:	199e      	adds	r6, r3, r6
 80005b4:	42b5      	cmp	r5, r6
 80005b6:	d903      	bls.n	80005c0 <__aeabi_fmul+0x16c>
 80005b8:	2380      	movs	r3, #128	; 0x80
 80005ba:	025b      	lsls	r3, r3, #9
 80005bc:	469c      	mov	ip, r3
 80005be:	4467      	add	r7, ip
 80005c0:	0424      	lsls	r4, r4, #16
 80005c2:	0433      	lsls	r3, r6, #16
 80005c4:	0c24      	lsrs	r4, r4, #16
 80005c6:	191b      	adds	r3, r3, r4
 80005c8:	019d      	lsls	r5, r3, #6
 80005ca:	1e6c      	subs	r4, r5, #1
 80005cc:	41a5      	sbcs	r5, r4
 80005ce:	0e9b      	lsrs	r3, r3, #26
 80005d0:	0c36      	lsrs	r6, r6, #16
 80005d2:	432b      	orrs	r3, r5
 80005d4:	19bd      	adds	r5, r7, r6
 80005d6:	01ad      	lsls	r5, r5, #6
 80005d8:	431d      	orrs	r5, r3
 80005da:	012b      	lsls	r3, r5, #4
 80005dc:	d504      	bpl.n	80005e8 <__aeabi_fmul+0x194>
 80005de:	2301      	movs	r3, #1
 80005e0:	0868      	lsrs	r0, r5, #1
 80005e2:	401d      	ands	r5, r3
 80005e4:	4305      	orrs	r5, r0
 80005e6:	1c08      	adds	r0, r1, #0
 80005e8:	1c03      	adds	r3, r0, #0
 80005ea:	337f      	adds	r3, #127	; 0x7f
 80005ec:	2b00      	cmp	r3, #0
 80005ee:	dd2c      	ble.n	800064a <__aeabi_fmul+0x1f6>
 80005f0:	0769      	lsls	r1, r5, #29
 80005f2:	d004      	beq.n	80005fe <__aeabi_fmul+0x1aa>
 80005f4:	210f      	movs	r1, #15
 80005f6:	4029      	ands	r1, r5
 80005f8:	2904      	cmp	r1, #4
 80005fa:	d000      	beq.n	80005fe <__aeabi_fmul+0x1aa>
 80005fc:	3504      	adds	r5, #4
 80005fe:	0129      	lsls	r1, r5, #4
 8000600:	d503      	bpl.n	800060a <__aeabi_fmul+0x1b6>
 8000602:	4b2c      	ldr	r3, [pc, #176]	; (80006b4 <__aeabi_fmul+0x260>)
 8000604:	401d      	ands	r5, r3
 8000606:	1c03      	adds	r3, r0, #0
 8000608:	3380      	adds	r3, #128	; 0x80
 800060a:	2bfe      	cmp	r3, #254	; 0xfe
 800060c:	dd17      	ble.n	800063e <__aeabi_fmul+0x1ea>
 800060e:	2401      	movs	r4, #1
 8000610:	23ff      	movs	r3, #255	; 0xff
 8000612:	4014      	ands	r4, r2
 8000614:	2500      	movs	r5, #0
 8000616:	e764      	b.n	80004e2 <__aeabi_fmul+0x8e>
 8000618:	2080      	movs	r0, #128	; 0x80
 800061a:	03c0      	lsls	r0, r0, #15
 800061c:	4205      	tst	r5, r0
 800061e:	d009      	beq.n	8000634 <__aeabi_fmul+0x1e0>
 8000620:	4643      	mov	r3, r8
 8000622:	4203      	tst	r3, r0
 8000624:	d106      	bne.n	8000634 <__aeabi_fmul+0x1e0>
 8000626:	4645      	mov	r5, r8
 8000628:	4305      	orrs	r5, r0
 800062a:	026d      	lsls	r5, r5, #9
 800062c:	0a6d      	lsrs	r5, r5, #9
 800062e:	464c      	mov	r4, r9
 8000630:	23ff      	movs	r3, #255	; 0xff
 8000632:	e756      	b.n	80004e2 <__aeabi_fmul+0x8e>
 8000634:	4305      	orrs	r5, r0
 8000636:	026d      	lsls	r5, r5, #9
 8000638:	0a6d      	lsrs	r5, r5, #9
 800063a:	23ff      	movs	r3, #255	; 0xff
 800063c:	e751      	b.n	80004e2 <__aeabi_fmul+0x8e>
 800063e:	2401      	movs	r4, #1
 8000640:	01ad      	lsls	r5, r5, #6
 8000642:	0a6d      	lsrs	r5, r5, #9
 8000644:	b2db      	uxtb	r3, r3
 8000646:	4014      	ands	r4, r2
 8000648:	e74b      	b.n	80004e2 <__aeabi_fmul+0x8e>
 800064a:	237e      	movs	r3, #126	; 0x7e
 800064c:	425b      	negs	r3, r3
 800064e:	1a1b      	subs	r3, r3, r0
 8000650:	2b1b      	cmp	r3, #27
 8000652:	dd07      	ble.n	8000664 <__aeabi_fmul+0x210>
 8000654:	2401      	movs	r4, #1
 8000656:	2300      	movs	r3, #0
 8000658:	4014      	ands	r4, r2
 800065a:	2500      	movs	r5, #0
 800065c:	e741      	b.n	80004e2 <__aeabi_fmul+0x8e>
 800065e:	1c08      	adds	r0, r1, #0
 8000660:	465a      	mov	r2, fp
 8000662:	e7c1      	b.n	80005e8 <__aeabi_fmul+0x194>
 8000664:	309e      	adds	r0, #158	; 0x9e
 8000666:	1c29      	adds	r1, r5, #0
 8000668:	4085      	lsls	r5, r0
 800066a:	40d9      	lsrs	r1, r3
 800066c:	1e68      	subs	r0, r5, #1
 800066e:	4185      	sbcs	r5, r0
 8000670:	430d      	orrs	r5, r1
 8000672:	076b      	lsls	r3, r5, #29
 8000674:	d004      	beq.n	8000680 <__aeabi_fmul+0x22c>
 8000676:	230f      	movs	r3, #15
 8000678:	402b      	ands	r3, r5
 800067a:	2b04      	cmp	r3, #4
 800067c:	d000      	beq.n	8000680 <__aeabi_fmul+0x22c>
 800067e:	3504      	adds	r5, #4
 8000680:	016b      	lsls	r3, r5, #5
 8000682:	d504      	bpl.n	800068e <__aeabi_fmul+0x23a>
 8000684:	2401      	movs	r4, #1
 8000686:	2301      	movs	r3, #1
 8000688:	4014      	ands	r4, r2
 800068a:	2500      	movs	r5, #0
 800068c:	e729      	b.n	80004e2 <__aeabi_fmul+0x8e>
 800068e:	2401      	movs	r4, #1
 8000690:	01ad      	lsls	r5, r5, #6
 8000692:	0a6d      	lsrs	r5, r5, #9
 8000694:	4014      	ands	r4, r2
 8000696:	2300      	movs	r3, #0
 8000698:	e723      	b.n	80004e2 <__aeabi_fmul+0x8e>
 800069a:	2380      	movs	r3, #128	; 0x80
 800069c:	03db      	lsls	r3, r3, #15
 800069e:	431d      	orrs	r5, r3
 80006a0:	2401      	movs	r4, #1
 80006a2:	465b      	mov	r3, fp
 80006a4:	026d      	lsls	r5, r5, #9
 80006a6:	4023      	ands	r3, r4
 80006a8:	1c1c      	adds	r4, r3, #0
 80006aa:	0a6d      	lsrs	r5, r5, #9
 80006ac:	23ff      	movs	r3, #255	; 0xff
 80006ae:	e718      	b.n	80004e2 <__aeabi_fmul+0x8e>
 80006b0:	080056a4 	.word	0x080056a4
 80006b4:	f7ffffff 	.word	0xf7ffffff

080006b8 <__aeabi_ddiv>:
 80006b8:	b5f0      	push	{r4, r5, r6, r7, lr}
 80006ba:	465f      	mov	r7, fp
 80006bc:	4656      	mov	r6, sl
 80006be:	464d      	mov	r5, r9
 80006c0:	4644      	mov	r4, r8
 80006c2:	b4f0      	push	{r4, r5, r6, r7}
 80006c4:	030f      	lsls	r7, r1, #12
 80006c6:	b087      	sub	sp, #28
 80006c8:	4698      	mov	r8, r3
 80006ca:	004d      	lsls	r5, r1, #1
 80006cc:	0b3b      	lsrs	r3, r7, #12
 80006ce:	0fcc      	lsrs	r4, r1, #31
 80006d0:	1c06      	adds	r6, r0, #0
 80006d2:	4692      	mov	sl, r2
 80006d4:	4681      	mov	r9, r0
 80006d6:	469b      	mov	fp, r3
 80006d8:	0d6d      	lsrs	r5, r5, #21
 80006da:	9401      	str	r4, [sp, #4]
 80006dc:	d06b      	beq.n	80007b6 <__aeabi_ddiv+0xfe>
 80006de:	4b66      	ldr	r3, [pc, #408]	; (8000878 <__aeabi_ddiv+0x1c0>)
 80006e0:	429d      	cmp	r5, r3
 80006e2:	d035      	beq.n	8000750 <__aeabi_ddiv+0x98>
 80006e4:	2780      	movs	r7, #128	; 0x80
 80006e6:	465b      	mov	r3, fp
 80006e8:	037f      	lsls	r7, r7, #13
 80006ea:	431f      	orrs	r7, r3
 80006ec:	00f3      	lsls	r3, r6, #3
 80006ee:	4699      	mov	r9, r3
 80006f0:	4b62      	ldr	r3, [pc, #392]	; (800087c <__aeabi_ddiv+0x1c4>)
 80006f2:	00ff      	lsls	r7, r7, #3
 80006f4:	0f40      	lsrs	r0, r0, #29
 80006f6:	469c      	mov	ip, r3
 80006f8:	4307      	orrs	r7, r0
 80006fa:	2300      	movs	r3, #0
 80006fc:	46bb      	mov	fp, r7
 80006fe:	2600      	movs	r6, #0
 8000700:	4465      	add	r5, ip
 8000702:	9300      	str	r3, [sp, #0]
 8000704:	4642      	mov	r2, r8
 8000706:	0317      	lsls	r7, r2, #12
 8000708:	0050      	lsls	r0, r2, #1
 800070a:	0fd2      	lsrs	r2, r2, #31
 800070c:	4653      	mov	r3, sl
 800070e:	0b3f      	lsrs	r7, r7, #12
 8000710:	0d40      	lsrs	r0, r0, #21
 8000712:	4690      	mov	r8, r2
 8000714:	d100      	bne.n	8000718 <__aeabi_ddiv+0x60>
 8000716:	e072      	b.n	80007fe <__aeabi_ddiv+0x146>
 8000718:	4a57      	ldr	r2, [pc, #348]	; (8000878 <__aeabi_ddiv+0x1c0>)
 800071a:	4290      	cmp	r0, r2
 800071c:	d067      	beq.n	80007ee <__aeabi_ddiv+0x136>
 800071e:	2380      	movs	r3, #128	; 0x80
 8000720:	035b      	lsls	r3, r3, #13
 8000722:	431f      	orrs	r7, r3
 8000724:	4653      	mov	r3, sl
 8000726:	4a55      	ldr	r2, [pc, #340]	; (800087c <__aeabi_ddiv+0x1c4>)
 8000728:	0f5b      	lsrs	r3, r3, #29
 800072a:	00ff      	lsls	r7, r7, #3
 800072c:	431f      	orrs	r7, r3
 800072e:	4694      	mov	ip, r2
 8000730:	4653      	mov	r3, sl
 8000732:	2100      	movs	r1, #0
 8000734:	00db      	lsls	r3, r3, #3
 8000736:	4460      	add	r0, ip
 8000738:	4642      	mov	r2, r8
 800073a:	4062      	eors	r2, r4
 800073c:	4692      	mov	sl, r2
 800073e:	1a2d      	subs	r5, r5, r0
 8000740:	430e      	orrs	r6, r1
 8000742:	2e0f      	cmp	r6, #15
 8000744:	d900      	bls.n	8000748 <__aeabi_ddiv+0x90>
 8000746:	e0a1      	b.n	800088c <__aeabi_ddiv+0x1d4>
 8000748:	484d      	ldr	r0, [pc, #308]	; (8000880 <__aeabi_ddiv+0x1c8>)
 800074a:	00b6      	lsls	r6, r6, #2
 800074c:	5980      	ldr	r0, [r0, r6]
 800074e:	4687      	mov	pc, r0
 8000750:	465b      	mov	r3, fp
 8000752:	431e      	orrs	r6, r3
 8000754:	d000      	beq.n	8000758 <__aeabi_ddiv+0xa0>
 8000756:	e076      	b.n	8000846 <__aeabi_ddiv+0x18e>
 8000758:	2300      	movs	r3, #0
 800075a:	469b      	mov	fp, r3
 800075c:	4699      	mov	r9, r3
 800075e:	3302      	adds	r3, #2
 8000760:	2608      	movs	r6, #8
 8000762:	9300      	str	r3, [sp, #0]
 8000764:	e7ce      	b.n	8000704 <__aeabi_ddiv+0x4c>
 8000766:	4699      	mov	r9, r3
 8000768:	4643      	mov	r3, r8
 800076a:	46bb      	mov	fp, r7
 800076c:	9301      	str	r3, [sp, #4]
 800076e:	9100      	str	r1, [sp, #0]
 8000770:	9b00      	ldr	r3, [sp, #0]
 8000772:	2b02      	cmp	r3, #2
 8000774:	d16b      	bne.n	800084e <__aeabi_ddiv+0x196>
 8000776:	9b01      	ldr	r3, [sp, #4]
 8000778:	469a      	mov	sl, r3
 800077a:	2100      	movs	r1, #0
 800077c:	4653      	mov	r3, sl
 800077e:	2201      	movs	r2, #1
 8000780:	2700      	movs	r7, #0
 8000782:	4689      	mov	r9, r1
 8000784:	401a      	ands	r2, r3
 8000786:	4b3c      	ldr	r3, [pc, #240]	; (8000878 <__aeabi_ddiv+0x1c0>)
 8000788:	2100      	movs	r1, #0
 800078a:	033f      	lsls	r7, r7, #12
 800078c:	0d0c      	lsrs	r4, r1, #20
 800078e:	0524      	lsls	r4, r4, #20
 8000790:	0b3f      	lsrs	r7, r7, #12
 8000792:	4327      	orrs	r7, r4
 8000794:	4c3b      	ldr	r4, [pc, #236]	; (8000884 <__aeabi_ddiv+0x1cc>)
 8000796:	051b      	lsls	r3, r3, #20
 8000798:	4027      	ands	r7, r4
 800079a:	431f      	orrs	r7, r3
 800079c:	007f      	lsls	r7, r7, #1
 800079e:	07d2      	lsls	r2, r2, #31
 80007a0:	087f      	lsrs	r7, r7, #1
 80007a2:	4317      	orrs	r7, r2
 80007a4:	4648      	mov	r0, r9
 80007a6:	1c39      	adds	r1, r7, #0
 80007a8:	b007      	add	sp, #28
 80007aa:	bc3c      	pop	{r2, r3, r4, r5}
 80007ac:	4690      	mov	r8, r2
 80007ae:	4699      	mov	r9, r3
 80007b0:	46a2      	mov	sl, r4
 80007b2:	46ab      	mov	fp, r5
 80007b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80007b6:	4303      	orrs	r3, r0
 80007b8:	d03e      	beq.n	8000838 <__aeabi_ddiv+0x180>
 80007ba:	465b      	mov	r3, fp
 80007bc:	2b00      	cmp	r3, #0
 80007be:	d100      	bne.n	80007c2 <__aeabi_ddiv+0x10a>
 80007c0:	e19c      	b.n	8000afc <__aeabi_ddiv+0x444>
 80007c2:	4658      	mov	r0, fp
 80007c4:	f001 fa62 	bl	8001c8c <__clzsi2>
 80007c8:	2328      	movs	r3, #40	; 0x28
 80007ca:	1c31      	adds	r1, r6, #0
 80007cc:	1a1b      	subs	r3, r3, r0
 80007ce:	1c02      	adds	r2, r0, #0
 80007d0:	465f      	mov	r7, fp
 80007d2:	40d9      	lsrs	r1, r3
 80007d4:	3a08      	subs	r2, #8
 80007d6:	4097      	lsls	r7, r2
 80007d8:	1c0b      	adds	r3, r1, #0
 80007da:	4096      	lsls	r6, r2
 80007dc:	433b      	orrs	r3, r7
 80007de:	469b      	mov	fp, r3
 80007e0:	46b1      	mov	r9, r6
 80007e2:	2300      	movs	r3, #0
 80007e4:	4d28      	ldr	r5, [pc, #160]	; (8000888 <__aeabi_ddiv+0x1d0>)
 80007e6:	2600      	movs	r6, #0
 80007e8:	1a2d      	subs	r5, r5, r0
 80007ea:	9300      	str	r3, [sp, #0]
 80007ec:	e78a      	b.n	8000704 <__aeabi_ddiv+0x4c>
 80007ee:	4652      	mov	r2, sl
 80007f0:	2103      	movs	r1, #3
 80007f2:	433a      	orrs	r2, r7
 80007f4:	d1a0      	bne.n	8000738 <__aeabi_ddiv+0x80>
 80007f6:	2700      	movs	r7, #0
 80007f8:	2300      	movs	r3, #0
 80007fa:	2102      	movs	r1, #2
 80007fc:	e79c      	b.n	8000738 <__aeabi_ddiv+0x80>
 80007fe:	4652      	mov	r2, sl
 8000800:	433a      	orrs	r2, r7
 8000802:	d015      	beq.n	8000830 <__aeabi_ddiv+0x178>
 8000804:	2f00      	cmp	r7, #0
 8000806:	d100      	bne.n	800080a <__aeabi_ddiv+0x152>
 8000808:	e185      	b.n	8000b16 <__aeabi_ddiv+0x45e>
 800080a:	1c38      	adds	r0, r7, #0
 800080c:	f001 fa3e 	bl	8001c8c <__clzsi2>
 8000810:	1c02      	adds	r2, r0, #0
 8000812:	2128      	movs	r1, #40	; 0x28
 8000814:	4650      	mov	r0, sl
 8000816:	1a89      	subs	r1, r1, r2
 8000818:	1c13      	adds	r3, r2, #0
 800081a:	40c8      	lsrs	r0, r1
 800081c:	4651      	mov	r1, sl
 800081e:	3b08      	subs	r3, #8
 8000820:	4099      	lsls	r1, r3
 8000822:	409f      	lsls	r7, r3
 8000824:	1c0b      	adds	r3, r1, #0
 8000826:	4307      	orrs	r7, r0
 8000828:	4817      	ldr	r0, [pc, #92]	; (8000888 <__aeabi_ddiv+0x1d0>)
 800082a:	2100      	movs	r1, #0
 800082c:	1a80      	subs	r0, r0, r2
 800082e:	e783      	b.n	8000738 <__aeabi_ddiv+0x80>
 8000830:	2700      	movs	r7, #0
 8000832:	2300      	movs	r3, #0
 8000834:	2101      	movs	r1, #1
 8000836:	e77f      	b.n	8000738 <__aeabi_ddiv+0x80>
 8000838:	2300      	movs	r3, #0
 800083a:	469b      	mov	fp, r3
 800083c:	4699      	mov	r9, r3
 800083e:	3301      	adds	r3, #1
 8000840:	2604      	movs	r6, #4
 8000842:	9300      	str	r3, [sp, #0]
 8000844:	e75e      	b.n	8000704 <__aeabi_ddiv+0x4c>
 8000846:	2303      	movs	r3, #3
 8000848:	260c      	movs	r6, #12
 800084a:	9300      	str	r3, [sp, #0]
 800084c:	e75a      	b.n	8000704 <__aeabi_ddiv+0x4c>
 800084e:	2b03      	cmp	r3, #3
 8000850:	d100      	bne.n	8000854 <__aeabi_ddiv+0x19c>
 8000852:	e23c      	b.n	8000cce <__aeabi_ddiv+0x616>
 8000854:	2b01      	cmp	r3, #1
 8000856:	d000      	beq.n	800085a <__aeabi_ddiv+0x1a2>
 8000858:	e1bf      	b.n	8000bda <__aeabi_ddiv+0x522>
 800085a:	1c1a      	adds	r2, r3, #0
 800085c:	9b01      	ldr	r3, [sp, #4]
 800085e:	401a      	ands	r2, r3
 8000860:	2100      	movs	r1, #0
 8000862:	2300      	movs	r3, #0
 8000864:	2700      	movs	r7, #0
 8000866:	4689      	mov	r9, r1
 8000868:	e78e      	b.n	8000788 <__aeabi_ddiv+0xd0>
 800086a:	2300      	movs	r3, #0
 800086c:	2780      	movs	r7, #128	; 0x80
 800086e:	4699      	mov	r9, r3
 8000870:	2200      	movs	r2, #0
 8000872:	033f      	lsls	r7, r7, #12
 8000874:	4b00      	ldr	r3, [pc, #0]	; (8000878 <__aeabi_ddiv+0x1c0>)
 8000876:	e787      	b.n	8000788 <__aeabi_ddiv+0xd0>
 8000878:	000007ff 	.word	0x000007ff
 800087c:	fffffc01 	.word	0xfffffc01
 8000880:	080056e4 	.word	0x080056e4
 8000884:	800fffff 	.word	0x800fffff
 8000888:	fffffc0d 	.word	0xfffffc0d
 800088c:	45bb      	cmp	fp, r7
 800088e:	d900      	bls.n	8000892 <__aeabi_ddiv+0x1da>
 8000890:	e151      	b.n	8000b36 <__aeabi_ddiv+0x47e>
 8000892:	d100      	bne.n	8000896 <__aeabi_ddiv+0x1de>
 8000894:	e14c      	b.n	8000b30 <__aeabi_ddiv+0x478>
 8000896:	464a      	mov	r2, r9
 8000898:	9203      	str	r2, [sp, #12]
 800089a:	2200      	movs	r2, #0
 800089c:	465c      	mov	r4, fp
 800089e:	4690      	mov	r8, r2
 80008a0:	3d01      	subs	r5, #1
 80008a2:	0e18      	lsrs	r0, r3, #24
 80008a4:	023f      	lsls	r7, r7, #8
 80008a6:	4338      	orrs	r0, r7
 80008a8:	021b      	lsls	r3, r3, #8
 80008aa:	9301      	str	r3, [sp, #4]
 80008ac:	0c03      	lsrs	r3, r0, #16
 80008ae:	4699      	mov	r9, r3
 80008b0:	0403      	lsls	r3, r0, #16
 80008b2:	0c1b      	lsrs	r3, r3, #16
 80008b4:	4649      	mov	r1, r9
 80008b6:	1c06      	adds	r6, r0, #0
 80008b8:	1c20      	adds	r0, r4, #0
 80008ba:	1c1f      	adds	r7, r3, #0
 80008bc:	9300      	str	r3, [sp, #0]
 80008be:	f001 f953 	bl	8001b68 <__aeabi_uidiv>
 80008c2:	1c02      	adds	r2, r0, #0
 80008c4:	437a      	muls	r2, r7
 80008c6:	9002      	str	r0, [sp, #8]
 80008c8:	4649      	mov	r1, r9
 80008ca:	1c20      	adds	r0, r4, #0
 80008cc:	1c17      	adds	r7, r2, #0
 80008ce:	f001 f9d1 	bl	8001c74 <__aeabi_uidivmod>
 80008d2:	9b03      	ldr	r3, [sp, #12]
 80008d4:	0409      	lsls	r1, r1, #16
 80008d6:	0c1b      	lsrs	r3, r3, #16
 80008d8:	4319      	orrs	r1, r3
 80008da:	428f      	cmp	r7, r1
 80008dc:	d90c      	bls.n	80008f8 <__aeabi_ddiv+0x240>
 80008de:	9b02      	ldr	r3, [sp, #8]
 80008e0:	1989      	adds	r1, r1, r6
 80008e2:	3b01      	subs	r3, #1
 80008e4:	428e      	cmp	r6, r1
 80008e6:	d900      	bls.n	80008ea <__aeabi_ddiv+0x232>
 80008e8:	e152      	b.n	8000b90 <__aeabi_ddiv+0x4d8>
 80008ea:	428f      	cmp	r7, r1
 80008ec:	d800      	bhi.n	80008f0 <__aeabi_ddiv+0x238>
 80008ee:	e14f      	b.n	8000b90 <__aeabi_ddiv+0x4d8>
 80008f0:	9b02      	ldr	r3, [sp, #8]
 80008f2:	1989      	adds	r1, r1, r6
 80008f4:	3b02      	subs	r3, #2
 80008f6:	9302      	str	r3, [sp, #8]
 80008f8:	1bcc      	subs	r4, r1, r7
 80008fa:	1c20      	adds	r0, r4, #0
 80008fc:	4649      	mov	r1, r9
 80008fe:	f001 f933 	bl	8001b68 <__aeabi_uidiv>
 8000902:	9f00      	ldr	r7, [sp, #0]
 8000904:	4683      	mov	fp, r0
 8000906:	4347      	muls	r7, r0
 8000908:	4649      	mov	r1, r9
 800090a:	1c20      	adds	r0, r4, #0
 800090c:	f001 f9b2 	bl	8001c74 <__aeabi_uidivmod>
 8000910:	9a03      	ldr	r2, [sp, #12]
 8000912:	040b      	lsls	r3, r1, #16
 8000914:	0414      	lsls	r4, r2, #16
 8000916:	0c24      	lsrs	r4, r4, #16
 8000918:	4323      	orrs	r3, r4
 800091a:	429f      	cmp	r7, r3
 800091c:	d90d      	bls.n	800093a <__aeabi_ddiv+0x282>
 800091e:	465a      	mov	r2, fp
 8000920:	199b      	adds	r3, r3, r6
 8000922:	3a01      	subs	r2, #1
 8000924:	429e      	cmp	r6, r3
 8000926:	d900      	bls.n	800092a <__aeabi_ddiv+0x272>
 8000928:	e130      	b.n	8000b8c <__aeabi_ddiv+0x4d4>
 800092a:	429f      	cmp	r7, r3
 800092c:	d800      	bhi.n	8000930 <__aeabi_ddiv+0x278>
 800092e:	e12d      	b.n	8000b8c <__aeabi_ddiv+0x4d4>
 8000930:	2202      	movs	r2, #2
 8000932:	4252      	negs	r2, r2
 8000934:	4694      	mov	ip, r2
 8000936:	199b      	adds	r3, r3, r6
 8000938:	44e3      	add	fp, ip
 800093a:	9a02      	ldr	r2, [sp, #8]
 800093c:	1bdb      	subs	r3, r3, r7
 800093e:	0417      	lsls	r7, r2, #16
 8000940:	465a      	mov	r2, fp
 8000942:	433a      	orrs	r2, r7
 8000944:	4693      	mov	fp, r2
 8000946:	9c01      	ldr	r4, [sp, #4]
 8000948:	0c17      	lsrs	r7, r2, #16
 800094a:	0c22      	lsrs	r2, r4, #16
 800094c:	1c10      	adds	r0, r2, #0
 800094e:	9204      	str	r2, [sp, #16]
 8000950:	465a      	mov	r2, fp
 8000952:	0411      	lsls	r1, r2, #16
 8000954:	0422      	lsls	r2, r4, #16
 8000956:	0c12      	lsrs	r2, r2, #16
 8000958:	1c14      	adds	r4, r2, #0
 800095a:	0c09      	lsrs	r1, r1, #16
 800095c:	437c      	muls	r4, r7
 800095e:	9205      	str	r2, [sp, #20]
 8000960:	434a      	muls	r2, r1
 8000962:	4341      	muls	r1, r0
 8000964:	4347      	muls	r7, r0
 8000966:	1861      	adds	r1, r4, r1
 8000968:	0c10      	lsrs	r0, r2, #16
 800096a:	1809      	adds	r1, r1, r0
 800096c:	428c      	cmp	r4, r1
 800096e:	d903      	bls.n	8000978 <__aeabi_ddiv+0x2c0>
 8000970:	2080      	movs	r0, #128	; 0x80
 8000972:	0240      	lsls	r0, r0, #9
 8000974:	4684      	mov	ip, r0
 8000976:	4467      	add	r7, ip
 8000978:	0c0c      	lsrs	r4, r1, #16
 800097a:	0412      	lsls	r2, r2, #16
 800097c:	0408      	lsls	r0, r1, #16
 800097e:	0c12      	lsrs	r2, r2, #16
 8000980:	193c      	adds	r4, r7, r4
 8000982:	1881      	adds	r1, r0, r2
 8000984:	42a3      	cmp	r3, r4
 8000986:	d200      	bcs.n	800098a <__aeabi_ddiv+0x2d2>
 8000988:	e0e5      	b.n	8000b56 <__aeabi_ddiv+0x49e>
 800098a:	d100      	bne.n	800098e <__aeabi_ddiv+0x2d6>
 800098c:	e0df      	b.n	8000b4e <__aeabi_ddiv+0x496>
 800098e:	1b1f      	subs	r7, r3, r4
 8000990:	4643      	mov	r3, r8
 8000992:	1a5c      	subs	r4, r3, r1
 8000994:	45a0      	cmp	r8, r4
 8000996:	4192      	sbcs	r2, r2
 8000998:	4252      	negs	r2, r2
 800099a:	1abf      	subs	r7, r7, r2
 800099c:	42b7      	cmp	r7, r6
 800099e:	d100      	bne.n	80009a2 <__aeabi_ddiv+0x2ea>
 80009a0:	e10e      	b.n	8000bc0 <__aeabi_ddiv+0x508>
 80009a2:	1c38      	adds	r0, r7, #0
 80009a4:	4649      	mov	r1, r9
 80009a6:	f001 f8df 	bl	8001b68 <__aeabi_uidiv>
 80009aa:	9b00      	ldr	r3, [sp, #0]
 80009ac:	9002      	str	r0, [sp, #8]
 80009ae:	4343      	muls	r3, r0
 80009b0:	4649      	mov	r1, r9
 80009b2:	1c38      	adds	r0, r7, #0
 80009b4:	4698      	mov	r8, r3
 80009b6:	f001 f95d 	bl	8001c74 <__aeabi_uidivmod>
 80009ba:	0c23      	lsrs	r3, r4, #16
 80009bc:	040f      	lsls	r7, r1, #16
 80009be:	431f      	orrs	r7, r3
 80009c0:	45b8      	cmp	r8, r7
 80009c2:	d90c      	bls.n	80009de <__aeabi_ddiv+0x326>
 80009c4:	9b02      	ldr	r3, [sp, #8]
 80009c6:	19bf      	adds	r7, r7, r6
 80009c8:	3b01      	subs	r3, #1
 80009ca:	42be      	cmp	r6, r7
 80009cc:	d900      	bls.n	80009d0 <__aeabi_ddiv+0x318>
 80009ce:	e0fb      	b.n	8000bc8 <__aeabi_ddiv+0x510>
 80009d0:	45b8      	cmp	r8, r7
 80009d2:	d800      	bhi.n	80009d6 <__aeabi_ddiv+0x31e>
 80009d4:	e0f8      	b.n	8000bc8 <__aeabi_ddiv+0x510>
 80009d6:	9b02      	ldr	r3, [sp, #8]
 80009d8:	19bf      	adds	r7, r7, r6
 80009da:	3b02      	subs	r3, #2
 80009dc:	9302      	str	r3, [sp, #8]
 80009de:	4643      	mov	r3, r8
 80009e0:	1aff      	subs	r7, r7, r3
 80009e2:	4649      	mov	r1, r9
 80009e4:	1c38      	adds	r0, r7, #0
 80009e6:	f001 f8bf 	bl	8001b68 <__aeabi_uidiv>
 80009ea:	9b00      	ldr	r3, [sp, #0]
 80009ec:	9003      	str	r0, [sp, #12]
 80009ee:	4343      	muls	r3, r0
 80009f0:	4649      	mov	r1, r9
 80009f2:	1c38      	adds	r0, r7, #0
 80009f4:	4698      	mov	r8, r3
 80009f6:	f001 f93d 	bl	8001c74 <__aeabi_uidivmod>
 80009fa:	0424      	lsls	r4, r4, #16
 80009fc:	0409      	lsls	r1, r1, #16
 80009fe:	0c24      	lsrs	r4, r4, #16
 8000a00:	4321      	orrs	r1, r4
 8000a02:	4588      	cmp	r8, r1
 8000a04:	d90c      	bls.n	8000a20 <__aeabi_ddiv+0x368>
 8000a06:	9b03      	ldr	r3, [sp, #12]
 8000a08:	1989      	adds	r1, r1, r6
 8000a0a:	3b01      	subs	r3, #1
 8000a0c:	428e      	cmp	r6, r1
 8000a0e:	d900      	bls.n	8000a12 <__aeabi_ddiv+0x35a>
 8000a10:	e0dc      	b.n	8000bcc <__aeabi_ddiv+0x514>
 8000a12:	4588      	cmp	r8, r1
 8000a14:	d800      	bhi.n	8000a18 <__aeabi_ddiv+0x360>
 8000a16:	e0d9      	b.n	8000bcc <__aeabi_ddiv+0x514>
 8000a18:	9b03      	ldr	r3, [sp, #12]
 8000a1a:	1989      	adds	r1, r1, r6
 8000a1c:	3b02      	subs	r3, #2
 8000a1e:	9303      	str	r3, [sp, #12]
 8000a20:	4643      	mov	r3, r8
 8000a22:	1ac9      	subs	r1, r1, r3
 8000a24:	9b02      	ldr	r3, [sp, #8]
 8000a26:	9a03      	ldr	r2, [sp, #12]
 8000a28:	041b      	lsls	r3, r3, #16
 8000a2a:	9c05      	ldr	r4, [sp, #20]
 8000a2c:	431a      	orrs	r2, r3
 8000a2e:	0c10      	lsrs	r0, r2, #16
 8000a30:	0413      	lsls	r3, r2, #16
 8000a32:	4691      	mov	r9, r2
 8000a34:	1c22      	adds	r2, r4, #0
 8000a36:	9f04      	ldr	r7, [sp, #16]
 8000a38:	0c1b      	lsrs	r3, r3, #16
 8000a3a:	435a      	muls	r2, r3
 8000a3c:	4344      	muls	r4, r0
 8000a3e:	437b      	muls	r3, r7
 8000a40:	4378      	muls	r0, r7
 8000a42:	18e3      	adds	r3, r4, r3
 8000a44:	0c17      	lsrs	r7, r2, #16
 8000a46:	19db      	adds	r3, r3, r7
 8000a48:	429c      	cmp	r4, r3
 8000a4a:	d903      	bls.n	8000a54 <__aeabi_ddiv+0x39c>
 8000a4c:	2480      	movs	r4, #128	; 0x80
 8000a4e:	0264      	lsls	r4, r4, #9
 8000a50:	46a4      	mov	ip, r4
 8000a52:	4460      	add	r0, ip
 8000a54:	0c1c      	lsrs	r4, r3, #16
 8000a56:	0412      	lsls	r2, r2, #16
 8000a58:	041b      	lsls	r3, r3, #16
 8000a5a:	0c12      	lsrs	r2, r2, #16
 8000a5c:	1900      	adds	r0, r0, r4
 8000a5e:	189b      	adds	r3, r3, r2
 8000a60:	4281      	cmp	r1, r0
 8000a62:	d200      	bcs.n	8000a66 <__aeabi_ddiv+0x3ae>
 8000a64:	e096      	b.n	8000b94 <__aeabi_ddiv+0x4dc>
 8000a66:	d100      	bne.n	8000a6a <__aeabi_ddiv+0x3b2>
 8000a68:	e0fc      	b.n	8000c64 <__aeabi_ddiv+0x5ac>
 8000a6a:	464a      	mov	r2, r9
 8000a6c:	2301      	movs	r3, #1
 8000a6e:	431a      	orrs	r2, r3
 8000a70:	4691      	mov	r9, r2
 8000a72:	4b9b      	ldr	r3, [pc, #620]	; (8000ce0 <__aeabi_ddiv+0x628>)
 8000a74:	18eb      	adds	r3, r5, r3
 8000a76:	2b00      	cmp	r3, #0
 8000a78:	dc00      	bgt.n	8000a7c <__aeabi_ddiv+0x3c4>
 8000a7a:	e099      	b.n	8000bb0 <__aeabi_ddiv+0x4f8>
 8000a7c:	464a      	mov	r2, r9
 8000a7e:	0752      	lsls	r2, r2, #29
 8000a80:	d00a      	beq.n	8000a98 <__aeabi_ddiv+0x3e0>
 8000a82:	220f      	movs	r2, #15
 8000a84:	4649      	mov	r1, r9
 8000a86:	400a      	ands	r2, r1
 8000a88:	2a04      	cmp	r2, #4
 8000a8a:	d005      	beq.n	8000a98 <__aeabi_ddiv+0x3e0>
 8000a8c:	3104      	adds	r1, #4
 8000a8e:	4549      	cmp	r1, r9
 8000a90:	4192      	sbcs	r2, r2
 8000a92:	4689      	mov	r9, r1
 8000a94:	4252      	negs	r2, r2
 8000a96:	4493      	add	fp, r2
 8000a98:	465a      	mov	r2, fp
 8000a9a:	01d2      	lsls	r2, r2, #7
 8000a9c:	d506      	bpl.n	8000aac <__aeabi_ddiv+0x3f4>
 8000a9e:	465a      	mov	r2, fp
 8000aa0:	4b90      	ldr	r3, [pc, #576]	; (8000ce4 <__aeabi_ddiv+0x62c>)
 8000aa2:	401a      	ands	r2, r3
 8000aa4:	2380      	movs	r3, #128	; 0x80
 8000aa6:	4693      	mov	fp, r2
 8000aa8:	00db      	lsls	r3, r3, #3
 8000aaa:	18eb      	adds	r3, r5, r3
 8000aac:	4a8e      	ldr	r2, [pc, #568]	; (8000ce8 <__aeabi_ddiv+0x630>)
 8000aae:	4293      	cmp	r3, r2
 8000ab0:	dd00      	ble.n	8000ab4 <__aeabi_ddiv+0x3fc>
 8000ab2:	e662      	b.n	800077a <__aeabi_ddiv+0xc2>
 8000ab4:	464a      	mov	r2, r9
 8000ab6:	4659      	mov	r1, fp
 8000ab8:	08d2      	lsrs	r2, r2, #3
 8000aba:	0749      	lsls	r1, r1, #29
 8000abc:	4311      	orrs	r1, r2
 8000abe:	465a      	mov	r2, fp
 8000ac0:	4689      	mov	r9, r1
 8000ac2:	0257      	lsls	r7, r2, #9
 8000ac4:	4651      	mov	r1, sl
 8000ac6:	2201      	movs	r2, #1
 8000ac8:	055b      	lsls	r3, r3, #21
 8000aca:	0b3f      	lsrs	r7, r7, #12
 8000acc:	0d5b      	lsrs	r3, r3, #21
 8000ace:	400a      	ands	r2, r1
 8000ad0:	e65a      	b.n	8000788 <__aeabi_ddiv+0xd0>
 8000ad2:	2080      	movs	r0, #128	; 0x80
 8000ad4:	465a      	mov	r2, fp
 8000ad6:	0300      	lsls	r0, r0, #12
 8000ad8:	4202      	tst	r2, r0
 8000ada:	d008      	beq.n	8000aee <__aeabi_ddiv+0x436>
 8000adc:	4207      	tst	r7, r0
 8000ade:	d106      	bne.n	8000aee <__aeabi_ddiv+0x436>
 8000ae0:	4307      	orrs	r7, r0
 8000ae2:	033f      	lsls	r7, r7, #12
 8000ae4:	4699      	mov	r9, r3
 8000ae6:	0b3f      	lsrs	r7, r7, #12
 8000ae8:	4642      	mov	r2, r8
 8000aea:	4b80      	ldr	r3, [pc, #512]	; (8000cec <__aeabi_ddiv+0x634>)
 8000aec:	e64c      	b.n	8000788 <__aeabi_ddiv+0xd0>
 8000aee:	465f      	mov	r7, fp
 8000af0:	4307      	orrs	r7, r0
 8000af2:	033f      	lsls	r7, r7, #12
 8000af4:	0b3f      	lsrs	r7, r7, #12
 8000af6:	1c22      	adds	r2, r4, #0
 8000af8:	4b7c      	ldr	r3, [pc, #496]	; (8000cec <__aeabi_ddiv+0x634>)
 8000afa:	e645      	b.n	8000788 <__aeabi_ddiv+0xd0>
 8000afc:	f001 f8c6 	bl	8001c8c <__clzsi2>
 8000b00:	1c03      	adds	r3, r0, #0
 8000b02:	3020      	adds	r0, #32
 8000b04:	2827      	cmp	r0, #39	; 0x27
 8000b06:	dc00      	bgt.n	8000b0a <__aeabi_ddiv+0x452>
 8000b08:	e65e      	b.n	80007c8 <__aeabi_ddiv+0x110>
 8000b0a:	3b08      	subs	r3, #8
 8000b0c:	409e      	lsls	r6, r3
 8000b0e:	2300      	movs	r3, #0
 8000b10:	46b3      	mov	fp, r6
 8000b12:	4699      	mov	r9, r3
 8000b14:	e665      	b.n	80007e2 <__aeabi_ddiv+0x12a>
 8000b16:	4650      	mov	r0, sl
 8000b18:	f001 f8b8 	bl	8001c8c <__clzsi2>
 8000b1c:	1c02      	adds	r2, r0, #0
 8000b1e:	3220      	adds	r2, #32
 8000b20:	2a27      	cmp	r2, #39	; 0x27
 8000b22:	dc00      	bgt.n	8000b26 <__aeabi_ddiv+0x46e>
 8000b24:	e675      	b.n	8000812 <__aeabi_ddiv+0x15a>
 8000b26:	4657      	mov	r7, sl
 8000b28:	3808      	subs	r0, #8
 8000b2a:	4087      	lsls	r7, r0
 8000b2c:	2300      	movs	r3, #0
 8000b2e:	e67b      	b.n	8000828 <__aeabi_ddiv+0x170>
 8000b30:	4599      	cmp	r9, r3
 8000b32:	d200      	bcs.n	8000b36 <__aeabi_ddiv+0x47e>
 8000b34:	e6af      	b.n	8000896 <__aeabi_ddiv+0x1de>
 8000b36:	465a      	mov	r2, fp
 8000b38:	4659      	mov	r1, fp
 8000b3a:	0854      	lsrs	r4, r2, #1
 8000b3c:	464a      	mov	r2, r9
 8000b3e:	07c8      	lsls	r0, r1, #31
 8000b40:	0852      	lsrs	r2, r2, #1
 8000b42:	4302      	orrs	r2, r0
 8000b44:	9203      	str	r2, [sp, #12]
 8000b46:	464a      	mov	r2, r9
 8000b48:	07d2      	lsls	r2, r2, #31
 8000b4a:	4690      	mov	r8, r2
 8000b4c:	e6a9      	b.n	80008a2 <__aeabi_ddiv+0x1ea>
 8000b4e:	2700      	movs	r7, #0
 8000b50:	4588      	cmp	r8, r1
 8000b52:	d300      	bcc.n	8000b56 <__aeabi_ddiv+0x49e>
 8000b54:	e71c      	b.n	8000990 <__aeabi_ddiv+0x2d8>
 8000b56:	9f01      	ldr	r7, [sp, #4]
 8000b58:	465a      	mov	r2, fp
 8000b5a:	46bc      	mov	ip, r7
 8000b5c:	44e0      	add	r8, ip
 8000b5e:	45b8      	cmp	r8, r7
 8000b60:	41bf      	sbcs	r7, r7
 8000b62:	427f      	negs	r7, r7
 8000b64:	19bf      	adds	r7, r7, r6
 8000b66:	18ff      	adds	r7, r7, r3
 8000b68:	3a01      	subs	r2, #1
 8000b6a:	42be      	cmp	r6, r7
 8000b6c:	d206      	bcs.n	8000b7c <__aeabi_ddiv+0x4c4>
 8000b6e:	42bc      	cmp	r4, r7
 8000b70:	d85f      	bhi.n	8000c32 <__aeabi_ddiv+0x57a>
 8000b72:	d100      	bne.n	8000b76 <__aeabi_ddiv+0x4be>
 8000b74:	e09f      	b.n	8000cb6 <__aeabi_ddiv+0x5fe>
 8000b76:	1b3f      	subs	r7, r7, r4
 8000b78:	4693      	mov	fp, r2
 8000b7a:	e709      	b.n	8000990 <__aeabi_ddiv+0x2d8>
 8000b7c:	42b7      	cmp	r7, r6
 8000b7e:	d1fa      	bne.n	8000b76 <__aeabi_ddiv+0x4be>
 8000b80:	9b01      	ldr	r3, [sp, #4]
 8000b82:	4543      	cmp	r3, r8
 8000b84:	d9f3      	bls.n	8000b6e <__aeabi_ddiv+0x4b6>
 8000b86:	1b37      	subs	r7, r6, r4
 8000b88:	4693      	mov	fp, r2
 8000b8a:	e701      	b.n	8000990 <__aeabi_ddiv+0x2d8>
 8000b8c:	4693      	mov	fp, r2
 8000b8e:	e6d4      	b.n	800093a <__aeabi_ddiv+0x282>
 8000b90:	9302      	str	r3, [sp, #8]
 8000b92:	e6b1      	b.n	80008f8 <__aeabi_ddiv+0x240>
 8000b94:	464a      	mov	r2, r9
 8000b96:	1989      	adds	r1, r1, r6
 8000b98:	3a01      	subs	r2, #1
 8000b9a:	428e      	cmp	r6, r1
 8000b9c:	d918      	bls.n	8000bd0 <__aeabi_ddiv+0x518>
 8000b9e:	4691      	mov	r9, r2
 8000ba0:	4281      	cmp	r1, r0
 8000ba2:	d000      	beq.n	8000ba6 <__aeabi_ddiv+0x4ee>
 8000ba4:	e761      	b.n	8000a6a <__aeabi_ddiv+0x3b2>
 8000ba6:	9a01      	ldr	r2, [sp, #4]
 8000ba8:	429a      	cmp	r2, r3
 8000baa:	d000      	beq.n	8000bae <__aeabi_ddiv+0x4f6>
 8000bac:	e75d      	b.n	8000a6a <__aeabi_ddiv+0x3b2>
 8000bae:	e760      	b.n	8000a72 <__aeabi_ddiv+0x3ba>
 8000bb0:	4f4f      	ldr	r7, [pc, #316]	; (8000cf0 <__aeabi_ddiv+0x638>)
 8000bb2:	1b7f      	subs	r7, r7, r5
 8000bb4:	2f38      	cmp	r7, #56	; 0x38
 8000bb6:	dd13      	ble.n	8000be0 <__aeabi_ddiv+0x528>
 8000bb8:	2201      	movs	r2, #1
 8000bba:	4653      	mov	r3, sl
 8000bbc:	401a      	ands	r2, r3
 8000bbe:	e64f      	b.n	8000860 <__aeabi_ddiv+0x1a8>
 8000bc0:	2301      	movs	r3, #1
 8000bc2:	425b      	negs	r3, r3
 8000bc4:	4699      	mov	r9, r3
 8000bc6:	e754      	b.n	8000a72 <__aeabi_ddiv+0x3ba>
 8000bc8:	9302      	str	r3, [sp, #8]
 8000bca:	e708      	b.n	80009de <__aeabi_ddiv+0x326>
 8000bcc:	9303      	str	r3, [sp, #12]
 8000bce:	e727      	b.n	8000a20 <__aeabi_ddiv+0x368>
 8000bd0:	4288      	cmp	r0, r1
 8000bd2:	d83c      	bhi.n	8000c4e <__aeabi_ddiv+0x596>
 8000bd4:	d074      	beq.n	8000cc0 <__aeabi_ddiv+0x608>
 8000bd6:	4691      	mov	r9, r2
 8000bd8:	e747      	b.n	8000a6a <__aeabi_ddiv+0x3b2>
 8000bda:	9b01      	ldr	r3, [sp, #4]
 8000bdc:	469a      	mov	sl, r3
 8000bde:	e748      	b.n	8000a72 <__aeabi_ddiv+0x3ba>
 8000be0:	2f1f      	cmp	r7, #31
 8000be2:	dc44      	bgt.n	8000c6e <__aeabi_ddiv+0x5b6>
 8000be4:	4b43      	ldr	r3, [pc, #268]	; (8000cf4 <__aeabi_ddiv+0x63c>)
 8000be6:	464a      	mov	r2, r9
 8000be8:	469c      	mov	ip, r3
 8000bea:	465b      	mov	r3, fp
 8000bec:	4465      	add	r5, ip
 8000bee:	40fa      	lsrs	r2, r7
 8000bf0:	40ab      	lsls	r3, r5
 8000bf2:	4313      	orrs	r3, r2
 8000bf4:	464a      	mov	r2, r9
 8000bf6:	40aa      	lsls	r2, r5
 8000bf8:	1c15      	adds	r5, r2, #0
 8000bfa:	1e6a      	subs	r2, r5, #1
 8000bfc:	4195      	sbcs	r5, r2
 8000bfe:	465a      	mov	r2, fp
 8000c00:	40fa      	lsrs	r2, r7
 8000c02:	432b      	orrs	r3, r5
 8000c04:	1c17      	adds	r7, r2, #0
 8000c06:	075a      	lsls	r2, r3, #29
 8000c08:	d009      	beq.n	8000c1e <__aeabi_ddiv+0x566>
 8000c0a:	220f      	movs	r2, #15
 8000c0c:	401a      	ands	r2, r3
 8000c0e:	2a04      	cmp	r2, #4
 8000c10:	d005      	beq.n	8000c1e <__aeabi_ddiv+0x566>
 8000c12:	1d1a      	adds	r2, r3, #4
 8000c14:	429a      	cmp	r2, r3
 8000c16:	419b      	sbcs	r3, r3
 8000c18:	425b      	negs	r3, r3
 8000c1a:	18ff      	adds	r7, r7, r3
 8000c1c:	1c13      	adds	r3, r2, #0
 8000c1e:	023a      	lsls	r2, r7, #8
 8000c20:	d53e      	bpl.n	8000ca0 <__aeabi_ddiv+0x5e8>
 8000c22:	4653      	mov	r3, sl
 8000c24:	2201      	movs	r2, #1
 8000c26:	2100      	movs	r1, #0
 8000c28:	401a      	ands	r2, r3
 8000c2a:	2700      	movs	r7, #0
 8000c2c:	2301      	movs	r3, #1
 8000c2e:	4689      	mov	r9, r1
 8000c30:	e5aa      	b.n	8000788 <__aeabi_ddiv+0xd0>
 8000c32:	2302      	movs	r3, #2
 8000c34:	425b      	negs	r3, r3
 8000c36:	469c      	mov	ip, r3
 8000c38:	9a01      	ldr	r2, [sp, #4]
 8000c3a:	44e3      	add	fp, ip
 8000c3c:	4694      	mov	ip, r2
 8000c3e:	44e0      	add	r8, ip
 8000c40:	4590      	cmp	r8, r2
 8000c42:	419b      	sbcs	r3, r3
 8000c44:	425b      	negs	r3, r3
 8000c46:	199b      	adds	r3, r3, r6
 8000c48:	19df      	adds	r7, r3, r7
 8000c4a:	1b3f      	subs	r7, r7, r4
 8000c4c:	e6a0      	b.n	8000990 <__aeabi_ddiv+0x2d8>
 8000c4e:	9f01      	ldr	r7, [sp, #4]
 8000c50:	464a      	mov	r2, r9
 8000c52:	007c      	lsls	r4, r7, #1
 8000c54:	42bc      	cmp	r4, r7
 8000c56:	41bf      	sbcs	r7, r7
 8000c58:	427f      	negs	r7, r7
 8000c5a:	19bf      	adds	r7, r7, r6
 8000c5c:	3a02      	subs	r2, #2
 8000c5e:	19c9      	adds	r1, r1, r7
 8000c60:	9401      	str	r4, [sp, #4]
 8000c62:	e79c      	b.n	8000b9e <__aeabi_ddiv+0x4e6>
 8000c64:	2b00      	cmp	r3, #0
 8000c66:	d195      	bne.n	8000b94 <__aeabi_ddiv+0x4dc>
 8000c68:	2200      	movs	r2, #0
 8000c6a:	9201      	str	r2, [sp, #4]
 8000c6c:	e79b      	b.n	8000ba6 <__aeabi_ddiv+0x4ee>
 8000c6e:	465a      	mov	r2, fp
 8000c70:	4b21      	ldr	r3, [pc, #132]	; (8000cf8 <__aeabi_ddiv+0x640>)
 8000c72:	1b5b      	subs	r3, r3, r5
 8000c74:	40da      	lsrs	r2, r3
 8000c76:	2f20      	cmp	r7, #32
 8000c78:	d027      	beq.n	8000cca <__aeabi_ddiv+0x612>
 8000c7a:	4b20      	ldr	r3, [pc, #128]	; (8000cfc <__aeabi_ddiv+0x644>)
 8000c7c:	469c      	mov	ip, r3
 8000c7e:	465b      	mov	r3, fp
 8000c80:	4465      	add	r5, ip
 8000c82:	40ab      	lsls	r3, r5
 8000c84:	4649      	mov	r1, r9
 8000c86:	430b      	orrs	r3, r1
 8000c88:	1e59      	subs	r1, r3, #1
 8000c8a:	418b      	sbcs	r3, r1
 8000c8c:	4313      	orrs	r3, r2
 8000c8e:	2207      	movs	r2, #7
 8000c90:	2700      	movs	r7, #0
 8000c92:	401a      	ands	r2, r3
 8000c94:	d007      	beq.n	8000ca6 <__aeabi_ddiv+0x5ee>
 8000c96:	220f      	movs	r2, #15
 8000c98:	2700      	movs	r7, #0
 8000c9a:	401a      	ands	r2, r3
 8000c9c:	2a04      	cmp	r2, #4
 8000c9e:	d1b8      	bne.n	8000c12 <__aeabi_ddiv+0x55a>
 8000ca0:	077a      	lsls	r2, r7, #29
 8000ca2:	027f      	lsls	r7, r7, #9
 8000ca4:	0b3f      	lsrs	r7, r7, #12
 8000ca6:	08db      	lsrs	r3, r3, #3
 8000ca8:	4313      	orrs	r3, r2
 8000caa:	4699      	mov	r9, r3
 8000cac:	2201      	movs	r2, #1
 8000cae:	4653      	mov	r3, sl
 8000cb0:	401a      	ands	r2, r3
 8000cb2:	2300      	movs	r3, #0
 8000cb4:	e568      	b.n	8000788 <__aeabi_ddiv+0xd0>
 8000cb6:	4541      	cmp	r1, r8
 8000cb8:	d8bb      	bhi.n	8000c32 <__aeabi_ddiv+0x57a>
 8000cba:	4693      	mov	fp, r2
 8000cbc:	2700      	movs	r7, #0
 8000cbe:	e667      	b.n	8000990 <__aeabi_ddiv+0x2d8>
 8000cc0:	9c01      	ldr	r4, [sp, #4]
 8000cc2:	429c      	cmp	r4, r3
 8000cc4:	d3c3      	bcc.n	8000c4e <__aeabi_ddiv+0x596>
 8000cc6:	4691      	mov	r9, r2
 8000cc8:	e76d      	b.n	8000ba6 <__aeabi_ddiv+0x4ee>
 8000cca:	2300      	movs	r3, #0
 8000ccc:	e7da      	b.n	8000c84 <__aeabi_ddiv+0x5cc>
 8000cce:	2780      	movs	r7, #128	; 0x80
 8000cd0:	465b      	mov	r3, fp
 8000cd2:	033f      	lsls	r7, r7, #12
 8000cd4:	431f      	orrs	r7, r3
 8000cd6:	033f      	lsls	r7, r7, #12
 8000cd8:	0b3f      	lsrs	r7, r7, #12
 8000cda:	9a01      	ldr	r2, [sp, #4]
 8000cdc:	4b03      	ldr	r3, [pc, #12]	; (8000cec <__aeabi_ddiv+0x634>)
 8000cde:	e553      	b.n	8000788 <__aeabi_ddiv+0xd0>
 8000ce0:	000003ff 	.word	0x000003ff
 8000ce4:	feffffff 	.word	0xfeffffff
 8000ce8:	000007fe 	.word	0x000007fe
 8000cec:	000007ff 	.word	0x000007ff
 8000cf0:	fffffc02 	.word	0xfffffc02
 8000cf4:	0000041e 	.word	0x0000041e
 8000cf8:	fffffbe2 	.word	0xfffffbe2
 8000cfc:	0000043e 	.word	0x0000043e

08000d00 <__aeabi_dmul>:
 8000d00:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000d02:	465f      	mov	r7, fp
 8000d04:	4656      	mov	r6, sl
 8000d06:	464d      	mov	r5, r9
 8000d08:	4644      	mov	r4, r8
 8000d0a:	b4f0      	push	{r4, r5, r6, r7}
 8000d0c:	1c05      	adds	r5, r0, #0
 8000d0e:	1c06      	adds	r6, r0, #0
 8000d10:	0308      	lsls	r0, r1, #12
 8000d12:	b087      	sub	sp, #28
 8000d14:	4699      	mov	r9, r3
 8000d16:	004f      	lsls	r7, r1, #1
 8000d18:	0b03      	lsrs	r3, r0, #12
 8000d1a:	0fcc      	lsrs	r4, r1, #31
 8000d1c:	4692      	mov	sl, r2
 8000d1e:	469b      	mov	fp, r3
 8000d20:	0d7f      	lsrs	r7, r7, #21
 8000d22:	9401      	str	r4, [sp, #4]
 8000d24:	d067      	beq.n	8000df6 <__aeabi_dmul+0xf6>
 8000d26:	4b6c      	ldr	r3, [pc, #432]	; (8000ed8 <__aeabi_dmul+0x1d8>)
 8000d28:	429f      	cmp	r7, r3
 8000d2a:	d036      	beq.n	8000d9a <__aeabi_dmul+0x9a>
 8000d2c:	2080      	movs	r0, #128	; 0x80
 8000d2e:	465b      	mov	r3, fp
 8000d30:	0340      	lsls	r0, r0, #13
 8000d32:	4318      	orrs	r0, r3
 8000d34:	00c0      	lsls	r0, r0, #3
 8000d36:	0f6b      	lsrs	r3, r5, #29
 8000d38:	4318      	orrs	r0, r3
 8000d3a:	4b68      	ldr	r3, [pc, #416]	; (8000edc <__aeabi_dmul+0x1dc>)
 8000d3c:	4683      	mov	fp, r0
 8000d3e:	469c      	mov	ip, r3
 8000d40:	2300      	movs	r3, #0
 8000d42:	4698      	mov	r8, r3
 8000d44:	00ee      	lsls	r6, r5, #3
 8000d46:	4467      	add	r7, ip
 8000d48:	9300      	str	r3, [sp, #0]
 8000d4a:	464b      	mov	r3, r9
 8000d4c:	4649      	mov	r1, r9
 8000d4e:	031d      	lsls	r5, r3, #12
 8000d50:	0fc9      	lsrs	r1, r1, #31
 8000d52:	005b      	lsls	r3, r3, #1
 8000d54:	4652      	mov	r2, sl
 8000d56:	0b2d      	lsrs	r5, r5, #12
 8000d58:	0d5b      	lsrs	r3, r3, #21
 8000d5a:	4689      	mov	r9, r1
 8000d5c:	d100      	bne.n	8000d60 <__aeabi_dmul+0x60>
 8000d5e:	e06e      	b.n	8000e3e <__aeabi_dmul+0x13e>
 8000d60:	495d      	ldr	r1, [pc, #372]	; (8000ed8 <__aeabi_dmul+0x1d8>)
 8000d62:	428b      	cmp	r3, r1
 8000d64:	d064      	beq.n	8000e30 <__aeabi_dmul+0x130>
 8000d66:	2080      	movs	r0, #128	; 0x80
 8000d68:	495c      	ldr	r1, [pc, #368]	; (8000edc <__aeabi_dmul+0x1dc>)
 8000d6a:	0340      	lsls	r0, r0, #13
 8000d6c:	468c      	mov	ip, r1
 8000d6e:	2100      	movs	r1, #0
 8000d70:	4305      	orrs	r5, r0
 8000d72:	00ed      	lsls	r5, r5, #3
 8000d74:	0f50      	lsrs	r0, r2, #29
 8000d76:	4305      	orrs	r5, r0
 8000d78:	00d2      	lsls	r2, r2, #3
 8000d7a:	4463      	add	r3, ip
 8000d7c:	4648      	mov	r0, r9
 8000d7e:	18ff      	adds	r7, r7, r3
 8000d80:	1c7b      	adds	r3, r7, #1
 8000d82:	469a      	mov	sl, r3
 8000d84:	9b00      	ldr	r3, [sp, #0]
 8000d86:	4060      	eors	r0, r4
 8000d88:	9002      	str	r0, [sp, #8]
 8000d8a:	430b      	orrs	r3, r1
 8000d8c:	2b0f      	cmp	r3, #15
 8000d8e:	d900      	bls.n	8000d92 <__aeabi_dmul+0x92>
 8000d90:	e0ac      	b.n	8000eec <__aeabi_dmul+0x1ec>
 8000d92:	4853      	ldr	r0, [pc, #332]	; (8000ee0 <__aeabi_dmul+0x1e0>)
 8000d94:	009b      	lsls	r3, r3, #2
 8000d96:	58c3      	ldr	r3, [r0, r3]
 8000d98:	469f      	mov	pc, r3
 8000d9a:	465b      	mov	r3, fp
 8000d9c:	431d      	orrs	r5, r3
 8000d9e:	d000      	beq.n	8000da2 <__aeabi_dmul+0xa2>
 8000da0:	e082      	b.n	8000ea8 <__aeabi_dmul+0x1a8>
 8000da2:	2308      	movs	r3, #8
 8000da4:	9300      	str	r3, [sp, #0]
 8000da6:	2300      	movs	r3, #0
 8000da8:	469b      	mov	fp, r3
 8000daa:	3302      	adds	r3, #2
 8000dac:	2600      	movs	r6, #0
 8000dae:	4698      	mov	r8, r3
 8000db0:	e7cb      	b.n	8000d4a <__aeabi_dmul+0x4a>
 8000db2:	9b02      	ldr	r3, [sp, #8]
 8000db4:	9301      	str	r3, [sp, #4]
 8000db6:	4643      	mov	r3, r8
 8000db8:	2b02      	cmp	r3, #2
 8000dba:	d159      	bne.n	8000e70 <__aeabi_dmul+0x170>
 8000dbc:	2401      	movs	r4, #1
 8000dbe:	2500      	movs	r5, #0
 8000dc0:	2600      	movs	r6, #0
 8000dc2:	9b01      	ldr	r3, [sp, #4]
 8000dc4:	401c      	ands	r4, r3
 8000dc6:	4b44      	ldr	r3, [pc, #272]	; (8000ed8 <__aeabi_dmul+0x1d8>)
 8000dc8:	2100      	movs	r1, #0
 8000dca:	032d      	lsls	r5, r5, #12
 8000dcc:	0d0a      	lsrs	r2, r1, #20
 8000dce:	0512      	lsls	r2, r2, #20
 8000dd0:	0b2d      	lsrs	r5, r5, #12
 8000dd2:	4315      	orrs	r5, r2
 8000dd4:	4a43      	ldr	r2, [pc, #268]	; (8000ee4 <__aeabi_dmul+0x1e4>)
 8000dd6:	051b      	lsls	r3, r3, #20
 8000dd8:	4015      	ands	r5, r2
 8000dda:	431d      	orrs	r5, r3
 8000ddc:	006d      	lsls	r5, r5, #1
 8000dde:	07e4      	lsls	r4, r4, #31
 8000de0:	086d      	lsrs	r5, r5, #1
 8000de2:	4325      	orrs	r5, r4
 8000de4:	1c30      	adds	r0, r6, #0
 8000de6:	1c29      	adds	r1, r5, #0
 8000de8:	b007      	add	sp, #28
 8000dea:	bc3c      	pop	{r2, r3, r4, r5}
 8000dec:	4690      	mov	r8, r2
 8000dee:	4699      	mov	r9, r3
 8000df0:	46a2      	mov	sl, r4
 8000df2:	46ab      	mov	fp, r5
 8000df4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8000df6:	432b      	orrs	r3, r5
 8000df8:	d04e      	beq.n	8000e98 <__aeabi_dmul+0x198>
 8000dfa:	465b      	mov	r3, fp
 8000dfc:	2b00      	cmp	r3, #0
 8000dfe:	d100      	bne.n	8000e02 <__aeabi_dmul+0x102>
 8000e00:	e185      	b.n	800110e <__aeabi_dmul+0x40e>
 8000e02:	4658      	mov	r0, fp
 8000e04:	f000 ff42 	bl	8001c8c <__clzsi2>
 8000e08:	1c02      	adds	r2, r0, #0
 8000e0a:	2328      	movs	r3, #40	; 0x28
 8000e0c:	1c29      	adds	r1, r5, #0
 8000e0e:	1a9b      	subs	r3, r3, r2
 8000e10:	1c16      	adds	r6, r2, #0
 8000e12:	4658      	mov	r0, fp
 8000e14:	40d9      	lsrs	r1, r3
 8000e16:	3e08      	subs	r6, #8
 8000e18:	40b0      	lsls	r0, r6
 8000e1a:	1c0b      	adds	r3, r1, #0
 8000e1c:	40b5      	lsls	r5, r6
 8000e1e:	4303      	orrs	r3, r0
 8000e20:	469b      	mov	fp, r3
 8000e22:	1c2e      	adds	r6, r5, #0
 8000e24:	2300      	movs	r3, #0
 8000e26:	4f30      	ldr	r7, [pc, #192]	; (8000ee8 <__aeabi_dmul+0x1e8>)
 8000e28:	9300      	str	r3, [sp, #0]
 8000e2a:	1abf      	subs	r7, r7, r2
 8000e2c:	4698      	mov	r8, r3
 8000e2e:	e78c      	b.n	8000d4a <__aeabi_dmul+0x4a>
 8000e30:	4651      	mov	r1, sl
 8000e32:	4329      	orrs	r1, r5
 8000e34:	d12e      	bne.n	8000e94 <__aeabi_dmul+0x194>
 8000e36:	2500      	movs	r5, #0
 8000e38:	2200      	movs	r2, #0
 8000e3a:	2102      	movs	r1, #2
 8000e3c:	e79e      	b.n	8000d7c <__aeabi_dmul+0x7c>
 8000e3e:	4651      	mov	r1, sl
 8000e40:	4329      	orrs	r1, r5
 8000e42:	d023      	beq.n	8000e8c <__aeabi_dmul+0x18c>
 8000e44:	2d00      	cmp	r5, #0
 8000e46:	d100      	bne.n	8000e4a <__aeabi_dmul+0x14a>
 8000e48:	e154      	b.n	80010f4 <__aeabi_dmul+0x3f4>
 8000e4a:	1c28      	adds	r0, r5, #0
 8000e4c:	f000 ff1e 	bl	8001c8c <__clzsi2>
 8000e50:	1c03      	adds	r3, r0, #0
 8000e52:	2128      	movs	r1, #40	; 0x28
 8000e54:	4650      	mov	r0, sl
 8000e56:	1ac9      	subs	r1, r1, r3
 8000e58:	1c1a      	adds	r2, r3, #0
 8000e5a:	40c8      	lsrs	r0, r1
 8000e5c:	4651      	mov	r1, sl
 8000e5e:	3a08      	subs	r2, #8
 8000e60:	4091      	lsls	r1, r2
 8000e62:	4095      	lsls	r5, r2
 8000e64:	1c0a      	adds	r2, r1, #0
 8000e66:	4305      	orrs	r5, r0
 8000e68:	481f      	ldr	r0, [pc, #124]	; (8000ee8 <__aeabi_dmul+0x1e8>)
 8000e6a:	2100      	movs	r1, #0
 8000e6c:	1ac3      	subs	r3, r0, r3
 8000e6e:	e785      	b.n	8000d7c <__aeabi_dmul+0x7c>
 8000e70:	2b03      	cmp	r3, #3
 8000e72:	d100      	bne.n	8000e76 <__aeabi_dmul+0x176>
 8000e74:	e1c2      	b.n	80011fc <__aeabi_dmul+0x4fc>
 8000e76:	2b01      	cmp	r3, #1
 8000e78:	d000      	beq.n	8000e7c <__aeabi_dmul+0x17c>
 8000e7a:	e16d      	b.n	8001158 <__aeabi_dmul+0x458>
 8000e7c:	4644      	mov	r4, r8
 8000e7e:	9b01      	ldr	r3, [sp, #4]
 8000e80:	2500      	movs	r5, #0
 8000e82:	401c      	ands	r4, r3
 8000e84:	b2e4      	uxtb	r4, r4
 8000e86:	2300      	movs	r3, #0
 8000e88:	2600      	movs	r6, #0
 8000e8a:	e79d      	b.n	8000dc8 <__aeabi_dmul+0xc8>
 8000e8c:	2500      	movs	r5, #0
 8000e8e:	2200      	movs	r2, #0
 8000e90:	2101      	movs	r1, #1
 8000e92:	e773      	b.n	8000d7c <__aeabi_dmul+0x7c>
 8000e94:	2103      	movs	r1, #3
 8000e96:	e771      	b.n	8000d7c <__aeabi_dmul+0x7c>
 8000e98:	2304      	movs	r3, #4
 8000e9a:	9300      	str	r3, [sp, #0]
 8000e9c:	2300      	movs	r3, #0
 8000e9e:	469b      	mov	fp, r3
 8000ea0:	3301      	adds	r3, #1
 8000ea2:	2600      	movs	r6, #0
 8000ea4:	4698      	mov	r8, r3
 8000ea6:	e750      	b.n	8000d4a <__aeabi_dmul+0x4a>
 8000ea8:	230c      	movs	r3, #12
 8000eaa:	9300      	str	r3, [sp, #0]
 8000eac:	3b09      	subs	r3, #9
 8000eae:	4698      	mov	r8, r3
 8000eb0:	e74b      	b.n	8000d4a <__aeabi_dmul+0x4a>
 8000eb2:	2580      	movs	r5, #128	; 0x80
 8000eb4:	2400      	movs	r4, #0
 8000eb6:	032d      	lsls	r5, r5, #12
 8000eb8:	2600      	movs	r6, #0
 8000eba:	4b07      	ldr	r3, [pc, #28]	; (8000ed8 <__aeabi_dmul+0x1d8>)
 8000ebc:	e784      	b.n	8000dc8 <__aeabi_dmul+0xc8>
 8000ebe:	464b      	mov	r3, r9
 8000ec0:	46ab      	mov	fp, r5
 8000ec2:	1c16      	adds	r6, r2, #0
 8000ec4:	9301      	str	r3, [sp, #4]
 8000ec6:	4688      	mov	r8, r1
 8000ec8:	e775      	b.n	8000db6 <__aeabi_dmul+0xb6>
 8000eca:	9b02      	ldr	r3, [sp, #8]
 8000ecc:	46ab      	mov	fp, r5
 8000ece:	1c16      	adds	r6, r2, #0
 8000ed0:	9301      	str	r3, [sp, #4]
 8000ed2:	4688      	mov	r8, r1
 8000ed4:	e76f      	b.n	8000db6 <__aeabi_dmul+0xb6>
 8000ed6:	46c0      	nop			; (mov r8, r8)
 8000ed8:	000007ff 	.word	0x000007ff
 8000edc:	fffffc01 	.word	0xfffffc01
 8000ee0:	08005724 	.word	0x08005724
 8000ee4:	800fffff 	.word	0x800fffff
 8000ee8:	fffffc0d 	.word	0xfffffc0d
 8000eec:	0c33      	lsrs	r3, r6, #16
 8000eee:	0436      	lsls	r6, r6, #16
 8000ef0:	0c36      	lsrs	r6, r6, #16
 8000ef2:	469c      	mov	ip, r3
 8000ef4:	1c33      	adds	r3, r6, #0
 8000ef6:	0c14      	lsrs	r4, r2, #16
 8000ef8:	0412      	lsls	r2, r2, #16
 8000efa:	0c12      	lsrs	r2, r2, #16
 8000efc:	4353      	muls	r3, r2
 8000efe:	4698      	mov	r8, r3
 8000f00:	4663      	mov	r3, ip
 8000f02:	4353      	muls	r3, r2
 8000f04:	4699      	mov	r9, r3
 8000f06:	4663      	mov	r3, ip
 8000f08:	4363      	muls	r3, r4
 8000f0a:	9301      	str	r3, [sp, #4]
 8000f0c:	1c33      	adds	r3, r6, #0
 8000f0e:	4641      	mov	r1, r8
 8000f10:	4363      	muls	r3, r4
 8000f12:	0c09      	lsrs	r1, r1, #16
 8000f14:	444b      	add	r3, r9
 8000f16:	185b      	adds	r3, r3, r1
 8000f18:	4599      	cmp	r9, r3
 8000f1a:	d905      	bls.n	8000f28 <__aeabi_dmul+0x228>
 8000f1c:	2080      	movs	r0, #128	; 0x80
 8000f1e:	0240      	lsls	r0, r0, #9
 8000f20:	4681      	mov	r9, r0
 8000f22:	9901      	ldr	r1, [sp, #4]
 8000f24:	4449      	add	r1, r9
 8000f26:	9101      	str	r1, [sp, #4]
 8000f28:	0c19      	lsrs	r1, r3, #16
 8000f2a:	9103      	str	r1, [sp, #12]
 8000f2c:	4641      	mov	r1, r8
 8000f2e:	0409      	lsls	r1, r1, #16
 8000f30:	0c09      	lsrs	r1, r1, #16
 8000f32:	041b      	lsls	r3, r3, #16
 8000f34:	185b      	adds	r3, r3, r1
 8000f36:	9304      	str	r3, [sp, #16]
 8000f38:	0c2b      	lsrs	r3, r5, #16
 8000f3a:	4698      	mov	r8, r3
 8000f3c:	1c33      	adds	r3, r6, #0
 8000f3e:	042d      	lsls	r5, r5, #16
 8000f40:	0c29      	lsrs	r1, r5, #16
 8000f42:	434b      	muls	r3, r1
 8000f44:	4660      	mov	r0, ip
 8000f46:	9300      	str	r3, [sp, #0]
 8000f48:	4643      	mov	r3, r8
 8000f4a:	4665      	mov	r5, ip
 8000f4c:	4358      	muls	r0, r3
 8000f4e:	435e      	muls	r6, r3
 8000f50:	9b00      	ldr	r3, [sp, #0]
 8000f52:	434d      	muls	r5, r1
 8000f54:	0c1b      	lsrs	r3, r3, #16
 8000f56:	4699      	mov	r9, r3
 8000f58:	19ae      	adds	r6, r5, r6
 8000f5a:	444e      	add	r6, r9
 8000f5c:	4684      	mov	ip, r0
 8000f5e:	42b5      	cmp	r5, r6
 8000f60:	d903      	bls.n	8000f6a <__aeabi_dmul+0x26a>
 8000f62:	2380      	movs	r3, #128	; 0x80
 8000f64:	025b      	lsls	r3, r3, #9
 8000f66:	4699      	mov	r9, r3
 8000f68:	44cc      	add	ip, r9
 8000f6a:	0c35      	lsrs	r5, r6, #16
 8000f6c:	1c2b      	adds	r3, r5, #0
 8000f6e:	9803      	ldr	r0, [sp, #12]
 8000f70:	4463      	add	r3, ip
 8000f72:	4684      	mov	ip, r0
 8000f74:	9305      	str	r3, [sp, #20]
 8000f76:	9b00      	ldr	r3, [sp, #0]
 8000f78:	0436      	lsls	r6, r6, #16
 8000f7a:	041b      	lsls	r3, r3, #16
 8000f7c:	0c1b      	lsrs	r3, r3, #16
 8000f7e:	18f3      	adds	r3, r6, r3
 8000f80:	449c      	add	ip, r3
 8000f82:	4660      	mov	r0, ip
 8000f84:	9003      	str	r0, [sp, #12]
 8000f86:	4658      	mov	r0, fp
 8000f88:	0405      	lsls	r5, r0, #16
 8000f8a:	0c06      	lsrs	r6, r0, #16
 8000f8c:	0c28      	lsrs	r0, r5, #16
 8000f8e:	4684      	mov	ip, r0
 8000f90:	4350      	muls	r0, r2
 8000f92:	1c35      	adds	r5, r6, #0
 8000f94:	4681      	mov	r9, r0
 8000f96:	4660      	mov	r0, ip
 8000f98:	4365      	muls	r5, r4
 8000f9a:	4344      	muls	r4, r0
 8000f9c:	4648      	mov	r0, r9
 8000f9e:	0c00      	lsrs	r0, r0, #16
 8000fa0:	4683      	mov	fp, r0
 8000fa2:	4372      	muls	r2, r6
 8000fa4:	1914      	adds	r4, r2, r4
 8000fa6:	445c      	add	r4, fp
 8000fa8:	42a2      	cmp	r2, r4
 8000faa:	d903      	bls.n	8000fb4 <__aeabi_dmul+0x2b4>
 8000fac:	2280      	movs	r2, #128	; 0x80
 8000fae:	0252      	lsls	r2, r2, #9
 8000fb0:	4693      	mov	fp, r2
 8000fb2:	445d      	add	r5, fp
 8000fb4:	0c22      	lsrs	r2, r4, #16
 8000fb6:	18ad      	adds	r5, r5, r2
 8000fb8:	464a      	mov	r2, r9
 8000fba:	0412      	lsls	r2, r2, #16
 8000fbc:	0c12      	lsrs	r2, r2, #16
 8000fbe:	0424      	lsls	r4, r4, #16
 8000fc0:	4640      	mov	r0, r8
 8000fc2:	18a4      	adds	r4, r4, r2
 8000fc4:	4662      	mov	r2, ip
 8000fc6:	434a      	muls	r2, r1
 8000fc8:	4371      	muls	r1, r6
 8000fca:	4346      	muls	r6, r0
 8000fcc:	4660      	mov	r0, ip
 8000fce:	9600      	str	r6, [sp, #0]
 8000fd0:	4646      	mov	r6, r8
 8000fd2:	4370      	muls	r0, r6
 8000fd4:	4680      	mov	r8, r0
 8000fd6:	0c10      	lsrs	r0, r2, #16
 8000fd8:	4684      	mov	ip, r0
 8000fda:	4488      	add	r8, r1
 8000fdc:	44e0      	add	r8, ip
 8000fde:	4541      	cmp	r1, r8
 8000fe0:	d905      	bls.n	8000fee <__aeabi_dmul+0x2ee>
 8000fe2:	2180      	movs	r1, #128	; 0x80
 8000fe4:	0249      	lsls	r1, r1, #9
 8000fe6:	468c      	mov	ip, r1
 8000fe8:	9900      	ldr	r1, [sp, #0]
 8000fea:	4461      	add	r1, ip
 8000fec:	9100      	str	r1, [sp, #0]
 8000fee:	9801      	ldr	r0, [sp, #4]
 8000ff0:	9903      	ldr	r1, [sp, #12]
 8000ff2:	4684      	mov	ip, r0
 8000ff4:	4461      	add	r1, ip
 8000ff6:	4299      	cmp	r1, r3
 8000ff8:	419b      	sbcs	r3, r3
 8000ffa:	425b      	negs	r3, r3
 8000ffc:	4699      	mov	r9, r3
 8000ffe:	9805      	ldr	r0, [sp, #20]
 8001000:	4643      	mov	r3, r8
 8001002:	4684      	mov	ip, r0
 8001004:	0412      	lsls	r2, r2, #16
 8001006:	0c12      	lsrs	r2, r2, #16
 8001008:	041b      	lsls	r3, r3, #16
 800100a:	189b      	adds	r3, r3, r2
 800100c:	4463      	add	r3, ip
 800100e:	469c      	mov	ip, r3
 8001010:	46ab      	mov	fp, r5
 8001012:	4283      	cmp	r3, r0
 8001014:	419b      	sbcs	r3, r3
 8001016:	4640      	mov	r0, r8
 8001018:	190a      	adds	r2, r1, r4
 800101a:	44cc      	add	ip, r9
 800101c:	42a2      	cmp	r2, r4
 800101e:	4189      	sbcs	r1, r1
 8001020:	44e3      	add	fp, ip
 8001022:	45cc      	cmp	ip, r9
 8001024:	41b6      	sbcs	r6, r6
 8001026:	465c      	mov	r4, fp
 8001028:	0c00      	lsrs	r0, r0, #16
 800102a:	4680      	mov	r8, r0
 800102c:	4249      	negs	r1, r1
 800102e:	4276      	negs	r6, r6
 8001030:	425b      	negs	r3, r3
 8001032:	1864      	adds	r4, r4, r1
 8001034:	4333      	orrs	r3, r6
 8001036:	4498      	add	r8, r3
 8001038:	428c      	cmp	r4, r1
 800103a:	4189      	sbcs	r1, r1
 800103c:	45ab      	cmp	fp, r5
 800103e:	419b      	sbcs	r3, r3
 8001040:	4249      	negs	r1, r1
 8001042:	425b      	negs	r3, r3
 8001044:	4319      	orrs	r1, r3
 8001046:	1c0d      	adds	r5, r1, #0
 8001048:	9b00      	ldr	r3, [sp, #0]
 800104a:	4445      	add	r5, r8
 800104c:	18ee      	adds	r6, r5, r3
 800104e:	0276      	lsls	r6, r6, #9
 8001050:	0de5      	lsrs	r5, r4, #23
 8001052:	432e      	orrs	r6, r5
 8001054:	46b3      	mov	fp, r6
 8001056:	9b04      	ldr	r3, [sp, #16]
 8001058:	0256      	lsls	r6, r2, #9
 800105a:	431e      	orrs	r6, r3
 800105c:	1e73      	subs	r3, r6, #1
 800105e:	419e      	sbcs	r6, r3
 8001060:	465b      	mov	r3, fp
 8001062:	0dd2      	lsrs	r2, r2, #23
 8001064:	4332      	orrs	r2, r6
 8001066:	0266      	lsls	r6, r4, #9
 8001068:	4316      	orrs	r6, r2
 800106a:	01db      	lsls	r3, r3, #7
 800106c:	d50a      	bpl.n	8001084 <__aeabi_dmul+0x384>
 800106e:	2301      	movs	r3, #1
 8001070:	4033      	ands	r3, r6
 8001072:	0876      	lsrs	r6, r6, #1
 8001074:	431e      	orrs	r6, r3
 8001076:	465b      	mov	r3, fp
 8001078:	07db      	lsls	r3, r3, #31
 800107a:	431e      	orrs	r6, r3
 800107c:	465b      	mov	r3, fp
 800107e:	085b      	lsrs	r3, r3, #1
 8001080:	469b      	mov	fp, r3
 8001082:	4657      	mov	r7, sl
 8001084:	4b63      	ldr	r3, [pc, #396]	; (8001214 <__aeabi_dmul+0x514>)
 8001086:	18fb      	adds	r3, r7, r3
 8001088:	2b00      	cmp	r3, #0
 800108a:	dd5a      	ble.n	8001142 <__aeabi_dmul+0x442>
 800108c:	0772      	lsls	r2, r6, #29
 800108e:	d009      	beq.n	80010a4 <__aeabi_dmul+0x3a4>
 8001090:	220f      	movs	r2, #15
 8001092:	4032      	ands	r2, r6
 8001094:	2a04      	cmp	r2, #4
 8001096:	d005      	beq.n	80010a4 <__aeabi_dmul+0x3a4>
 8001098:	1d32      	adds	r2, r6, #4
 800109a:	42b2      	cmp	r2, r6
 800109c:	41b6      	sbcs	r6, r6
 800109e:	4276      	negs	r6, r6
 80010a0:	44b3      	add	fp, r6
 80010a2:	1c16      	adds	r6, r2, #0
 80010a4:	465a      	mov	r2, fp
 80010a6:	01d2      	lsls	r2, r2, #7
 80010a8:	d506      	bpl.n	80010b8 <__aeabi_dmul+0x3b8>
 80010aa:	465a      	mov	r2, fp
 80010ac:	4b5a      	ldr	r3, [pc, #360]	; (8001218 <__aeabi_dmul+0x518>)
 80010ae:	401a      	ands	r2, r3
 80010b0:	2380      	movs	r3, #128	; 0x80
 80010b2:	4693      	mov	fp, r2
 80010b4:	00db      	lsls	r3, r3, #3
 80010b6:	18fb      	adds	r3, r7, r3
 80010b8:	4a58      	ldr	r2, [pc, #352]	; (800121c <__aeabi_dmul+0x51c>)
 80010ba:	4293      	cmp	r3, r2
 80010bc:	dd34      	ble.n	8001128 <__aeabi_dmul+0x428>
 80010be:	2401      	movs	r4, #1
 80010c0:	9b02      	ldr	r3, [sp, #8]
 80010c2:	2500      	movs	r5, #0
 80010c4:	401c      	ands	r4, r3
 80010c6:	2600      	movs	r6, #0
 80010c8:	4b55      	ldr	r3, [pc, #340]	; (8001220 <__aeabi_dmul+0x520>)
 80010ca:	e67d      	b.n	8000dc8 <__aeabi_dmul+0xc8>
 80010cc:	2080      	movs	r0, #128	; 0x80
 80010ce:	465b      	mov	r3, fp
 80010d0:	0300      	lsls	r0, r0, #12
 80010d2:	4203      	tst	r3, r0
 80010d4:	d008      	beq.n	80010e8 <__aeabi_dmul+0x3e8>
 80010d6:	4205      	tst	r5, r0
 80010d8:	d106      	bne.n	80010e8 <__aeabi_dmul+0x3e8>
 80010da:	4305      	orrs	r5, r0
 80010dc:	032d      	lsls	r5, r5, #12
 80010de:	0b2d      	lsrs	r5, r5, #12
 80010e0:	464c      	mov	r4, r9
 80010e2:	1c16      	adds	r6, r2, #0
 80010e4:	4b4e      	ldr	r3, [pc, #312]	; (8001220 <__aeabi_dmul+0x520>)
 80010e6:	e66f      	b.n	8000dc8 <__aeabi_dmul+0xc8>
 80010e8:	465d      	mov	r5, fp
 80010ea:	4305      	orrs	r5, r0
 80010ec:	032d      	lsls	r5, r5, #12
 80010ee:	0b2d      	lsrs	r5, r5, #12
 80010f0:	4b4b      	ldr	r3, [pc, #300]	; (8001220 <__aeabi_dmul+0x520>)
 80010f2:	e669      	b.n	8000dc8 <__aeabi_dmul+0xc8>
 80010f4:	4650      	mov	r0, sl
 80010f6:	f000 fdc9 	bl	8001c8c <__clzsi2>
 80010fa:	1c03      	adds	r3, r0, #0
 80010fc:	3320      	adds	r3, #32
 80010fe:	2b27      	cmp	r3, #39	; 0x27
 8001100:	dc00      	bgt.n	8001104 <__aeabi_dmul+0x404>
 8001102:	e6a6      	b.n	8000e52 <__aeabi_dmul+0x152>
 8001104:	4655      	mov	r5, sl
 8001106:	3808      	subs	r0, #8
 8001108:	4085      	lsls	r5, r0
 800110a:	2200      	movs	r2, #0
 800110c:	e6ac      	b.n	8000e68 <__aeabi_dmul+0x168>
 800110e:	1c28      	adds	r0, r5, #0
 8001110:	f000 fdbc 	bl	8001c8c <__clzsi2>
 8001114:	1c02      	adds	r2, r0, #0
 8001116:	3220      	adds	r2, #32
 8001118:	2a27      	cmp	r2, #39	; 0x27
 800111a:	dc00      	bgt.n	800111e <__aeabi_dmul+0x41e>
 800111c:	e675      	b.n	8000e0a <__aeabi_dmul+0x10a>
 800111e:	3808      	subs	r0, #8
 8001120:	4085      	lsls	r5, r0
 8001122:	2600      	movs	r6, #0
 8001124:	46ab      	mov	fp, r5
 8001126:	e67d      	b.n	8000e24 <__aeabi_dmul+0x124>
 8001128:	465a      	mov	r2, fp
 800112a:	08f6      	lsrs	r6, r6, #3
 800112c:	0752      	lsls	r2, r2, #29
 800112e:	4316      	orrs	r6, r2
 8001130:	465a      	mov	r2, fp
 8001132:	2401      	movs	r4, #1
 8001134:	0255      	lsls	r5, r2, #9
 8001136:	9a02      	ldr	r2, [sp, #8]
 8001138:	055b      	lsls	r3, r3, #21
 800113a:	0b2d      	lsrs	r5, r5, #12
 800113c:	0d5b      	lsrs	r3, r3, #21
 800113e:	4014      	ands	r4, r2
 8001140:	e642      	b.n	8000dc8 <__aeabi_dmul+0xc8>
 8001142:	4d38      	ldr	r5, [pc, #224]	; (8001224 <__aeabi_dmul+0x524>)
 8001144:	1bed      	subs	r5, r5, r7
 8001146:	2d38      	cmp	r5, #56	; 0x38
 8001148:	dd0a      	ble.n	8001160 <__aeabi_dmul+0x460>
 800114a:	2401      	movs	r4, #1
 800114c:	9b02      	ldr	r3, [sp, #8]
 800114e:	2500      	movs	r5, #0
 8001150:	401c      	ands	r4, r3
 8001152:	2600      	movs	r6, #0
 8001154:	2300      	movs	r3, #0
 8001156:	e637      	b.n	8000dc8 <__aeabi_dmul+0xc8>
 8001158:	9b01      	ldr	r3, [sp, #4]
 800115a:	4657      	mov	r7, sl
 800115c:	9302      	str	r3, [sp, #8]
 800115e:	e791      	b.n	8001084 <__aeabi_dmul+0x384>
 8001160:	2d1f      	cmp	r5, #31
 8001162:	dc25      	bgt.n	80011b0 <__aeabi_dmul+0x4b0>
 8001164:	4b30      	ldr	r3, [pc, #192]	; (8001228 <__aeabi_dmul+0x528>)
 8001166:	1c32      	adds	r2, r6, #0
 8001168:	469c      	mov	ip, r3
 800116a:	4467      	add	r7, ip
 800116c:	40be      	lsls	r6, r7
 800116e:	465b      	mov	r3, fp
 8001170:	40bb      	lsls	r3, r7
 8001172:	1c37      	adds	r7, r6, #0
 8001174:	40ea      	lsrs	r2, r5
 8001176:	1e7e      	subs	r6, r7, #1
 8001178:	41b7      	sbcs	r7, r6
 800117a:	4313      	orrs	r3, r2
 800117c:	433b      	orrs	r3, r7
 800117e:	1c1e      	adds	r6, r3, #0
 8001180:	465b      	mov	r3, fp
 8001182:	40eb      	lsrs	r3, r5
 8001184:	1c1d      	adds	r5, r3, #0
 8001186:	0773      	lsls	r3, r6, #29
 8001188:	d009      	beq.n	800119e <__aeabi_dmul+0x49e>
 800118a:	230f      	movs	r3, #15
 800118c:	4033      	ands	r3, r6
 800118e:	2b04      	cmp	r3, #4
 8001190:	d005      	beq.n	800119e <__aeabi_dmul+0x49e>
 8001192:	1d33      	adds	r3, r6, #4
 8001194:	42b3      	cmp	r3, r6
 8001196:	41b6      	sbcs	r6, r6
 8001198:	4276      	negs	r6, r6
 800119a:	19ad      	adds	r5, r5, r6
 800119c:	1c1e      	adds	r6, r3, #0
 800119e:	022b      	lsls	r3, r5, #8
 80011a0:	d520      	bpl.n	80011e4 <__aeabi_dmul+0x4e4>
 80011a2:	2401      	movs	r4, #1
 80011a4:	9b02      	ldr	r3, [sp, #8]
 80011a6:	2500      	movs	r5, #0
 80011a8:	401c      	ands	r4, r3
 80011aa:	2600      	movs	r6, #0
 80011ac:	2301      	movs	r3, #1
 80011ae:	e60b      	b.n	8000dc8 <__aeabi_dmul+0xc8>
 80011b0:	465a      	mov	r2, fp
 80011b2:	4b1e      	ldr	r3, [pc, #120]	; (800122c <__aeabi_dmul+0x52c>)
 80011b4:	1bdb      	subs	r3, r3, r7
 80011b6:	40da      	lsrs	r2, r3
 80011b8:	1c13      	adds	r3, r2, #0
 80011ba:	2d20      	cmp	r5, #32
 80011bc:	d01c      	beq.n	80011f8 <__aeabi_dmul+0x4f8>
 80011be:	4a1c      	ldr	r2, [pc, #112]	; (8001230 <__aeabi_dmul+0x530>)
 80011c0:	4694      	mov	ip, r2
 80011c2:	465a      	mov	r2, fp
 80011c4:	4467      	add	r7, ip
 80011c6:	40ba      	lsls	r2, r7
 80011c8:	1c17      	adds	r7, r2, #0
 80011ca:	433e      	orrs	r6, r7
 80011cc:	1e72      	subs	r2, r6, #1
 80011ce:	4196      	sbcs	r6, r2
 80011d0:	431e      	orrs	r6, r3
 80011d2:	2307      	movs	r3, #7
 80011d4:	2500      	movs	r5, #0
 80011d6:	4033      	ands	r3, r6
 80011d8:	d007      	beq.n	80011ea <__aeabi_dmul+0x4ea>
 80011da:	230f      	movs	r3, #15
 80011dc:	2500      	movs	r5, #0
 80011de:	4033      	ands	r3, r6
 80011e0:	2b04      	cmp	r3, #4
 80011e2:	d1d6      	bne.n	8001192 <__aeabi_dmul+0x492>
 80011e4:	076b      	lsls	r3, r5, #29
 80011e6:	026d      	lsls	r5, r5, #9
 80011e8:	0b2d      	lsrs	r5, r5, #12
 80011ea:	2401      	movs	r4, #1
 80011ec:	08f6      	lsrs	r6, r6, #3
 80011ee:	431e      	orrs	r6, r3
 80011f0:	9b02      	ldr	r3, [sp, #8]
 80011f2:	401c      	ands	r4, r3
 80011f4:	2300      	movs	r3, #0
 80011f6:	e5e7      	b.n	8000dc8 <__aeabi_dmul+0xc8>
 80011f8:	2700      	movs	r7, #0
 80011fa:	e7e6      	b.n	80011ca <__aeabi_dmul+0x4ca>
 80011fc:	2580      	movs	r5, #128	; 0x80
 80011fe:	465b      	mov	r3, fp
 8001200:	2401      	movs	r4, #1
 8001202:	032d      	lsls	r5, r5, #12
 8001204:	431d      	orrs	r5, r3
 8001206:	9b01      	ldr	r3, [sp, #4]
 8001208:	032d      	lsls	r5, r5, #12
 800120a:	4023      	ands	r3, r4
 800120c:	1c1c      	adds	r4, r3, #0
 800120e:	0b2d      	lsrs	r5, r5, #12
 8001210:	4b03      	ldr	r3, [pc, #12]	; (8001220 <__aeabi_dmul+0x520>)
 8001212:	e5d9      	b.n	8000dc8 <__aeabi_dmul+0xc8>
 8001214:	000003ff 	.word	0x000003ff
 8001218:	feffffff 	.word	0xfeffffff
 800121c:	000007fe 	.word	0x000007fe
 8001220:	000007ff 	.word	0x000007ff
 8001224:	fffffc02 	.word	0xfffffc02
 8001228:	0000041e 	.word	0x0000041e
 800122c:	fffffbe2 	.word	0xfffffbe2
 8001230:	0000043e 	.word	0x0000043e

08001234 <__aeabi_dsub>:
 8001234:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001236:	464d      	mov	r5, r9
 8001238:	4644      	mov	r4, r8
 800123a:	465f      	mov	r7, fp
 800123c:	4656      	mov	r6, sl
 800123e:	b4f0      	push	{r4, r5, r6, r7}
 8001240:	1c0e      	adds	r6, r1, #0
 8001242:	1c11      	adds	r1, r2, #0
 8001244:	0332      	lsls	r2, r6, #12
 8001246:	0a52      	lsrs	r2, r2, #9
 8001248:	0f47      	lsrs	r7, r0, #29
 800124a:	4317      	orrs	r7, r2
 800124c:	00c5      	lsls	r5, r0, #3
 800124e:	031a      	lsls	r2, r3, #12
 8001250:	0058      	lsls	r0, r3, #1
 8001252:	0fdb      	lsrs	r3, r3, #31
 8001254:	4699      	mov	r9, r3
 8001256:	0a52      	lsrs	r2, r2, #9
 8001258:	0f4b      	lsrs	r3, r1, #29
 800125a:	b083      	sub	sp, #12
 800125c:	431a      	orrs	r2, r3
 800125e:	00cb      	lsls	r3, r1, #3
 8001260:	9301      	str	r3, [sp, #4]
 8001262:	4bcf      	ldr	r3, [pc, #828]	; (80015a0 <__aeabi_dsub+0x36c>)
 8001264:	0074      	lsls	r4, r6, #1
 8001266:	0ff6      	lsrs	r6, r6, #31
 8001268:	0d64      	lsrs	r4, r4, #21
 800126a:	46b0      	mov	r8, r6
 800126c:	0d40      	lsrs	r0, r0, #21
 800126e:	4298      	cmp	r0, r3
 8001270:	d100      	bne.n	8001274 <__aeabi_dsub+0x40>
 8001272:	e0e8      	b.n	8001446 <__aeabi_dsub+0x212>
 8001274:	2301      	movs	r3, #1
 8001276:	4649      	mov	r1, r9
 8001278:	4059      	eors	r1, r3
 800127a:	1c0b      	adds	r3, r1, #0
 800127c:	429e      	cmp	r6, r3
 800127e:	d100      	bne.n	8001282 <__aeabi_dsub+0x4e>
 8001280:	e0b1      	b.n	80013e6 <__aeabi_dsub+0x1b2>
 8001282:	1a26      	subs	r6, r4, r0
 8001284:	2e00      	cmp	r6, #0
 8001286:	dc00      	bgt.n	800128a <__aeabi_dsub+0x56>
 8001288:	e11c      	b.n	80014c4 <__aeabi_dsub+0x290>
 800128a:	2800      	cmp	r0, #0
 800128c:	d142      	bne.n	8001314 <__aeabi_dsub+0xe0>
 800128e:	1c13      	adds	r3, r2, #0
 8001290:	9901      	ldr	r1, [sp, #4]
 8001292:	430b      	orrs	r3, r1
 8001294:	d000      	beq.n	8001298 <__aeabi_dsub+0x64>
 8001296:	e0e6      	b.n	8001466 <__aeabi_dsub+0x232>
 8001298:	076b      	lsls	r3, r5, #29
 800129a:	d100      	bne.n	800129e <__aeabi_dsub+0x6a>
 800129c:	e08e      	b.n	80013bc <__aeabi_dsub+0x188>
 800129e:	230f      	movs	r3, #15
 80012a0:	402b      	ands	r3, r5
 80012a2:	2b04      	cmp	r3, #4
 80012a4:	d100      	bne.n	80012a8 <__aeabi_dsub+0x74>
 80012a6:	e089      	b.n	80013bc <__aeabi_dsub+0x188>
 80012a8:	1d2a      	adds	r2, r5, #4
 80012aa:	42aa      	cmp	r2, r5
 80012ac:	41ad      	sbcs	r5, r5
 80012ae:	2380      	movs	r3, #128	; 0x80
 80012b0:	2601      	movs	r6, #1
 80012b2:	4641      	mov	r1, r8
 80012b4:	426d      	negs	r5, r5
 80012b6:	197f      	adds	r7, r7, r5
 80012b8:	041b      	lsls	r3, r3, #16
 80012ba:	403b      	ands	r3, r7
 80012bc:	400e      	ands	r6, r1
 80012be:	1c15      	adds	r5, r2, #0
 80012c0:	2b00      	cmp	r3, #0
 80012c2:	d100      	bne.n	80012c6 <__aeabi_dsub+0x92>
 80012c4:	e083      	b.n	80013ce <__aeabi_dsub+0x19a>
 80012c6:	4bb6      	ldr	r3, [pc, #728]	; (80015a0 <__aeabi_dsub+0x36c>)
 80012c8:	3401      	adds	r4, #1
 80012ca:	429c      	cmp	r4, r3
 80012cc:	d100      	bne.n	80012d0 <__aeabi_dsub+0x9c>
 80012ce:	e116      	b.n	80014fe <__aeabi_dsub+0x2ca>
 80012d0:	1c3a      	adds	r2, r7, #0
 80012d2:	4bb4      	ldr	r3, [pc, #720]	; (80015a4 <__aeabi_dsub+0x370>)
 80012d4:	08ed      	lsrs	r5, r5, #3
 80012d6:	401a      	ands	r2, r3
 80012d8:	0750      	lsls	r0, r2, #29
 80012da:	0564      	lsls	r4, r4, #21
 80012dc:	0252      	lsls	r2, r2, #9
 80012de:	4305      	orrs	r5, r0
 80012e0:	0b12      	lsrs	r2, r2, #12
 80012e2:	0d64      	lsrs	r4, r4, #21
 80012e4:	2100      	movs	r1, #0
 80012e6:	0312      	lsls	r2, r2, #12
 80012e8:	0d0b      	lsrs	r3, r1, #20
 80012ea:	051b      	lsls	r3, r3, #20
 80012ec:	0564      	lsls	r4, r4, #21
 80012ee:	0b12      	lsrs	r2, r2, #12
 80012f0:	431a      	orrs	r2, r3
 80012f2:	0863      	lsrs	r3, r4, #1
 80012f4:	4cac      	ldr	r4, [pc, #688]	; (80015a8 <__aeabi_dsub+0x374>)
 80012f6:	07f6      	lsls	r6, r6, #31
 80012f8:	4014      	ands	r4, r2
 80012fa:	431c      	orrs	r4, r3
 80012fc:	0064      	lsls	r4, r4, #1
 80012fe:	0864      	lsrs	r4, r4, #1
 8001300:	4334      	orrs	r4, r6
 8001302:	1c28      	adds	r0, r5, #0
 8001304:	1c21      	adds	r1, r4, #0
 8001306:	b003      	add	sp, #12
 8001308:	bc3c      	pop	{r2, r3, r4, r5}
 800130a:	4690      	mov	r8, r2
 800130c:	4699      	mov	r9, r3
 800130e:	46a2      	mov	sl, r4
 8001310:	46ab      	mov	fp, r5
 8001312:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001314:	4ba2      	ldr	r3, [pc, #648]	; (80015a0 <__aeabi_dsub+0x36c>)
 8001316:	429c      	cmp	r4, r3
 8001318:	d0be      	beq.n	8001298 <__aeabi_dsub+0x64>
 800131a:	2380      	movs	r3, #128	; 0x80
 800131c:	041b      	lsls	r3, r3, #16
 800131e:	431a      	orrs	r2, r3
 8001320:	2e38      	cmp	r6, #56	; 0x38
 8001322:	dd00      	ble.n	8001326 <__aeabi_dsub+0xf2>
 8001324:	e103      	b.n	800152e <__aeabi_dsub+0x2fa>
 8001326:	2e1f      	cmp	r6, #31
 8001328:	dd00      	ble.n	800132c <__aeabi_dsub+0xf8>
 800132a:	e13f      	b.n	80015ac <__aeabi_dsub+0x378>
 800132c:	2020      	movs	r0, #32
 800132e:	1b83      	subs	r3, r0, r6
 8001330:	4699      	mov	r9, r3
 8001332:	1c13      	adds	r3, r2, #0
 8001334:	4649      	mov	r1, r9
 8001336:	408b      	lsls	r3, r1
 8001338:	469c      	mov	ip, r3
 800133a:	9b01      	ldr	r3, [sp, #4]
 800133c:	4660      	mov	r0, ip
 800133e:	40f3      	lsrs	r3, r6
 8001340:	4303      	orrs	r3, r0
 8001342:	9801      	ldr	r0, [sp, #4]
 8001344:	40f2      	lsrs	r2, r6
 8001346:	4088      	lsls	r0, r1
 8001348:	1c01      	adds	r1, r0, #0
 800134a:	1e48      	subs	r0, r1, #1
 800134c:	4181      	sbcs	r1, r0
 800134e:	430b      	orrs	r3, r1
 8001350:	1aeb      	subs	r3, r5, r3
 8001352:	429d      	cmp	r5, r3
 8001354:	4180      	sbcs	r0, r0
 8001356:	1c1d      	adds	r5, r3, #0
 8001358:	1aba      	subs	r2, r7, r2
 800135a:	4240      	negs	r0, r0
 800135c:	1a17      	subs	r7, r2, r0
 800135e:	023b      	lsls	r3, r7, #8
 8001360:	d400      	bmi.n	8001364 <__aeabi_dsub+0x130>
 8001362:	e0a8      	b.n	80014b6 <__aeabi_dsub+0x282>
 8001364:	027a      	lsls	r2, r7, #9
 8001366:	0a56      	lsrs	r6, r2, #9
 8001368:	2e00      	cmp	r6, #0
 800136a:	d100      	bne.n	800136e <__aeabi_dsub+0x13a>
 800136c:	e0ca      	b.n	8001504 <__aeabi_dsub+0x2d0>
 800136e:	1c30      	adds	r0, r6, #0
 8001370:	f000 fc8c 	bl	8001c8c <__clzsi2>
 8001374:	1c03      	adds	r3, r0, #0
 8001376:	3b08      	subs	r3, #8
 8001378:	2b1f      	cmp	r3, #31
 800137a:	dd00      	ble.n	800137e <__aeabi_dsub+0x14a>
 800137c:	e0cb      	b.n	8001516 <__aeabi_dsub+0x2e2>
 800137e:	2228      	movs	r2, #40	; 0x28
 8001380:	1c29      	adds	r1, r5, #0
 8001382:	1a12      	subs	r2, r2, r0
 8001384:	40d1      	lsrs	r1, r2
 8001386:	409e      	lsls	r6, r3
 8001388:	1c0a      	adds	r2, r1, #0
 800138a:	409d      	lsls	r5, r3
 800138c:	4332      	orrs	r2, r6
 800138e:	429c      	cmp	r4, r3
 8001390:	dd00      	ble.n	8001394 <__aeabi_dsub+0x160>
 8001392:	e0c8      	b.n	8001526 <__aeabi_dsub+0x2f2>
 8001394:	1b1c      	subs	r4, r3, r4
 8001396:	1c67      	adds	r7, r4, #1
 8001398:	2f1f      	cmp	r7, #31
 800139a:	dd00      	ble.n	800139e <__aeabi_dsub+0x16a>
 800139c:	e0ed      	b.n	800157a <__aeabi_dsub+0x346>
 800139e:	231f      	movs	r3, #31
 80013a0:	1c29      	adds	r1, r5, #0
 80013a2:	1b1c      	subs	r4, r3, r4
 80013a4:	1c13      	adds	r3, r2, #0
 80013a6:	40a5      	lsls	r5, r4
 80013a8:	40a3      	lsls	r3, r4
 80013aa:	40f9      	lsrs	r1, r7
 80013ac:	1e6c      	subs	r4, r5, #1
 80013ae:	41a5      	sbcs	r5, r4
 80013b0:	40fa      	lsrs	r2, r7
 80013b2:	4319      	orrs	r1, r3
 80013b4:	430d      	orrs	r5, r1
 80013b6:	1c17      	adds	r7, r2, #0
 80013b8:	2400      	movs	r4, #0
 80013ba:	e76d      	b.n	8001298 <__aeabi_dsub+0x64>
 80013bc:	2380      	movs	r3, #128	; 0x80
 80013be:	2601      	movs	r6, #1
 80013c0:	4642      	mov	r2, r8
 80013c2:	041b      	lsls	r3, r3, #16
 80013c4:	403b      	ands	r3, r7
 80013c6:	4016      	ands	r6, r2
 80013c8:	2b00      	cmp	r3, #0
 80013ca:	d000      	beq.n	80013ce <__aeabi_dsub+0x19a>
 80013cc:	e77b      	b.n	80012c6 <__aeabi_dsub+0x92>
 80013ce:	4b74      	ldr	r3, [pc, #464]	; (80015a0 <__aeabi_dsub+0x36c>)
 80013d0:	08ed      	lsrs	r5, r5, #3
 80013d2:	0778      	lsls	r0, r7, #29
 80013d4:	4305      	orrs	r5, r0
 80013d6:	08fa      	lsrs	r2, r7, #3
 80013d8:	429c      	cmp	r4, r3
 80013da:	d03b      	beq.n	8001454 <__aeabi_dsub+0x220>
 80013dc:	0312      	lsls	r2, r2, #12
 80013de:	0564      	lsls	r4, r4, #21
 80013e0:	0b12      	lsrs	r2, r2, #12
 80013e2:	0d64      	lsrs	r4, r4, #21
 80013e4:	e77e      	b.n	80012e4 <__aeabi_dsub+0xb0>
 80013e6:	1a23      	subs	r3, r4, r0
 80013e8:	469a      	mov	sl, r3
 80013ea:	2b00      	cmp	r3, #0
 80013ec:	dc00      	bgt.n	80013f0 <__aeabi_dsub+0x1bc>
 80013ee:	e0a5      	b.n	800153c <__aeabi_dsub+0x308>
 80013f0:	2800      	cmp	r0, #0
 80013f2:	d044      	beq.n	800147e <__aeabi_dsub+0x24a>
 80013f4:	486a      	ldr	r0, [pc, #424]	; (80015a0 <__aeabi_dsub+0x36c>)
 80013f6:	4284      	cmp	r4, r0
 80013f8:	d100      	bne.n	80013fc <__aeabi_dsub+0x1c8>
 80013fa:	e74d      	b.n	8001298 <__aeabi_dsub+0x64>
 80013fc:	2080      	movs	r0, #128	; 0x80
 80013fe:	0400      	lsls	r0, r0, #16
 8001400:	4302      	orrs	r2, r0
 8001402:	4653      	mov	r3, sl
 8001404:	2b38      	cmp	r3, #56	; 0x38
 8001406:	dc00      	bgt.n	800140a <__aeabi_dsub+0x1d6>
 8001408:	e11c      	b.n	8001644 <__aeabi_dsub+0x410>
 800140a:	9b01      	ldr	r3, [sp, #4]
 800140c:	431a      	orrs	r2, r3
 800140e:	1e51      	subs	r1, r2, #1
 8001410:	418a      	sbcs	r2, r1
 8001412:	b2d1      	uxtb	r1, r2
 8001414:	2200      	movs	r2, #0
 8001416:	1949      	adds	r1, r1, r5
 8001418:	42a9      	cmp	r1, r5
 800141a:	4180      	sbcs	r0, r0
 800141c:	1c0d      	adds	r5, r1, #0
 800141e:	19d2      	adds	r2, r2, r7
 8001420:	4240      	negs	r0, r0
 8001422:	1817      	adds	r7, r2, r0
 8001424:	023b      	lsls	r3, r7, #8
 8001426:	d546      	bpl.n	80014b6 <__aeabi_dsub+0x282>
 8001428:	4b5d      	ldr	r3, [pc, #372]	; (80015a0 <__aeabi_dsub+0x36c>)
 800142a:	3401      	adds	r4, #1
 800142c:	429c      	cmp	r4, r3
 800142e:	d100      	bne.n	8001432 <__aeabi_dsub+0x1fe>
 8001430:	e169      	b.n	8001706 <__aeabi_dsub+0x4d2>
 8001432:	2001      	movs	r0, #1
 8001434:	4a5b      	ldr	r2, [pc, #364]	; (80015a4 <__aeabi_dsub+0x370>)
 8001436:	086b      	lsrs	r3, r5, #1
 8001438:	403a      	ands	r2, r7
 800143a:	4028      	ands	r0, r5
 800143c:	4318      	orrs	r0, r3
 800143e:	07d5      	lsls	r5, r2, #31
 8001440:	4305      	orrs	r5, r0
 8001442:	0857      	lsrs	r7, r2, #1
 8001444:	e728      	b.n	8001298 <__aeabi_dsub+0x64>
 8001446:	1c13      	adds	r3, r2, #0
 8001448:	9901      	ldr	r1, [sp, #4]
 800144a:	430b      	orrs	r3, r1
 800144c:	d100      	bne.n	8001450 <__aeabi_dsub+0x21c>
 800144e:	e711      	b.n	8001274 <__aeabi_dsub+0x40>
 8001450:	464b      	mov	r3, r9
 8001452:	e713      	b.n	800127c <__aeabi_dsub+0x48>
 8001454:	1c2b      	adds	r3, r5, #0
 8001456:	4313      	orrs	r3, r2
 8001458:	d051      	beq.n	80014fe <__aeabi_dsub+0x2ca>
 800145a:	2380      	movs	r3, #128	; 0x80
 800145c:	031b      	lsls	r3, r3, #12
 800145e:	431a      	orrs	r2, r3
 8001460:	0312      	lsls	r2, r2, #12
 8001462:	0b12      	lsrs	r2, r2, #12
 8001464:	e73e      	b.n	80012e4 <__aeabi_dsub+0xb0>
 8001466:	3e01      	subs	r6, #1
 8001468:	2e00      	cmp	r6, #0
 800146a:	d000      	beq.n	800146e <__aeabi_dsub+0x23a>
 800146c:	e080      	b.n	8001570 <__aeabi_dsub+0x33c>
 800146e:	1a69      	subs	r1, r5, r1
 8001470:	428d      	cmp	r5, r1
 8001472:	419b      	sbcs	r3, r3
 8001474:	1aba      	subs	r2, r7, r2
 8001476:	425b      	negs	r3, r3
 8001478:	1ad7      	subs	r7, r2, r3
 800147a:	1c0d      	adds	r5, r1, #0
 800147c:	e76f      	b.n	800135e <__aeabi_dsub+0x12a>
 800147e:	1c10      	adds	r0, r2, #0
 8001480:	9b01      	ldr	r3, [sp, #4]
 8001482:	4318      	orrs	r0, r3
 8001484:	d100      	bne.n	8001488 <__aeabi_dsub+0x254>
 8001486:	e707      	b.n	8001298 <__aeabi_dsub+0x64>
 8001488:	2301      	movs	r3, #1
 800148a:	425b      	negs	r3, r3
 800148c:	469c      	mov	ip, r3
 800148e:	44e2      	add	sl, ip
 8001490:	4653      	mov	r3, sl
 8001492:	2b00      	cmp	r3, #0
 8001494:	d000      	beq.n	8001498 <__aeabi_dsub+0x264>
 8001496:	e102      	b.n	800169e <__aeabi_dsub+0x46a>
 8001498:	9b01      	ldr	r3, [sp, #4]
 800149a:	19d2      	adds	r2, r2, r7
 800149c:	1959      	adds	r1, r3, r5
 800149e:	42a9      	cmp	r1, r5
 80014a0:	419b      	sbcs	r3, r3
 80014a2:	425b      	negs	r3, r3
 80014a4:	18d7      	adds	r7, r2, r3
 80014a6:	1c0d      	adds	r5, r1, #0
 80014a8:	e7bc      	b.n	8001424 <__aeabi_dsub+0x1f0>
 80014aa:	4663      	mov	r3, ip
 80014ac:	4303      	orrs	r3, r0
 80014ae:	d100      	bne.n	80014b2 <__aeabi_dsub+0x27e>
 80014b0:	e128      	b.n	8001704 <__aeabi_dsub+0x4d0>
 80014b2:	1c07      	adds	r7, r0, #0
 80014b4:	4665      	mov	r5, ip
 80014b6:	076b      	lsls	r3, r5, #29
 80014b8:	d000      	beq.n	80014bc <__aeabi_dsub+0x288>
 80014ba:	e6f0      	b.n	800129e <__aeabi_dsub+0x6a>
 80014bc:	2601      	movs	r6, #1
 80014be:	4643      	mov	r3, r8
 80014c0:	401e      	ands	r6, r3
 80014c2:	e784      	b.n	80013ce <__aeabi_dsub+0x19a>
 80014c4:	2e00      	cmp	r6, #0
 80014c6:	d000      	beq.n	80014ca <__aeabi_dsub+0x296>
 80014c8:	e081      	b.n	80015ce <__aeabi_dsub+0x39a>
 80014ca:	1c60      	adds	r0, r4, #1
 80014cc:	0540      	lsls	r0, r0, #21
 80014ce:	0d40      	lsrs	r0, r0, #21
 80014d0:	2801      	cmp	r0, #1
 80014d2:	dc00      	bgt.n	80014d6 <__aeabi_dsub+0x2a2>
 80014d4:	e107      	b.n	80016e6 <__aeabi_dsub+0x4b2>
 80014d6:	9901      	ldr	r1, [sp, #4]
 80014d8:	1a68      	subs	r0, r5, r1
 80014da:	4684      	mov	ip, r0
 80014dc:	4565      	cmp	r5, ip
 80014de:	41b6      	sbcs	r6, r6
 80014e0:	1ab8      	subs	r0, r7, r2
 80014e2:	4276      	negs	r6, r6
 80014e4:	1b86      	subs	r6, r0, r6
 80014e6:	0230      	lsls	r0, r6, #8
 80014e8:	d400      	bmi.n	80014ec <__aeabi_dsub+0x2b8>
 80014ea:	e0a1      	b.n	8001630 <__aeabi_dsub+0x3fc>
 80014ec:	468c      	mov	ip, r1
 80014ee:	1b4d      	subs	r5, r1, r5
 80014f0:	45ac      	cmp	ip, r5
 80014f2:	4189      	sbcs	r1, r1
 80014f4:	1bd2      	subs	r2, r2, r7
 80014f6:	4249      	negs	r1, r1
 80014f8:	1a56      	subs	r6, r2, r1
 80014fa:	4698      	mov	r8, r3
 80014fc:	e734      	b.n	8001368 <__aeabi_dsub+0x134>
 80014fe:	2200      	movs	r2, #0
 8001500:	2500      	movs	r5, #0
 8001502:	e6ef      	b.n	80012e4 <__aeabi_dsub+0xb0>
 8001504:	1c28      	adds	r0, r5, #0
 8001506:	f000 fbc1 	bl	8001c8c <__clzsi2>
 800150a:	3020      	adds	r0, #32
 800150c:	1c03      	adds	r3, r0, #0
 800150e:	3b08      	subs	r3, #8
 8001510:	2b1f      	cmp	r3, #31
 8001512:	dc00      	bgt.n	8001516 <__aeabi_dsub+0x2e2>
 8001514:	e733      	b.n	800137e <__aeabi_dsub+0x14a>
 8001516:	1c02      	adds	r2, r0, #0
 8001518:	3a28      	subs	r2, #40	; 0x28
 800151a:	4095      	lsls	r5, r2
 800151c:	1c2a      	adds	r2, r5, #0
 800151e:	2500      	movs	r5, #0
 8001520:	429c      	cmp	r4, r3
 8001522:	dc00      	bgt.n	8001526 <__aeabi_dsub+0x2f2>
 8001524:	e736      	b.n	8001394 <__aeabi_dsub+0x160>
 8001526:	4f1f      	ldr	r7, [pc, #124]	; (80015a4 <__aeabi_dsub+0x370>)
 8001528:	1ae4      	subs	r4, r4, r3
 800152a:	4017      	ands	r7, r2
 800152c:	e6b4      	b.n	8001298 <__aeabi_dsub+0x64>
 800152e:	9b01      	ldr	r3, [sp, #4]
 8001530:	431a      	orrs	r2, r3
 8001532:	1e51      	subs	r1, r2, #1
 8001534:	418a      	sbcs	r2, r1
 8001536:	b2d3      	uxtb	r3, r2
 8001538:	2200      	movs	r2, #0
 800153a:	e709      	b.n	8001350 <__aeabi_dsub+0x11c>
 800153c:	2b00      	cmp	r3, #0
 800153e:	d000      	beq.n	8001542 <__aeabi_dsub+0x30e>
 8001540:	e101      	b.n	8001746 <__aeabi_dsub+0x512>
 8001542:	1c60      	adds	r0, r4, #1
 8001544:	0543      	lsls	r3, r0, #21
 8001546:	0d5b      	lsrs	r3, r3, #21
 8001548:	2b01      	cmp	r3, #1
 800154a:	dc00      	bgt.n	800154e <__aeabi_dsub+0x31a>
 800154c:	e0b0      	b.n	80016b0 <__aeabi_dsub+0x47c>
 800154e:	4b14      	ldr	r3, [pc, #80]	; (80015a0 <__aeabi_dsub+0x36c>)
 8001550:	4298      	cmp	r0, r3
 8001552:	d100      	bne.n	8001556 <__aeabi_dsub+0x322>
 8001554:	e11e      	b.n	8001794 <__aeabi_dsub+0x560>
 8001556:	9b01      	ldr	r3, [sp, #4]
 8001558:	19d2      	adds	r2, r2, r7
 800155a:	1959      	adds	r1, r3, r5
 800155c:	42a9      	cmp	r1, r5
 800155e:	419b      	sbcs	r3, r3
 8001560:	425b      	negs	r3, r3
 8001562:	18d2      	adds	r2, r2, r3
 8001564:	0849      	lsrs	r1, r1, #1
 8001566:	07d5      	lsls	r5, r2, #31
 8001568:	430d      	orrs	r5, r1
 800156a:	0857      	lsrs	r7, r2, #1
 800156c:	1c04      	adds	r4, r0, #0
 800156e:	e693      	b.n	8001298 <__aeabi_dsub+0x64>
 8001570:	4b0b      	ldr	r3, [pc, #44]	; (80015a0 <__aeabi_dsub+0x36c>)
 8001572:	429c      	cmp	r4, r3
 8001574:	d000      	beq.n	8001578 <__aeabi_dsub+0x344>
 8001576:	e6d3      	b.n	8001320 <__aeabi_dsub+0xec>
 8001578:	e68e      	b.n	8001298 <__aeabi_dsub+0x64>
 800157a:	1c21      	adds	r1, r4, #0
 800157c:	1c13      	adds	r3, r2, #0
 800157e:	391f      	subs	r1, #31
 8001580:	40cb      	lsrs	r3, r1
 8001582:	1c19      	adds	r1, r3, #0
 8001584:	2f20      	cmp	r7, #32
 8001586:	d100      	bne.n	800158a <__aeabi_dsub+0x356>
 8001588:	e08e      	b.n	80016a8 <__aeabi_dsub+0x474>
 800158a:	233f      	movs	r3, #63	; 0x3f
 800158c:	1b1c      	subs	r4, r3, r4
 800158e:	40a2      	lsls	r2, r4
 8001590:	4315      	orrs	r5, r2
 8001592:	1e6a      	subs	r2, r5, #1
 8001594:	4195      	sbcs	r5, r2
 8001596:	2700      	movs	r7, #0
 8001598:	430d      	orrs	r5, r1
 800159a:	2400      	movs	r4, #0
 800159c:	e78b      	b.n	80014b6 <__aeabi_dsub+0x282>
 800159e:	46c0      	nop			; (mov r8, r8)
 80015a0:	000007ff 	.word	0x000007ff
 80015a4:	ff7fffff 	.word	0xff7fffff
 80015a8:	800fffff 	.word	0x800fffff
 80015ac:	1c33      	adds	r3, r6, #0
 80015ae:	1c10      	adds	r0, r2, #0
 80015b0:	3b20      	subs	r3, #32
 80015b2:	40d8      	lsrs	r0, r3
 80015b4:	2e20      	cmp	r6, #32
 80015b6:	d079      	beq.n	80016ac <__aeabi_dsub+0x478>
 80015b8:	2340      	movs	r3, #64	; 0x40
 80015ba:	1b9b      	subs	r3, r3, r6
 80015bc:	409a      	lsls	r2, r3
 80015be:	1c13      	adds	r3, r2, #0
 80015c0:	9a01      	ldr	r2, [sp, #4]
 80015c2:	4313      	orrs	r3, r2
 80015c4:	1e59      	subs	r1, r3, #1
 80015c6:	418b      	sbcs	r3, r1
 80015c8:	2200      	movs	r2, #0
 80015ca:	4303      	orrs	r3, r0
 80015cc:	e6c0      	b.n	8001350 <__aeabi_dsub+0x11c>
 80015ce:	2c00      	cmp	r4, #0
 80015d0:	d053      	beq.n	800167a <__aeabi_dsub+0x446>
 80015d2:	4cc7      	ldr	r4, [pc, #796]	; (80018f0 <__aeabi_dsub+0x6bc>)
 80015d4:	42a0      	cmp	r0, r4
 80015d6:	d100      	bne.n	80015da <__aeabi_dsub+0x3a6>
 80015d8:	e0b0      	b.n	800173c <__aeabi_dsub+0x508>
 80015da:	2480      	movs	r4, #128	; 0x80
 80015dc:	4271      	negs	r1, r6
 80015de:	4689      	mov	r9, r1
 80015e0:	0424      	lsls	r4, r4, #16
 80015e2:	4327      	orrs	r7, r4
 80015e4:	4649      	mov	r1, r9
 80015e6:	2938      	cmp	r1, #56	; 0x38
 80015e8:	dd00      	ble.n	80015ec <__aeabi_dsub+0x3b8>
 80015ea:	e0cd      	b.n	8001788 <__aeabi_dsub+0x554>
 80015ec:	291f      	cmp	r1, #31
 80015ee:	dd00      	ble.n	80015f2 <__aeabi_dsub+0x3be>
 80015f0:	e159      	b.n	80018a6 <__aeabi_dsub+0x672>
 80015f2:	2420      	movs	r4, #32
 80015f4:	1c3e      	adds	r6, r7, #0
 80015f6:	1a61      	subs	r1, r4, r1
 80015f8:	408e      	lsls	r6, r1
 80015fa:	468a      	mov	sl, r1
 80015fc:	46b0      	mov	r8, r6
 80015fe:	4649      	mov	r1, r9
 8001600:	1c2e      	adds	r6, r5, #0
 8001602:	40ce      	lsrs	r6, r1
 8001604:	4651      	mov	r1, sl
 8001606:	46b4      	mov	ip, r6
 8001608:	408d      	lsls	r5, r1
 800160a:	4664      	mov	r4, ip
 800160c:	4646      	mov	r6, r8
 800160e:	4649      	mov	r1, r9
 8001610:	4326      	orrs	r6, r4
 8001612:	1e6c      	subs	r4, r5, #1
 8001614:	41a5      	sbcs	r5, r4
 8001616:	40cf      	lsrs	r7, r1
 8001618:	4335      	orrs	r5, r6
 800161a:	9901      	ldr	r1, [sp, #4]
 800161c:	1bd7      	subs	r7, r2, r7
 800161e:	468c      	mov	ip, r1
 8001620:	1b4d      	subs	r5, r1, r5
 8001622:	45ac      	cmp	ip, r5
 8001624:	4192      	sbcs	r2, r2
 8001626:	4252      	negs	r2, r2
 8001628:	1abf      	subs	r7, r7, r2
 800162a:	1c04      	adds	r4, r0, #0
 800162c:	4698      	mov	r8, r3
 800162e:	e696      	b.n	800135e <__aeabi_dsub+0x12a>
 8001630:	4663      	mov	r3, ip
 8001632:	4665      	mov	r5, ip
 8001634:	4333      	orrs	r3, r6
 8001636:	d000      	beq.n	800163a <__aeabi_dsub+0x406>
 8001638:	e696      	b.n	8001368 <__aeabi_dsub+0x134>
 800163a:	2600      	movs	r6, #0
 800163c:	2700      	movs	r7, #0
 800163e:	2400      	movs	r4, #0
 8001640:	2500      	movs	r5, #0
 8001642:	e6c4      	b.n	80013ce <__aeabi_dsub+0x19a>
 8001644:	2b1f      	cmp	r3, #31
 8001646:	dc61      	bgt.n	800170c <__aeabi_dsub+0x4d8>
 8001648:	2020      	movs	r0, #32
 800164a:	1ac3      	subs	r3, r0, r3
 800164c:	469b      	mov	fp, r3
 800164e:	1c13      	adds	r3, r2, #0
 8001650:	4659      	mov	r1, fp
 8001652:	408b      	lsls	r3, r1
 8001654:	4651      	mov	r1, sl
 8001656:	4699      	mov	r9, r3
 8001658:	9b01      	ldr	r3, [sp, #4]
 800165a:	40cb      	lsrs	r3, r1
 800165c:	469c      	mov	ip, r3
 800165e:	464b      	mov	r3, r9
 8001660:	4660      	mov	r0, ip
 8001662:	4303      	orrs	r3, r0
 8001664:	469c      	mov	ip, r3
 8001666:	465b      	mov	r3, fp
 8001668:	9901      	ldr	r1, [sp, #4]
 800166a:	4099      	lsls	r1, r3
 800166c:	4663      	mov	r3, ip
 800166e:	1e48      	subs	r0, r1, #1
 8001670:	4181      	sbcs	r1, r0
 8001672:	4319      	orrs	r1, r3
 8001674:	4653      	mov	r3, sl
 8001676:	40da      	lsrs	r2, r3
 8001678:	e6cd      	b.n	8001416 <__aeabi_dsub+0x1e2>
 800167a:	1c3c      	adds	r4, r7, #0
 800167c:	432c      	orrs	r4, r5
 800167e:	d05d      	beq.n	800173c <__aeabi_dsub+0x508>
 8001680:	43f1      	mvns	r1, r6
 8001682:	4689      	mov	r9, r1
 8001684:	2900      	cmp	r1, #0
 8001686:	d155      	bne.n	8001734 <__aeabi_dsub+0x500>
 8001688:	9901      	ldr	r1, [sp, #4]
 800168a:	1bd2      	subs	r2, r2, r7
 800168c:	468c      	mov	ip, r1
 800168e:	1b4d      	subs	r5, r1, r5
 8001690:	45ac      	cmp	ip, r5
 8001692:	4189      	sbcs	r1, r1
 8001694:	4249      	negs	r1, r1
 8001696:	1a57      	subs	r7, r2, r1
 8001698:	1c04      	adds	r4, r0, #0
 800169a:	4698      	mov	r8, r3
 800169c:	e65f      	b.n	800135e <__aeabi_dsub+0x12a>
 800169e:	4894      	ldr	r0, [pc, #592]	; (80018f0 <__aeabi_dsub+0x6bc>)
 80016a0:	4284      	cmp	r4, r0
 80016a2:	d000      	beq.n	80016a6 <__aeabi_dsub+0x472>
 80016a4:	e6ad      	b.n	8001402 <__aeabi_dsub+0x1ce>
 80016a6:	e5f7      	b.n	8001298 <__aeabi_dsub+0x64>
 80016a8:	2200      	movs	r2, #0
 80016aa:	e771      	b.n	8001590 <__aeabi_dsub+0x35c>
 80016ac:	2300      	movs	r3, #0
 80016ae:	e787      	b.n	80015c0 <__aeabi_dsub+0x38c>
 80016b0:	1c3b      	adds	r3, r7, #0
 80016b2:	432b      	orrs	r3, r5
 80016b4:	2c00      	cmp	r4, #0
 80016b6:	d000      	beq.n	80016ba <__aeabi_dsub+0x486>
 80016b8:	e0da      	b.n	8001870 <__aeabi_dsub+0x63c>
 80016ba:	2b00      	cmp	r3, #0
 80016bc:	d100      	bne.n	80016c0 <__aeabi_dsub+0x48c>
 80016be:	e113      	b.n	80018e8 <__aeabi_dsub+0x6b4>
 80016c0:	1c13      	adds	r3, r2, #0
 80016c2:	9901      	ldr	r1, [sp, #4]
 80016c4:	430b      	orrs	r3, r1
 80016c6:	d100      	bne.n	80016ca <__aeabi_dsub+0x496>
 80016c8:	e5e6      	b.n	8001298 <__aeabi_dsub+0x64>
 80016ca:	1949      	adds	r1, r1, r5
 80016cc:	42a9      	cmp	r1, r5
 80016ce:	419b      	sbcs	r3, r3
 80016d0:	19d2      	adds	r2, r2, r7
 80016d2:	425b      	negs	r3, r3
 80016d4:	18d7      	adds	r7, r2, r3
 80016d6:	023b      	lsls	r3, r7, #8
 80016d8:	d400      	bmi.n	80016dc <__aeabi_dsub+0x4a8>
 80016da:	e121      	b.n	8001920 <__aeabi_dsub+0x6ec>
 80016dc:	4b85      	ldr	r3, [pc, #532]	; (80018f4 <__aeabi_dsub+0x6c0>)
 80016de:	1c0d      	adds	r5, r1, #0
 80016e0:	401f      	ands	r7, r3
 80016e2:	1c04      	adds	r4, r0, #0
 80016e4:	e5d8      	b.n	8001298 <__aeabi_dsub+0x64>
 80016e6:	1c38      	adds	r0, r7, #0
 80016e8:	4328      	orrs	r0, r5
 80016ea:	2c00      	cmp	r4, #0
 80016ec:	d140      	bne.n	8001770 <__aeabi_dsub+0x53c>
 80016ee:	2800      	cmp	r0, #0
 80016f0:	d000      	beq.n	80016f4 <__aeabi_dsub+0x4c0>
 80016f2:	e083      	b.n	80017fc <__aeabi_dsub+0x5c8>
 80016f4:	1c10      	adds	r0, r2, #0
 80016f6:	9901      	ldr	r1, [sp, #4]
 80016f8:	4308      	orrs	r0, r1
 80016fa:	d003      	beq.n	8001704 <__aeabi_dsub+0x4d0>
 80016fc:	1c17      	adds	r7, r2, #0
 80016fe:	1c0d      	adds	r5, r1, #0
 8001700:	4698      	mov	r8, r3
 8001702:	e5c9      	b.n	8001298 <__aeabi_dsub+0x64>
 8001704:	2600      	movs	r6, #0
 8001706:	2700      	movs	r7, #0
 8001708:	2500      	movs	r5, #0
 800170a:	e660      	b.n	80013ce <__aeabi_dsub+0x19a>
 800170c:	4650      	mov	r0, sl
 800170e:	1c13      	adds	r3, r2, #0
 8001710:	3820      	subs	r0, #32
 8001712:	40c3      	lsrs	r3, r0
 8001714:	1c18      	adds	r0, r3, #0
 8001716:	4653      	mov	r3, sl
 8001718:	2b20      	cmp	r3, #32
 800171a:	d100      	bne.n	800171e <__aeabi_dsub+0x4ea>
 800171c:	e0c1      	b.n	80018a2 <__aeabi_dsub+0x66e>
 800171e:	2340      	movs	r3, #64	; 0x40
 8001720:	4651      	mov	r1, sl
 8001722:	1a5b      	subs	r3, r3, r1
 8001724:	409a      	lsls	r2, r3
 8001726:	9901      	ldr	r1, [sp, #4]
 8001728:	4311      	orrs	r1, r2
 800172a:	1e4a      	subs	r2, r1, #1
 800172c:	4191      	sbcs	r1, r2
 800172e:	2200      	movs	r2, #0
 8001730:	4301      	orrs	r1, r0
 8001732:	e670      	b.n	8001416 <__aeabi_dsub+0x1e2>
 8001734:	4c6e      	ldr	r4, [pc, #440]	; (80018f0 <__aeabi_dsub+0x6bc>)
 8001736:	42a0      	cmp	r0, r4
 8001738:	d000      	beq.n	800173c <__aeabi_dsub+0x508>
 800173a:	e753      	b.n	80015e4 <__aeabi_dsub+0x3b0>
 800173c:	1c17      	adds	r7, r2, #0
 800173e:	9d01      	ldr	r5, [sp, #4]
 8001740:	1c04      	adds	r4, r0, #0
 8001742:	4698      	mov	r8, r3
 8001744:	e5a8      	b.n	8001298 <__aeabi_dsub+0x64>
 8001746:	2c00      	cmp	r4, #0
 8001748:	d128      	bne.n	800179c <__aeabi_dsub+0x568>
 800174a:	1c3c      	adds	r4, r7, #0
 800174c:	432c      	orrs	r4, r5
 800174e:	d100      	bne.n	8001752 <__aeabi_dsub+0x51e>
 8001750:	e08a      	b.n	8001868 <__aeabi_dsub+0x634>
 8001752:	43db      	mvns	r3, r3
 8001754:	469a      	mov	sl, r3
 8001756:	2b00      	cmp	r3, #0
 8001758:	d000      	beq.n	800175c <__aeabi_dsub+0x528>
 800175a:	e082      	b.n	8001862 <__aeabi_dsub+0x62e>
 800175c:	9b01      	ldr	r3, [sp, #4]
 800175e:	19d2      	adds	r2, r2, r7
 8001760:	469c      	mov	ip, r3
 8001762:	4465      	add	r5, ip
 8001764:	429d      	cmp	r5, r3
 8001766:	4189      	sbcs	r1, r1
 8001768:	4249      	negs	r1, r1
 800176a:	1857      	adds	r7, r2, r1
 800176c:	1c04      	adds	r4, r0, #0
 800176e:	e659      	b.n	8001424 <__aeabi_dsub+0x1f0>
 8001770:	2800      	cmp	r0, #0
 8001772:	d15b      	bne.n	800182c <__aeabi_dsub+0x5f8>
 8001774:	1c10      	adds	r0, r2, #0
 8001776:	9901      	ldr	r1, [sp, #4]
 8001778:	4308      	orrs	r0, r1
 800177a:	d100      	bne.n	800177e <__aeabi_dsub+0x54a>
 800177c:	e0a4      	b.n	80018c8 <__aeabi_dsub+0x694>
 800177e:	1c17      	adds	r7, r2, #0
 8001780:	1c0d      	adds	r5, r1, #0
 8001782:	4698      	mov	r8, r3
 8001784:	4c5a      	ldr	r4, [pc, #360]	; (80018f0 <__aeabi_dsub+0x6bc>)
 8001786:	e587      	b.n	8001298 <__aeabi_dsub+0x64>
 8001788:	433d      	orrs	r5, r7
 800178a:	1e6f      	subs	r7, r5, #1
 800178c:	41bd      	sbcs	r5, r7
 800178e:	2700      	movs	r7, #0
 8001790:	b2ed      	uxtb	r5, r5
 8001792:	e742      	b.n	800161a <__aeabi_dsub+0x3e6>
 8001794:	1c04      	adds	r4, r0, #0
 8001796:	2700      	movs	r7, #0
 8001798:	2500      	movs	r5, #0
 800179a:	e618      	b.n	80013ce <__aeabi_dsub+0x19a>
 800179c:	4c54      	ldr	r4, [pc, #336]	; (80018f0 <__aeabi_dsub+0x6bc>)
 800179e:	42a0      	cmp	r0, r4
 80017a0:	d062      	beq.n	8001868 <__aeabi_dsub+0x634>
 80017a2:	4653      	mov	r3, sl
 80017a4:	2480      	movs	r4, #128	; 0x80
 80017a6:	425b      	negs	r3, r3
 80017a8:	469a      	mov	sl, r3
 80017aa:	0424      	lsls	r4, r4, #16
 80017ac:	4327      	orrs	r7, r4
 80017ae:	4653      	mov	r3, sl
 80017b0:	2b38      	cmp	r3, #56	; 0x38
 80017b2:	dd00      	ble.n	80017b6 <__aeabi_dsub+0x582>
 80017b4:	e08e      	b.n	80018d4 <__aeabi_dsub+0x6a0>
 80017b6:	2b1f      	cmp	r3, #31
 80017b8:	dd00      	ble.n	80017bc <__aeabi_dsub+0x588>
 80017ba:	e09d      	b.n	80018f8 <__aeabi_dsub+0x6c4>
 80017bc:	2420      	movs	r4, #32
 80017be:	1ae3      	subs	r3, r4, r3
 80017c0:	469b      	mov	fp, r3
 80017c2:	1c3b      	adds	r3, r7, #0
 80017c4:	4659      	mov	r1, fp
 80017c6:	408b      	lsls	r3, r1
 80017c8:	4651      	mov	r1, sl
 80017ca:	4699      	mov	r9, r3
 80017cc:	1c2b      	adds	r3, r5, #0
 80017ce:	40cb      	lsrs	r3, r1
 80017d0:	469c      	mov	ip, r3
 80017d2:	464b      	mov	r3, r9
 80017d4:	4664      	mov	r4, ip
 80017d6:	4323      	orrs	r3, r4
 80017d8:	469c      	mov	ip, r3
 80017da:	465b      	mov	r3, fp
 80017dc:	409d      	lsls	r5, r3
 80017de:	4663      	mov	r3, ip
 80017e0:	1e6c      	subs	r4, r5, #1
 80017e2:	41a5      	sbcs	r5, r4
 80017e4:	40cf      	lsrs	r7, r1
 80017e6:	431d      	orrs	r5, r3
 80017e8:	9b01      	ldr	r3, [sp, #4]
 80017ea:	18bf      	adds	r7, r7, r2
 80017ec:	469c      	mov	ip, r3
 80017ee:	4465      	add	r5, ip
 80017f0:	429d      	cmp	r5, r3
 80017f2:	4192      	sbcs	r2, r2
 80017f4:	4252      	negs	r2, r2
 80017f6:	18bf      	adds	r7, r7, r2
 80017f8:	1c04      	adds	r4, r0, #0
 80017fa:	e613      	b.n	8001424 <__aeabi_dsub+0x1f0>
 80017fc:	1c10      	adds	r0, r2, #0
 80017fe:	9901      	ldr	r1, [sp, #4]
 8001800:	4308      	orrs	r0, r1
 8001802:	d100      	bne.n	8001806 <__aeabi_dsub+0x5d2>
 8001804:	e548      	b.n	8001298 <__aeabi_dsub+0x64>
 8001806:	1a68      	subs	r0, r5, r1
 8001808:	4684      	mov	ip, r0
 800180a:	4285      	cmp	r5, r0
 800180c:	4180      	sbcs	r0, r0
 800180e:	1abe      	subs	r6, r7, r2
 8001810:	4240      	negs	r0, r0
 8001812:	1a30      	subs	r0, r6, r0
 8001814:	0206      	lsls	r6, r0, #8
 8001816:	d400      	bmi.n	800181a <__aeabi_dsub+0x5e6>
 8001818:	e647      	b.n	80014aa <__aeabi_dsub+0x276>
 800181a:	468c      	mov	ip, r1
 800181c:	1b4d      	subs	r5, r1, r5
 800181e:	45ac      	cmp	ip, r5
 8001820:	4189      	sbcs	r1, r1
 8001822:	1bd2      	subs	r2, r2, r7
 8001824:	4249      	negs	r1, r1
 8001826:	1a57      	subs	r7, r2, r1
 8001828:	4698      	mov	r8, r3
 800182a:	e535      	b.n	8001298 <__aeabi_dsub+0x64>
 800182c:	1c10      	adds	r0, r2, #0
 800182e:	9901      	ldr	r1, [sp, #4]
 8001830:	4308      	orrs	r0, r1
 8001832:	d034      	beq.n	800189e <__aeabi_dsub+0x66a>
 8001834:	2480      	movs	r4, #128	; 0x80
 8001836:	0778      	lsls	r0, r7, #29
 8001838:	08ed      	lsrs	r5, r5, #3
 800183a:	08ff      	lsrs	r7, r7, #3
 800183c:	0324      	lsls	r4, r4, #12
 800183e:	4328      	orrs	r0, r5
 8001840:	4227      	tst	r7, r4
 8001842:	d008      	beq.n	8001856 <__aeabi_dsub+0x622>
 8001844:	08d6      	lsrs	r6, r2, #3
 8001846:	4226      	tst	r6, r4
 8001848:	d105      	bne.n	8001856 <__aeabi_dsub+0x622>
 800184a:	08c9      	lsrs	r1, r1, #3
 800184c:	0752      	lsls	r2, r2, #29
 800184e:	430a      	orrs	r2, r1
 8001850:	1c10      	adds	r0, r2, #0
 8001852:	1c37      	adds	r7, r6, #0
 8001854:	4698      	mov	r8, r3
 8001856:	00ff      	lsls	r7, r7, #3
 8001858:	0f42      	lsrs	r2, r0, #29
 800185a:	4317      	orrs	r7, r2
 800185c:	00c5      	lsls	r5, r0, #3
 800185e:	4c24      	ldr	r4, [pc, #144]	; (80018f0 <__aeabi_dsub+0x6bc>)
 8001860:	e51a      	b.n	8001298 <__aeabi_dsub+0x64>
 8001862:	4c23      	ldr	r4, [pc, #140]	; (80018f0 <__aeabi_dsub+0x6bc>)
 8001864:	42a0      	cmp	r0, r4
 8001866:	d1a2      	bne.n	80017ae <__aeabi_dsub+0x57a>
 8001868:	1c17      	adds	r7, r2, #0
 800186a:	9d01      	ldr	r5, [sp, #4]
 800186c:	1c04      	adds	r4, r0, #0
 800186e:	e513      	b.n	8001298 <__aeabi_dsub+0x64>
 8001870:	2b00      	cmp	r3, #0
 8001872:	d035      	beq.n	80018e0 <__aeabi_dsub+0x6ac>
 8001874:	1c13      	adds	r3, r2, #0
 8001876:	9901      	ldr	r1, [sp, #4]
 8001878:	430b      	orrs	r3, r1
 800187a:	d010      	beq.n	800189e <__aeabi_dsub+0x66a>
 800187c:	2480      	movs	r4, #128	; 0x80
 800187e:	0778      	lsls	r0, r7, #29
 8001880:	08ed      	lsrs	r5, r5, #3
 8001882:	08ff      	lsrs	r7, r7, #3
 8001884:	0324      	lsls	r4, r4, #12
 8001886:	4328      	orrs	r0, r5
 8001888:	4227      	tst	r7, r4
 800188a:	d0e4      	beq.n	8001856 <__aeabi_dsub+0x622>
 800188c:	08d3      	lsrs	r3, r2, #3
 800188e:	4223      	tst	r3, r4
 8001890:	d1e1      	bne.n	8001856 <__aeabi_dsub+0x622>
 8001892:	08c9      	lsrs	r1, r1, #3
 8001894:	0752      	lsls	r2, r2, #29
 8001896:	430a      	orrs	r2, r1
 8001898:	1c10      	adds	r0, r2, #0
 800189a:	1c1f      	adds	r7, r3, #0
 800189c:	e7db      	b.n	8001856 <__aeabi_dsub+0x622>
 800189e:	4c14      	ldr	r4, [pc, #80]	; (80018f0 <__aeabi_dsub+0x6bc>)
 80018a0:	e4fa      	b.n	8001298 <__aeabi_dsub+0x64>
 80018a2:	2200      	movs	r2, #0
 80018a4:	e73f      	b.n	8001726 <__aeabi_dsub+0x4f2>
 80018a6:	464c      	mov	r4, r9
 80018a8:	1c3e      	adds	r6, r7, #0
 80018aa:	3c20      	subs	r4, #32
 80018ac:	40e6      	lsrs	r6, r4
 80018ae:	4649      	mov	r1, r9
 80018b0:	1c34      	adds	r4, r6, #0
 80018b2:	2920      	cmp	r1, #32
 80018b4:	d032      	beq.n	800191c <__aeabi_dsub+0x6e8>
 80018b6:	2640      	movs	r6, #64	; 0x40
 80018b8:	1a76      	subs	r6, r6, r1
 80018ba:	40b7      	lsls	r7, r6
 80018bc:	433d      	orrs	r5, r7
 80018be:	1e6f      	subs	r7, r5, #1
 80018c0:	41bd      	sbcs	r5, r7
 80018c2:	2700      	movs	r7, #0
 80018c4:	4325      	orrs	r5, r4
 80018c6:	e6a8      	b.n	800161a <__aeabi_dsub+0x3e6>
 80018c8:	2780      	movs	r7, #128	; 0x80
 80018ca:	2600      	movs	r6, #0
 80018cc:	03ff      	lsls	r7, r7, #15
 80018ce:	4c08      	ldr	r4, [pc, #32]	; (80018f0 <__aeabi_dsub+0x6bc>)
 80018d0:	2500      	movs	r5, #0
 80018d2:	e57c      	b.n	80013ce <__aeabi_dsub+0x19a>
 80018d4:	433d      	orrs	r5, r7
 80018d6:	1e6f      	subs	r7, r5, #1
 80018d8:	41bd      	sbcs	r5, r7
 80018da:	2700      	movs	r7, #0
 80018dc:	b2ed      	uxtb	r5, r5
 80018de:	e783      	b.n	80017e8 <__aeabi_dsub+0x5b4>
 80018e0:	1c17      	adds	r7, r2, #0
 80018e2:	9d01      	ldr	r5, [sp, #4]
 80018e4:	4c02      	ldr	r4, [pc, #8]	; (80018f0 <__aeabi_dsub+0x6bc>)
 80018e6:	e4d7      	b.n	8001298 <__aeabi_dsub+0x64>
 80018e8:	1c17      	adds	r7, r2, #0
 80018ea:	9d01      	ldr	r5, [sp, #4]
 80018ec:	e4d4      	b.n	8001298 <__aeabi_dsub+0x64>
 80018ee:	46c0      	nop			; (mov r8, r8)
 80018f0:	000007ff 	.word	0x000007ff
 80018f4:	ff7fffff 	.word	0xff7fffff
 80018f8:	4654      	mov	r4, sl
 80018fa:	1c3b      	adds	r3, r7, #0
 80018fc:	3c20      	subs	r4, #32
 80018fe:	40e3      	lsrs	r3, r4
 8001900:	1c1c      	adds	r4, r3, #0
 8001902:	4653      	mov	r3, sl
 8001904:	2b20      	cmp	r3, #32
 8001906:	d00d      	beq.n	8001924 <__aeabi_dsub+0x6f0>
 8001908:	2340      	movs	r3, #64	; 0x40
 800190a:	4651      	mov	r1, sl
 800190c:	1a5b      	subs	r3, r3, r1
 800190e:	409f      	lsls	r7, r3
 8001910:	433d      	orrs	r5, r7
 8001912:	1e6f      	subs	r7, r5, #1
 8001914:	41bd      	sbcs	r5, r7
 8001916:	2700      	movs	r7, #0
 8001918:	4325      	orrs	r5, r4
 800191a:	e765      	b.n	80017e8 <__aeabi_dsub+0x5b4>
 800191c:	2700      	movs	r7, #0
 800191e:	e7cd      	b.n	80018bc <__aeabi_dsub+0x688>
 8001920:	1c0d      	adds	r5, r1, #0
 8001922:	e5c8      	b.n	80014b6 <__aeabi_dsub+0x282>
 8001924:	2700      	movs	r7, #0
 8001926:	e7f3      	b.n	8001910 <__aeabi_dsub+0x6dc>

08001928 <__aeabi_i2d>:
 8001928:	b538      	push	{r3, r4, r5, lr}
 800192a:	1e04      	subs	r4, r0, #0
 800192c:	d016      	beq.n	800195c <__aeabi_i2d+0x34>
 800192e:	0fc5      	lsrs	r5, r0, #31
 8001930:	d000      	beq.n	8001934 <__aeabi_i2d+0xc>
 8001932:	4244      	negs	r4, r0
 8001934:	1c20      	adds	r0, r4, #0
 8001936:	f000 f9a9 	bl	8001c8c <__clzsi2>
 800193a:	4b17      	ldr	r3, [pc, #92]	; (8001998 <__aeabi_i2d+0x70>)
 800193c:	1a1b      	subs	r3, r3, r0
 800193e:	280a      	cmp	r0, #10
 8001940:	dc21      	bgt.n	8001986 <__aeabi_i2d+0x5e>
 8001942:	1c02      	adds	r2, r0, #0
 8001944:	1c21      	adds	r1, r4, #0
 8001946:	3215      	adds	r2, #21
 8001948:	4091      	lsls	r1, r2
 800194a:	1c0a      	adds	r2, r1, #0
 800194c:	210b      	movs	r1, #11
 800194e:	1a08      	subs	r0, r1, r0
 8001950:	40c4      	lsrs	r4, r0
 8001952:	055b      	lsls	r3, r3, #21
 8001954:	0324      	lsls	r4, r4, #12
 8001956:	0b24      	lsrs	r4, r4, #12
 8001958:	0d5b      	lsrs	r3, r3, #21
 800195a:	e003      	b.n	8001964 <__aeabi_i2d+0x3c>
 800195c:	2500      	movs	r5, #0
 800195e:	2300      	movs	r3, #0
 8001960:	2400      	movs	r4, #0
 8001962:	2200      	movs	r2, #0
 8001964:	2100      	movs	r1, #0
 8001966:	1c10      	adds	r0, r2, #0
 8001968:	0324      	lsls	r4, r4, #12
 800196a:	0d0a      	lsrs	r2, r1, #20
 800196c:	0512      	lsls	r2, r2, #20
 800196e:	0b24      	lsrs	r4, r4, #12
 8001970:	4314      	orrs	r4, r2
 8001972:	4a0a      	ldr	r2, [pc, #40]	; (800199c <__aeabi_i2d+0x74>)
 8001974:	051b      	lsls	r3, r3, #20
 8001976:	4014      	ands	r4, r2
 8001978:	431c      	orrs	r4, r3
 800197a:	0064      	lsls	r4, r4, #1
 800197c:	07ed      	lsls	r5, r5, #31
 800197e:	0864      	lsrs	r4, r4, #1
 8001980:	432c      	orrs	r4, r5
 8001982:	1c21      	adds	r1, r4, #0
 8001984:	bd38      	pop	{r3, r4, r5, pc}
 8001986:	380b      	subs	r0, #11
 8001988:	4084      	lsls	r4, r0
 800198a:	055b      	lsls	r3, r3, #21
 800198c:	0324      	lsls	r4, r4, #12
 800198e:	0b24      	lsrs	r4, r4, #12
 8001990:	0d5b      	lsrs	r3, r3, #21
 8001992:	2200      	movs	r2, #0
 8001994:	e7e6      	b.n	8001964 <__aeabi_i2d+0x3c>
 8001996:	46c0      	nop			; (mov r8, r8)
 8001998:	0000041e 	.word	0x0000041e
 800199c:	800fffff 	.word	0x800fffff

080019a0 <__aeabi_f2d>:
 80019a0:	0042      	lsls	r2, r0, #1
 80019a2:	0e12      	lsrs	r2, r2, #24
 80019a4:	1c51      	adds	r1, r2, #1
 80019a6:	b538      	push	{r3, r4, r5, lr}
 80019a8:	b2c9      	uxtb	r1, r1
 80019aa:	0243      	lsls	r3, r0, #9
 80019ac:	0a5d      	lsrs	r5, r3, #9
 80019ae:	0fc4      	lsrs	r4, r0, #31
 80019b0:	2901      	cmp	r1, #1
 80019b2:	dd15      	ble.n	80019e0 <__aeabi_f2d+0x40>
 80019b4:	21e0      	movs	r1, #224	; 0xe0
 80019b6:	0089      	lsls	r1, r1, #2
 80019b8:	468c      	mov	ip, r1
 80019ba:	076d      	lsls	r5, r5, #29
 80019bc:	0b1b      	lsrs	r3, r3, #12
 80019be:	4462      	add	r2, ip
 80019c0:	2100      	movs	r1, #0
 80019c2:	1c28      	adds	r0, r5, #0
 80019c4:	0d0d      	lsrs	r5, r1, #20
 80019c6:	052d      	lsls	r5, r5, #20
 80019c8:	432b      	orrs	r3, r5
 80019ca:	4d1c      	ldr	r5, [pc, #112]	; (8001a3c <__aeabi_f2d+0x9c>)
 80019cc:	0552      	lsls	r2, r2, #21
 80019ce:	402b      	ands	r3, r5
 80019d0:	0852      	lsrs	r2, r2, #1
 80019d2:	4313      	orrs	r3, r2
 80019d4:	005b      	lsls	r3, r3, #1
 80019d6:	07e4      	lsls	r4, r4, #31
 80019d8:	085b      	lsrs	r3, r3, #1
 80019da:	4323      	orrs	r3, r4
 80019dc:	1c19      	adds	r1, r3, #0
 80019de:	bd38      	pop	{r3, r4, r5, pc}
 80019e0:	2a00      	cmp	r2, #0
 80019e2:	d115      	bne.n	8001a10 <__aeabi_f2d+0x70>
 80019e4:	2d00      	cmp	r5, #0
 80019e6:	d01f      	beq.n	8001a28 <__aeabi_f2d+0x88>
 80019e8:	1c28      	adds	r0, r5, #0
 80019ea:	f000 f94f 	bl	8001c8c <__clzsi2>
 80019ee:	280a      	cmp	r0, #10
 80019f0:	dc1d      	bgt.n	8001a2e <__aeabi_f2d+0x8e>
 80019f2:	230b      	movs	r3, #11
 80019f4:	1c2a      	adds	r2, r5, #0
 80019f6:	1a1b      	subs	r3, r3, r0
 80019f8:	40da      	lsrs	r2, r3
 80019fa:	1c13      	adds	r3, r2, #0
 80019fc:	1c02      	adds	r2, r0, #0
 80019fe:	3215      	adds	r2, #21
 8001a00:	4095      	lsls	r5, r2
 8001a02:	4a0f      	ldr	r2, [pc, #60]	; (8001a40 <__aeabi_f2d+0xa0>)
 8001a04:	031b      	lsls	r3, r3, #12
 8001a06:	1a12      	subs	r2, r2, r0
 8001a08:	0552      	lsls	r2, r2, #21
 8001a0a:	0b1b      	lsrs	r3, r3, #12
 8001a0c:	0d52      	lsrs	r2, r2, #21
 8001a0e:	e7d7      	b.n	80019c0 <__aeabi_f2d+0x20>
 8001a10:	2d00      	cmp	r5, #0
 8001a12:	d006      	beq.n	8001a22 <__aeabi_f2d+0x82>
 8001a14:	2280      	movs	r2, #128	; 0x80
 8001a16:	0b1b      	lsrs	r3, r3, #12
 8001a18:	0312      	lsls	r2, r2, #12
 8001a1a:	4313      	orrs	r3, r2
 8001a1c:	076d      	lsls	r5, r5, #29
 8001a1e:	4a09      	ldr	r2, [pc, #36]	; (8001a44 <__aeabi_f2d+0xa4>)
 8001a20:	e7ce      	b.n	80019c0 <__aeabi_f2d+0x20>
 8001a22:	4a08      	ldr	r2, [pc, #32]	; (8001a44 <__aeabi_f2d+0xa4>)
 8001a24:	2300      	movs	r3, #0
 8001a26:	e7cb      	b.n	80019c0 <__aeabi_f2d+0x20>
 8001a28:	2200      	movs	r2, #0
 8001a2a:	2300      	movs	r3, #0
 8001a2c:	e7c8      	b.n	80019c0 <__aeabi_f2d+0x20>
 8001a2e:	1c03      	adds	r3, r0, #0
 8001a30:	3b0b      	subs	r3, #11
 8001a32:	409d      	lsls	r5, r3
 8001a34:	1c2b      	adds	r3, r5, #0
 8001a36:	2500      	movs	r5, #0
 8001a38:	e7e3      	b.n	8001a02 <__aeabi_f2d+0x62>
 8001a3a:	46c0      	nop			; (mov r8, r8)
 8001a3c:	800fffff 	.word	0x800fffff
 8001a40:	00000389 	.word	0x00000389
 8001a44:	000007ff 	.word	0x000007ff

08001a48 <__aeabi_d2f>:
 8001a48:	b570      	push	{r4, r5, r6, lr}
 8001a4a:	030b      	lsls	r3, r1, #12
 8001a4c:	004d      	lsls	r5, r1, #1
 8001a4e:	0f44      	lsrs	r4, r0, #29
 8001a50:	0d6d      	lsrs	r5, r5, #21
 8001a52:	0a5b      	lsrs	r3, r3, #9
 8001a54:	4323      	orrs	r3, r4
 8001a56:	1c6c      	adds	r4, r5, #1
 8001a58:	0564      	lsls	r4, r4, #21
 8001a5a:	0fc9      	lsrs	r1, r1, #31
 8001a5c:	00c2      	lsls	r2, r0, #3
 8001a5e:	0d64      	lsrs	r4, r4, #21
 8001a60:	2c01      	cmp	r4, #1
 8001a62:	dd2a      	ble.n	8001aba <__aeabi_d2f+0x72>
 8001a64:	4c3b      	ldr	r4, [pc, #236]	; (8001b54 <__aeabi_d2f+0x10c>)
 8001a66:	192c      	adds	r4, r5, r4
 8001a68:	2cfe      	cmp	r4, #254	; 0xfe
 8001a6a:	dc1a      	bgt.n	8001aa2 <__aeabi_d2f+0x5a>
 8001a6c:	2c00      	cmp	r4, #0
 8001a6e:	dd35      	ble.n	8001adc <__aeabi_d2f+0x94>
 8001a70:	0180      	lsls	r0, r0, #6
 8001a72:	1e45      	subs	r5, r0, #1
 8001a74:	41a8      	sbcs	r0, r5
 8001a76:	00db      	lsls	r3, r3, #3
 8001a78:	4303      	orrs	r3, r0
 8001a7a:	0f52      	lsrs	r2, r2, #29
 8001a7c:	4313      	orrs	r3, r2
 8001a7e:	075a      	lsls	r2, r3, #29
 8001a80:	d004      	beq.n	8001a8c <__aeabi_d2f+0x44>
 8001a82:	220f      	movs	r2, #15
 8001a84:	401a      	ands	r2, r3
 8001a86:	2a04      	cmp	r2, #4
 8001a88:	d000      	beq.n	8001a8c <__aeabi_d2f+0x44>
 8001a8a:	3304      	adds	r3, #4
 8001a8c:	2280      	movs	r2, #128	; 0x80
 8001a8e:	04d2      	lsls	r2, r2, #19
 8001a90:	401a      	ands	r2, r3
 8001a92:	d027      	beq.n	8001ae4 <__aeabi_d2f+0x9c>
 8001a94:	3401      	adds	r4, #1
 8001a96:	2cff      	cmp	r4, #255	; 0xff
 8001a98:	d003      	beq.n	8001aa2 <__aeabi_d2f+0x5a>
 8001a9a:	019b      	lsls	r3, r3, #6
 8001a9c:	0a5b      	lsrs	r3, r3, #9
 8001a9e:	b2e4      	uxtb	r4, r4
 8001aa0:	e001      	b.n	8001aa6 <__aeabi_d2f+0x5e>
 8001aa2:	24ff      	movs	r4, #255	; 0xff
 8001aa4:	2300      	movs	r3, #0
 8001aa6:	025b      	lsls	r3, r3, #9
 8001aa8:	05e4      	lsls	r4, r4, #23
 8001aaa:	0a5b      	lsrs	r3, r3, #9
 8001aac:	4323      	orrs	r3, r4
 8001aae:	005b      	lsls	r3, r3, #1
 8001ab0:	07c9      	lsls	r1, r1, #31
 8001ab2:	085b      	lsrs	r3, r3, #1
 8001ab4:	430b      	orrs	r3, r1
 8001ab6:	1c18      	adds	r0, r3, #0
 8001ab8:	bd70      	pop	{r4, r5, r6, pc}
 8001aba:	2d00      	cmp	r5, #0
 8001abc:	d106      	bne.n	8001acc <__aeabi_d2f+0x84>
 8001abe:	4313      	orrs	r3, r2
 8001ac0:	d10e      	bne.n	8001ae0 <__aeabi_d2f+0x98>
 8001ac2:	2400      	movs	r4, #0
 8001ac4:	025b      	lsls	r3, r3, #9
 8001ac6:	0a5b      	lsrs	r3, r3, #9
 8001ac8:	b2e4      	uxtb	r4, r4
 8001aca:	e7ec      	b.n	8001aa6 <__aeabi_d2f+0x5e>
 8001acc:	431a      	orrs	r2, r3
 8001ace:	d0e8      	beq.n	8001aa2 <__aeabi_d2f+0x5a>
 8001ad0:	2080      	movs	r0, #128	; 0x80
 8001ad2:	00db      	lsls	r3, r3, #3
 8001ad4:	0480      	lsls	r0, r0, #18
 8001ad6:	4303      	orrs	r3, r0
 8001ad8:	24ff      	movs	r4, #255	; 0xff
 8001ada:	e7d0      	b.n	8001a7e <__aeabi_d2f+0x36>
 8001adc:	3417      	adds	r4, #23
 8001ade:	da0c      	bge.n	8001afa <__aeabi_d2f+0xb2>
 8001ae0:	2305      	movs	r3, #5
 8001ae2:	2400      	movs	r4, #0
 8001ae4:	08db      	lsrs	r3, r3, #3
 8001ae6:	2cff      	cmp	r4, #255	; 0xff
 8001ae8:	d1ec      	bne.n	8001ac4 <__aeabi_d2f+0x7c>
 8001aea:	2b00      	cmp	r3, #0
 8001aec:	d02d      	beq.n	8001b4a <__aeabi_d2f+0x102>
 8001aee:	2280      	movs	r2, #128	; 0x80
 8001af0:	03d2      	lsls	r2, r2, #15
 8001af2:	4313      	orrs	r3, r2
 8001af4:	025b      	lsls	r3, r3, #9
 8001af6:	0a5b      	lsrs	r3, r3, #9
 8001af8:	e7d5      	b.n	8001aa6 <__aeabi_d2f+0x5e>
 8001afa:	2480      	movs	r4, #128	; 0x80
 8001afc:	4816      	ldr	r0, [pc, #88]	; (8001b58 <__aeabi_d2f+0x110>)
 8001afe:	0424      	lsls	r4, r4, #16
 8001b00:	4323      	orrs	r3, r4
 8001b02:	1b40      	subs	r0, r0, r5
 8001b04:	281f      	cmp	r0, #31
 8001b06:	dc0d      	bgt.n	8001b24 <__aeabi_d2f+0xdc>
 8001b08:	4c14      	ldr	r4, [pc, #80]	; (8001b5c <__aeabi_d2f+0x114>)
 8001b0a:	46a4      	mov	ip, r4
 8001b0c:	4465      	add	r5, ip
 8001b0e:	40ab      	lsls	r3, r5
 8001b10:	1c1c      	adds	r4, r3, #0
 8001b12:	1c13      	adds	r3, r2, #0
 8001b14:	40ab      	lsls	r3, r5
 8001b16:	1e5d      	subs	r5, r3, #1
 8001b18:	41ab      	sbcs	r3, r5
 8001b1a:	40c2      	lsrs	r2, r0
 8001b1c:	4323      	orrs	r3, r4
 8001b1e:	4313      	orrs	r3, r2
 8001b20:	2400      	movs	r4, #0
 8001b22:	e7ac      	b.n	8001a7e <__aeabi_d2f+0x36>
 8001b24:	1c1e      	adds	r6, r3, #0
 8001b26:	4c0e      	ldr	r4, [pc, #56]	; (8001b60 <__aeabi_d2f+0x118>)
 8001b28:	1b64      	subs	r4, r4, r5
 8001b2a:	40e6      	lsrs	r6, r4
 8001b2c:	1c34      	adds	r4, r6, #0
 8001b2e:	2820      	cmp	r0, #32
 8001b30:	d00d      	beq.n	8001b4e <__aeabi_d2f+0x106>
 8001b32:	480c      	ldr	r0, [pc, #48]	; (8001b64 <__aeabi_d2f+0x11c>)
 8001b34:	4684      	mov	ip, r0
 8001b36:	4465      	add	r5, ip
 8001b38:	40ab      	lsls	r3, r5
 8001b3a:	1c1d      	adds	r5, r3, #0
 8001b3c:	432a      	orrs	r2, r5
 8001b3e:	1e53      	subs	r3, r2, #1
 8001b40:	419a      	sbcs	r2, r3
 8001b42:	1c13      	adds	r3, r2, #0
 8001b44:	4323      	orrs	r3, r4
 8001b46:	2400      	movs	r4, #0
 8001b48:	e799      	b.n	8001a7e <__aeabi_d2f+0x36>
 8001b4a:	2300      	movs	r3, #0
 8001b4c:	e7ab      	b.n	8001aa6 <__aeabi_d2f+0x5e>
 8001b4e:	2500      	movs	r5, #0
 8001b50:	e7f4      	b.n	8001b3c <__aeabi_d2f+0xf4>
 8001b52:	46c0      	nop			; (mov r8, r8)
 8001b54:	fffffc80 	.word	0xfffffc80
 8001b58:	0000039e 	.word	0x0000039e
 8001b5c:	fffffc82 	.word	0xfffffc82
 8001b60:	0000037e 	.word	0x0000037e
 8001b64:	fffffca2 	.word	0xfffffca2

08001b68 <__aeabi_uidiv>:
 8001b68:	2200      	movs	r2, #0
 8001b6a:	0843      	lsrs	r3, r0, #1
 8001b6c:	428b      	cmp	r3, r1
 8001b6e:	d374      	bcc.n	8001c5a <__aeabi_uidiv+0xf2>
 8001b70:	0903      	lsrs	r3, r0, #4
 8001b72:	428b      	cmp	r3, r1
 8001b74:	d35f      	bcc.n	8001c36 <__aeabi_uidiv+0xce>
 8001b76:	0a03      	lsrs	r3, r0, #8
 8001b78:	428b      	cmp	r3, r1
 8001b7a:	d344      	bcc.n	8001c06 <__aeabi_uidiv+0x9e>
 8001b7c:	0b03      	lsrs	r3, r0, #12
 8001b7e:	428b      	cmp	r3, r1
 8001b80:	d328      	bcc.n	8001bd4 <__aeabi_uidiv+0x6c>
 8001b82:	0c03      	lsrs	r3, r0, #16
 8001b84:	428b      	cmp	r3, r1
 8001b86:	d30d      	bcc.n	8001ba4 <__aeabi_uidiv+0x3c>
 8001b88:	22ff      	movs	r2, #255	; 0xff
 8001b8a:	0209      	lsls	r1, r1, #8
 8001b8c:	ba12      	rev	r2, r2
 8001b8e:	0c03      	lsrs	r3, r0, #16
 8001b90:	428b      	cmp	r3, r1
 8001b92:	d302      	bcc.n	8001b9a <__aeabi_uidiv+0x32>
 8001b94:	1212      	asrs	r2, r2, #8
 8001b96:	0209      	lsls	r1, r1, #8
 8001b98:	d065      	beq.n	8001c66 <__aeabi_uidiv+0xfe>
 8001b9a:	0b03      	lsrs	r3, r0, #12
 8001b9c:	428b      	cmp	r3, r1
 8001b9e:	d319      	bcc.n	8001bd4 <__aeabi_uidiv+0x6c>
 8001ba0:	e000      	b.n	8001ba4 <__aeabi_uidiv+0x3c>
 8001ba2:	0a09      	lsrs	r1, r1, #8
 8001ba4:	0bc3      	lsrs	r3, r0, #15
 8001ba6:	428b      	cmp	r3, r1
 8001ba8:	d301      	bcc.n	8001bae <__aeabi_uidiv+0x46>
 8001baa:	03cb      	lsls	r3, r1, #15
 8001bac:	1ac0      	subs	r0, r0, r3
 8001bae:	4152      	adcs	r2, r2
 8001bb0:	0b83      	lsrs	r3, r0, #14
 8001bb2:	428b      	cmp	r3, r1
 8001bb4:	d301      	bcc.n	8001bba <__aeabi_uidiv+0x52>
 8001bb6:	038b      	lsls	r3, r1, #14
 8001bb8:	1ac0      	subs	r0, r0, r3
 8001bba:	4152      	adcs	r2, r2
 8001bbc:	0b43      	lsrs	r3, r0, #13
 8001bbe:	428b      	cmp	r3, r1
 8001bc0:	d301      	bcc.n	8001bc6 <__aeabi_uidiv+0x5e>
 8001bc2:	034b      	lsls	r3, r1, #13
 8001bc4:	1ac0      	subs	r0, r0, r3
 8001bc6:	4152      	adcs	r2, r2
 8001bc8:	0b03      	lsrs	r3, r0, #12
 8001bca:	428b      	cmp	r3, r1
 8001bcc:	d301      	bcc.n	8001bd2 <__aeabi_uidiv+0x6a>
 8001bce:	030b      	lsls	r3, r1, #12
 8001bd0:	1ac0      	subs	r0, r0, r3
 8001bd2:	4152      	adcs	r2, r2
 8001bd4:	0ac3      	lsrs	r3, r0, #11
 8001bd6:	428b      	cmp	r3, r1
 8001bd8:	d301      	bcc.n	8001bde <__aeabi_uidiv+0x76>
 8001bda:	02cb      	lsls	r3, r1, #11
 8001bdc:	1ac0      	subs	r0, r0, r3
 8001bde:	4152      	adcs	r2, r2
 8001be0:	0a83      	lsrs	r3, r0, #10
 8001be2:	428b      	cmp	r3, r1
 8001be4:	d301      	bcc.n	8001bea <__aeabi_uidiv+0x82>
 8001be6:	028b      	lsls	r3, r1, #10
 8001be8:	1ac0      	subs	r0, r0, r3
 8001bea:	4152      	adcs	r2, r2
 8001bec:	0a43      	lsrs	r3, r0, #9
 8001bee:	428b      	cmp	r3, r1
 8001bf0:	d301      	bcc.n	8001bf6 <__aeabi_uidiv+0x8e>
 8001bf2:	024b      	lsls	r3, r1, #9
 8001bf4:	1ac0      	subs	r0, r0, r3
 8001bf6:	4152      	adcs	r2, r2
 8001bf8:	0a03      	lsrs	r3, r0, #8
 8001bfa:	428b      	cmp	r3, r1
 8001bfc:	d301      	bcc.n	8001c02 <__aeabi_uidiv+0x9a>
 8001bfe:	020b      	lsls	r3, r1, #8
 8001c00:	1ac0      	subs	r0, r0, r3
 8001c02:	4152      	adcs	r2, r2
 8001c04:	d2cd      	bcs.n	8001ba2 <__aeabi_uidiv+0x3a>
 8001c06:	09c3      	lsrs	r3, r0, #7
 8001c08:	428b      	cmp	r3, r1
 8001c0a:	d301      	bcc.n	8001c10 <__aeabi_uidiv+0xa8>
 8001c0c:	01cb      	lsls	r3, r1, #7
 8001c0e:	1ac0      	subs	r0, r0, r3
 8001c10:	4152      	adcs	r2, r2
 8001c12:	0983      	lsrs	r3, r0, #6
 8001c14:	428b      	cmp	r3, r1
 8001c16:	d301      	bcc.n	8001c1c <__aeabi_uidiv+0xb4>
 8001c18:	018b      	lsls	r3, r1, #6
 8001c1a:	1ac0      	subs	r0, r0, r3
 8001c1c:	4152      	adcs	r2, r2
 8001c1e:	0943      	lsrs	r3, r0, #5
 8001c20:	428b      	cmp	r3, r1
 8001c22:	d301      	bcc.n	8001c28 <__aeabi_uidiv+0xc0>
 8001c24:	014b      	lsls	r3, r1, #5
 8001c26:	1ac0      	subs	r0, r0, r3
 8001c28:	4152      	adcs	r2, r2
 8001c2a:	0903      	lsrs	r3, r0, #4
 8001c2c:	428b      	cmp	r3, r1
 8001c2e:	d301      	bcc.n	8001c34 <__aeabi_uidiv+0xcc>
 8001c30:	010b      	lsls	r3, r1, #4
 8001c32:	1ac0      	subs	r0, r0, r3
 8001c34:	4152      	adcs	r2, r2
 8001c36:	08c3      	lsrs	r3, r0, #3
 8001c38:	428b      	cmp	r3, r1
 8001c3a:	d301      	bcc.n	8001c40 <__aeabi_uidiv+0xd8>
 8001c3c:	00cb      	lsls	r3, r1, #3
 8001c3e:	1ac0      	subs	r0, r0, r3
 8001c40:	4152      	adcs	r2, r2
 8001c42:	0883      	lsrs	r3, r0, #2
 8001c44:	428b      	cmp	r3, r1
 8001c46:	d301      	bcc.n	8001c4c <__aeabi_uidiv+0xe4>
 8001c48:	008b      	lsls	r3, r1, #2
 8001c4a:	1ac0      	subs	r0, r0, r3
 8001c4c:	4152      	adcs	r2, r2
 8001c4e:	0843      	lsrs	r3, r0, #1
 8001c50:	428b      	cmp	r3, r1
 8001c52:	d301      	bcc.n	8001c58 <__aeabi_uidiv+0xf0>
 8001c54:	004b      	lsls	r3, r1, #1
 8001c56:	1ac0      	subs	r0, r0, r3
 8001c58:	4152      	adcs	r2, r2
 8001c5a:	1a41      	subs	r1, r0, r1
 8001c5c:	d200      	bcs.n	8001c60 <__aeabi_uidiv+0xf8>
 8001c5e:	4601      	mov	r1, r0
 8001c60:	4152      	adcs	r2, r2
 8001c62:	4610      	mov	r0, r2
 8001c64:	4770      	bx	lr
 8001c66:	e7ff      	b.n	8001c68 <__aeabi_uidiv+0x100>
 8001c68:	b501      	push	{r0, lr}
 8001c6a:	2000      	movs	r0, #0
 8001c6c:	f000 f80c 	bl	8001c88 <__aeabi_idiv0>
 8001c70:	bd02      	pop	{r1, pc}
 8001c72:	46c0      	nop			; (mov r8, r8)

08001c74 <__aeabi_uidivmod>:
 8001c74:	2900      	cmp	r1, #0
 8001c76:	d0f7      	beq.n	8001c68 <__aeabi_uidiv+0x100>
 8001c78:	b503      	push	{r0, r1, lr}
 8001c7a:	f7ff ff75 	bl	8001b68 <__aeabi_uidiv>
 8001c7e:	bc0e      	pop	{r1, r2, r3}
 8001c80:	4342      	muls	r2, r0
 8001c82:	1a89      	subs	r1, r1, r2
 8001c84:	4718      	bx	r3
 8001c86:	46c0      	nop			; (mov r8, r8)

08001c88 <__aeabi_idiv0>:
 8001c88:	4770      	bx	lr
 8001c8a:	46c0      	nop			; (mov r8, r8)

08001c8c <__clzsi2>:
 8001c8c:	211c      	movs	r1, #28
 8001c8e:	2301      	movs	r3, #1
 8001c90:	041b      	lsls	r3, r3, #16
 8001c92:	4298      	cmp	r0, r3
 8001c94:	d301      	bcc.n	8001c9a <__clzsi2+0xe>
 8001c96:	0c00      	lsrs	r0, r0, #16
 8001c98:	3910      	subs	r1, #16
 8001c9a:	0a1b      	lsrs	r3, r3, #8
 8001c9c:	4298      	cmp	r0, r3
 8001c9e:	d301      	bcc.n	8001ca4 <__clzsi2+0x18>
 8001ca0:	0a00      	lsrs	r0, r0, #8
 8001ca2:	3908      	subs	r1, #8
 8001ca4:	091b      	lsrs	r3, r3, #4
 8001ca6:	4298      	cmp	r0, r3
 8001ca8:	d301      	bcc.n	8001cae <__clzsi2+0x22>
 8001caa:	0900      	lsrs	r0, r0, #4
 8001cac:	3904      	subs	r1, #4
 8001cae:	a202      	add	r2, pc, #8	; (adr r2, 8001cb8 <__clzsi2+0x2c>)
 8001cb0:	5c10      	ldrb	r0, [r2, r0]
 8001cb2:	1840      	adds	r0, r0, r1
 8001cb4:	4770      	bx	lr
 8001cb6:	46c0      	nop			; (mov r8, r8)
 8001cb8:	02020304 	.word	0x02020304
 8001cbc:	01010101 	.word	0x01010101
	...

08001cd0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 8001cd0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001cd2:	4644      	mov	r4, r8
 8001cd4:	465f      	mov	r7, fp
 8001cd6:	4656      	mov	r6, sl
 8001cd8:	464d      	mov	r5, r9
void hal_lld_init(void) {

  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
 8001cda:	4bd2      	ldr	r3, [pc, #840]	; (8002024 <main+0x354>)
 8001cdc:	49d2      	ldr	r1, [pc, #840]	; (8002028 <main+0x358>)
 8001cde:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001ce0:	b4f0      	push	{r4, r5, r6, r7}
 8001ce2:	430a      	orrs	r2, r1
 8001ce4:	629a      	str	r2, [r3, #40]	; 0x28
 8001ce6:	22bc      	movs	r2, #188	; 0xbc
 8001ce8:	6a99      	ldr	r1, [r3, #40]	; 0x28
 8001cea:	03d2      	lsls	r2, r2, #15
 8001cec:	400a      	ands	r2, r1
 8001cee:	629a      	str	r2, [r3, #40]	; 0x28
 8001cf0:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8001cf2:	691a      	ldr	r2, [r3, #16]
 8001cf4:	2201      	movs	r2, #1
 8001cf6:	2000      	movs	r0, #0
 8001cf8:	4252      	negs	r2, r2
 8001cfa:	611a      	str	r2, [r3, #16]
 8001cfc:	691a      	ldr	r2, [r3, #16]
 8001cfe:	6118      	str	r0, [r3, #16]
 8001d00:	691a      	ldr	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8001d02:	49ca      	ldr	r1, [pc, #808]	; (800202c <main+0x35c>)
 8001d04:	68da      	ldr	r2, [r3, #12]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001d06:	2480      	movs	r4, #128	; 0x80
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8001d08:	430a      	orrs	r2, r1
 8001d0a:	60da      	str	r2, [r3, #12]
 8001d0c:	2280      	movs	r2, #128	; 0x80
 8001d0e:	68d9      	ldr	r1, [r3, #12]
 8001d10:	03d2      	lsls	r2, r2, #15
 8001d12:	400a      	ands	r2, r1

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8001d14:	2180      	movs	r1, #128	; 0x80
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8001d16:	60da      	str	r2, [r3, #12]
 8001d18:	68da      	ldr	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8001d1a:	69da      	ldr	r2, [r3, #28]
 8001d1c:	0549      	lsls	r1, r1, #21
 8001d1e:	430a      	orrs	r2, r1
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001d20:	49c3      	ldr	r1, [pc, #780]	; (8002030 <main+0x360>)
  rccResetAHB(~STM32_GPIO_EN_MASK);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8001d22:	61da      	str	r2, [r3, #28]
 8001d24:	69da      	ldr	r2, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001d26:	680a      	ldr	r2, [r1, #0]
 8001d28:	0064      	lsls	r4, r4, #1
 8001d2a:	4322      	orrs	r2, r4
 8001d2c:	600a      	str	r2, [r1, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8001d2e:	22c0      	movs	r2, #192	; 0xc0
 8001d30:	6a19      	ldr	r1, [r3, #32]
 8001d32:	0092      	lsls	r2, r2, #2
 8001d34:	400a      	ands	r2, r1
 8001d36:	2180      	movs	r1, #128	; 0x80
 8001d38:	b091      	sub	sp, #68	; 0x44
 8001d3a:	0089      	lsls	r1, r1, #2
 8001d3c:	428a      	cmp	r2, r1
 8001d3e:	d003      	beq.n	8001d48 <main+0x78>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8001d40:	2280      	movs	r2, #128	; 0x80
 8001d42:	0252      	lsls	r2, r2, #9
 8001d44:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 8001d46:	6218      	str	r0, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8001d48:	2280      	movs	r2, #128	; 0x80
 8001d4a:	4bb6      	ldr	r3, [pc, #728]	; (8002024 <main+0x354>)
 8001d4c:	0212      	lsls	r2, r2, #8
 8001d4e:	6a19      	ldr	r1, [r3, #32]
 8001d50:	4211      	tst	r1, r2
 8001d52:	d107      	bne.n	8001d64 <main+0x94>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8001d54:	2080      	movs	r0, #128	; 0x80
 8001d56:	6a19      	ldr	r1, [r3, #32]
 8001d58:	0080      	lsls	r0, r0, #2
 8001d5a:	4301      	orrs	r1, r0
 8001d5c:	6219      	str	r1, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8001d5e:	6a19      	ldr	r1, [r3, #32]
 8001d60:	430a      	orrs	r2, r1
 8001d62:	621a      	str	r2, [r3, #32]
 * @init
 */
void dmaInit(void) {
  int i;

  dma.allocated_mask = 0U;
 8001d64:	2400      	movs	r4, #0
 8001d66:	4bb3      	ldr	r3, [pc, #716]	; (8002034 <main+0x364>)
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001d68:	4ab3      	ldr	r2, [pc, #716]	; (8002038 <main+0x368>)
 */
void dmaInit(void) {
  int i;

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
 8001d6a:	605c      	str	r4, [r3, #4]
 * @init
 */
void dmaInit(void) {
  int i;

  dma.allocated_mask = 0U;
 8001d6c:	601c      	str	r4, [r3, #0]
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001d6e:	6014      	str	r4, [r2, #0]
 8001d70:	4ab2      	ldr	r2, [pc, #712]	; (800203c <main+0x36c>)
    dma.streams[i].func = NULL;
 8001d72:	609c      	str	r4, [r3, #8]
  int i;

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001d74:	6014      	str	r4, [r2, #0]
 8001d76:	4ab2      	ldr	r2, [pc, #712]	; (8002040 <main+0x370>)
    dma.streams[i].func = NULL;
 8001d78:	611c      	str	r4, [r3, #16]
  int i;

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001d7a:	6014      	str	r4, [r2, #0]
 8001d7c:	4ab1      	ldr	r2, [pc, #708]	; (8002044 <main+0x374>)
    dma.streams[i].func = NULL;
 8001d7e:	619c      	str	r4, [r3, #24]
  int i;

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001d80:	6014      	str	r4, [r2, #0]
 8001d82:	4ab1      	ldr	r2, [pc, #708]	; (8002048 <main+0x378>)
    dma.streams[i].func = NULL;
 8001d84:	621c      	str	r4, [r3, #32]
  int i;

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001d86:	6014      	str	r4, [r2, #0]
    dma.streams[i].func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8001d88:	2201      	movs	r2, #1

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
    dma.streams[i].func = NULL;
 8001d8a:	629c      	str	r4, [r3, #40]	; 0x28
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8001d8c:	4baf      	ldr	r3, [pc, #700]	; (800204c <main+0x37c>)
 8001d8e:	4252      	negs	r2, r2
 8001d90:	605a      	str	r2, [r3, #4]
 * @notapi
 */
void irqInit(void) {

#if HAL_USE_PAL
  nvicEnableVector(EXTI0_1_IRQn, STM32_IRQ_EXTI0_1_PRIORITY);
 8001d92:	2005      	movs	r0, #5
 8001d94:	2103      	movs	r1, #3
 8001d96:	f002 fd4b 	bl	8004830 <nvicEnableVector>
  nvicEnableVector(EXTI2_3_IRQn, STM32_IRQ_EXTI2_3_PRIORITY);
 8001d9a:	2006      	movs	r0, #6
 8001d9c:	2103      	movs	r1, #3
 8001d9e:	f002 fd47 	bl	8004830 <nvicEnableVector>
  nvicEnableVector(EXTI4_15_IRQn, STM32_IRQ_EXTI4_15_PRIORITY);
 8001da2:	2007      	movs	r0, #7
 8001da4:	2103      	movs	r1, #3
 8001da6:	f002 fd43 	bl	8004830 <nvicEnableVector>
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8001daa:	2301      	movs	r3, #1
 8001dac:	4ea8      	ldr	r6, [pc, #672]	; (8002050 <main+0x380>)
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc     = ADC1;
 8001dae:	4fa9      	ldr	r7, [pc, #676]	; (8002054 <main+0x384>)
 8001db0:	7033      	strb	r3, [r6, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001db2:	1c33      	adds	r3, r6, #0
 8001db4:	3318      	adds	r3, #24
 8001db6:	61b3      	str	r3, [r6, #24]
  tqp->prev = (thread_t *)tqp;
 8001db8:	61f3      	str	r3, [r6, #28]
  ADCD1.dmastp  = NULL;
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 8001dba:	4ba7      	ldr	r3, [pc, #668]	; (8002058 <main+0x388>)
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;

#if STM32_ADC1_IRQ_SHARED_WITH_EXTI == FALSE
  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(12, STM32_ADC_ADC1_IRQ_PRIORITY);
 8001dbc:	2102      	movs	r1, #2
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8001dbe:	6234      	str	r4, [r6, #32]
 8001dc0:	200c      	movs	r0, #12
#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc     = ADC1;
  ADCD1.dmastp  = NULL;
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 8001dc2:	6333      	str	r3, [r6, #48]	; 0x30
  adcp->config   = NULL;
 8001dc4:	6074      	str	r4, [r6, #4]
  adcp->samples  = NULL;
 8001dc6:	60b4      	str	r4, [r6, #8]
  adcp->depth    = 0;
 8001dc8:	60f4      	str	r4, [r6, #12]
  adcp->grpp     = NULL;
 8001dca:	6134      	str	r4, [r6, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8001dcc:	6174      	str	r4, [r6, #20]
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc     = ADC1;
 8001dce:	62b7      	str	r7, [r6, #40]	; 0x28
  ADCD1.dmastp  = NULL;
 8001dd0:	62f4      	str	r4, [r6, #44]	; 0x2c
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;

#if STM32_ADC1_IRQ_SHARED_WITH_EXTI == FALSE
  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(12, STM32_ADC_ADC1_IRQ_PRIORITY);
 8001dd2:	f002 fd2d 	bl	8004830 <nvicEnableVector>
#endif
#endif

  /* Calibration procedure.*/
  rccEnableADC1(true);
 8001dd6:	2180      	movs	r1, #128	; 0x80
 8001dd8:	4b92      	ldr	r3, [pc, #584]	; (8002024 <main+0x354>)
 8001dda:	0089      	lsls	r1, r1, #2
 8001ddc:	699a      	ldr	r2, [r3, #24]
 8001dde:	430a      	orrs	r2, r1
 8001de0:	619a      	str	r2, [r3, #24]
 8001de2:	699b      	ldr	r3, [r3, #24]

  /* CCR setup.*/
#if STM32_ADC_SUPPORTS_PRESCALER
  ADC->CCR = STM32_ADC_PRESC << 18;
#else
  ADC->CCR = 0;
 8001de4:	4b9d      	ldr	r3, [pc, #628]	; (800205c <main+0x38c>)
 8001de6:	601c      	str	r4, [r3, #0]
#endif

  osalDbgAssert(ADC1->CR == 0, "invalid register state");
 8001de8:	68bb      	ldr	r3, [r7, #8]
 8001dea:	9301      	str	r3, [sp, #4]
 8001dec:	2b00      	cmp	r3, #0
 8001dee:	d000      	beq.n	8001df2 <main+0x122>
 8001df0:	e0c3      	b.n	8001f7a <main+0x2aa>
  ADC1->CR |= ADC_CR_ADCAL;
 8001df2:	2280      	movs	r2, #128	; 0x80
 8001df4:	68bb      	ldr	r3, [r7, #8]
 8001df6:	0612      	lsls	r2, r2, #24
 8001df8:	4313      	orrs	r3, r2
 8001dfa:	60bb      	str	r3, [r7, #8]
  osalDbgAssert(ADC1->CR != 0, "invalid register state");
 8001dfc:	68bb      	ldr	r3, [r7, #8]
 8001dfe:	2b00      	cmp	r3, #0
 8001e00:	d100      	bne.n	8001e04 <main+0x134>
 8001e02:	e0ba      	b.n	8001f7a <main+0x2aa>
  while (ADC1->CR & ADC_CR_ADCAL)
 8001e04:	1c3b      	adds	r3, r7, #0
 8001e06:	689a      	ldr	r2, [r3, #8]
 8001e08:	2a00      	cmp	r2, #0
 8001e0a:	dbfc      	blt.n	8001e06 <main+0x136>
    ;
  rccDisableADC1();
 8001e0c:	4b85      	ldr	r3, [pc, #532]	; (8002024 <main+0x354>)
 8001e0e:	4a94      	ldr	r2, [pc, #592]	; (8002060 <main+0x390>)
 8001e10:	6999      	ldr	r1, [r3, #24]
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8001e12:	4f94      	ldr	r7, [pc, #592]	; (8002064 <main+0x394>)
 8001e14:	400a      	ands	r2, r1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001e16:	4994      	ldr	r1, [pc, #592]	; (8002068 <main+0x398>)
 8001e18:	619a      	str	r2, [r3, #24]
 8001e1a:	699a      	ldr	r2, [r3, #24]
 8001e1c:	468b      	mov	fp, r1
 8001e1e:	60f9      	str	r1, [r7, #12]
  tqp->prev = (thread_t *)tqp;
 8001e20:	6139      	str	r1, [r7, #16]
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 8001e22:	4992      	ldr	r1, [pc, #584]	; (800206c <main+0x39c>)
  i2cp->config = NULL;
 8001e24:	2500      	movs	r5, #0
 8001e26:	6339      	str	r1, [r7, #48]	; 0x30

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001e28:	2102      	movs	r1, #2
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8001e2a:	2201      	movs	r2, #1
 8001e2c:	69d8      	ldr	r0, [r3, #28]
 8001e2e:	703a      	strb	r2, [r7, #0]
 8001e30:	4308      	orrs	r0, r1
  i2cp->config = NULL;
 8001e32:	607d      	str	r5, [r7, #4]
 8001e34:	617d      	str	r5, [r7, #20]
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 8001e36:	61fd      	str	r5, [r7, #28]
  I2CD1.i2c    = I2C1;
#if STM32_I2C_USE_DMA == TRUE
  I2CD1.dmarx  = NULL;
 8001e38:	62bd      	str	r5, [r7, #40]	; 0x28
  I2CD1.dmatx  = NULL;
 8001e3a:	62fd      	str	r5, [r7, #44]	; 0x2c
 8001e3c:	61d8      	str	r0, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001e3e:	488c      	ldr	r0, [pc, #560]	; (8002070 <main+0x3a0>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001e40:	69db      	ldr	r3, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001e42:	6883      	ldr	r3, [r0, #8]
 8001e44:	430b      	orrs	r3, r1
 8001e46:	6083      	str	r3, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001e48:	4b8a      	ldr	r3, [pc, #552]	; (8002074 <main+0x3a4>)
 8001e4a:	488b      	ldr	r0, [pc, #556]	; (8002078 <main+0x3a8>)
 8001e4c:	6298      	str	r0, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001e4e:	488b      	ldr	r0, [pc, #556]	; (800207c <main+0x3ac>)
 8001e50:	62d8      	str	r0, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8001e52:	619d      	str	r5, [r3, #24]
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001e54:	2010      	movs	r0, #16

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
  STM32_ST_TIM->CCR[0] = 0;
 8001e56:	635d      	str	r5, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8001e58:	60dd      	str	r5, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001e5a:	605d      	str	r5, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8001e5c:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8001e5e:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8001e60:	f002 fce6 	bl	8004830 <nvicEnableVector>
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001e64:	4c86      	ldr	r4, [pc, #536]	; (8002080 <main+0x3b0>)
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001e66:	4b87      	ldr	r3, [pc, #540]	; (8002084 <main+0x3b4>)

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8001e68:	2007      	movs	r0, #7
 8001e6a:	61e3      	str	r3, [r4, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8001e6c:	6223      	str	r3, [r4, #32]
  ch.vtlist.delta = (sysinterval_t)-1;
 8001e6e:	2301      	movs	r3, #1
 8001e70:	425b      	negs	r3, r3
 8001e72:	6263      	str	r3, [r4, #36]	; 0x24
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8001e74:	3b0f      	subs	r3, #15
 8001e76:	8723      	strh	r3, [r4, #56]	; 0x38
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8001e78:	3390      	adds	r3, #144	; 0x90
 8001e7a:	8763      	strh	r3, [r4, #58]	; 0x3a
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8001e7c:	4b82      	ldr	r3, [pc, #520]	; (8002088 <main+0x3b8>)
 8001e7e:	6024      	str	r4, [r4, #0]
 8001e80:	63e3      	str	r3, [r4, #60]	; 0x3c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8001e82:	1c2b      	adds	r3, r5, #0
  tqp->prev = (thread_t *)tqp;
 8001e84:	6064      	str	r4, [r4, #4]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8001e86:	60a5      	str	r5, [r4, #8]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8001e88:	8525      	strh	r5, [r4, #40]	; 0x28
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8001e8a:	3301      	adds	r3, #1
 8001e8c:	011a      	lsls	r2, r3, #4
 8001e8e:	18a2      	adds	r2, r4, r2
 8001e90:	3228      	adds	r2, #40	; 0x28
 8001e92:	7a11      	ldrb	r1, [r2, #8]
 8001e94:	4381      	bics	r1, r0
 8001e96:	7211      	strb	r1, [r2, #8]
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8001e98:	2b80      	cmp	r3, #128	; 0x80
 8001e9a:	d1f6      	bne.n	8001e8a <main+0x1ba>
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 8001e9c:	2524      	movs	r5, #36	; 0x24
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 8001e9e:	4a7b      	ldr	r2, [pc, #492]	; (800208c <main+0x3bc>)
 8001ea0:	487b      	ldr	r0, [pc, #492]	; (8002090 <main+0x3c0>)
  _scheduler_init();
  _vt_init();
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 8001ea2:	2100      	movs	r1, #0
 8001ea4:	6010      	str	r0, [r2, #0]
  ch_memcore.endmem  = __heap_end__;
 8001ea6:	487b      	ldr	r0, [pc, #492]	; (8002094 <main+0x3c4>)
 8001ea8:	46a8      	mov	r8, r5
 8001eaa:	6050      	str	r0, [r2, #4]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8001eac:	4a7a      	ldr	r2, [pc, #488]	; (8002098 <main+0x3c8>)
 8001eae:	487b      	ldr	r0, [pc, #492]	; (800209c <main+0x3cc>)
  H_NEXT(&default_heap.header) = NULL;
 8001eb0:	6051      	str	r1, [r2, #4]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8001eb2:	6010      	str	r0, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001eb4:	1c10      	adds	r0, r2, #0
 8001eb6:	300c      	adds	r0, #12
  H_NEXT(&default_heap.header) = NULL;
  H_PAGES(&default_heap.header) = 0;
 8001eb8:	6091      	str	r1, [r2, #8]
  tqp->prev = (thread_t *)tqp;
 8001eba:	6110      	str	r0, [r2, #16]
 8001ebc:	6151      	str	r1, [r2, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001ebe:	60d0      	str	r0, [r2, #12]
 8001ec0:	4a77      	ldr	r2, [pc, #476]	; (80020a0 <main+0x3d0>)
 8001ec2:	6321      	str	r1, [r4, #48]	; 0x30
 8001ec4:	4490      	add	r8, r2
 8001ec6:	4645      	mov	r5, r8
 8001ec8:	1c10      	adds	r0, r2, #0
 8001eca:	6255      	str	r5, [r2, #36]	; 0x24
 8001ecc:	2528      	movs	r5, #40	; 0x28
 8001ece:	3010      	adds	r0, #16
 8001ed0:	6110      	str	r0, [r2, #16]
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 8001ed2:	2014      	movs	r0, #20
 8001ed4:	46a8      	mov	r8, r5
 8001ed6:	6190      	str	r0, [r2, #24]
  mp->align = align;
 8001ed8:	3810      	subs	r0, #16
 8001eda:	4684      	mov	ip, r0
 8001edc:	61d0      	str	r0, [r2, #28]
  mp->provider = provider;
 8001ede:	4871      	ldr	r0, [pc, #452]	; (80020a4 <main+0x3d4>)
 8001ee0:	4490      	add	r8, r2
 8001ee2:	6210      	str	r0, [r2, #32]
 8001ee4:	6390      	str	r0, [r2, #56]	; 0x38
 8001ee6:	1c10      	adds	r0, r2, #0
 8001ee8:	4645      	mov	r5, r8
 8001eea:	303c      	adds	r0, #60	; 0x3c
 8001eec:	63d0      	str	r0, [r2, #60]	; 0x3c
 8001eee:	1c10      	adds	r0, r2, #0
 8001ef0:	6295      	str	r5, [r2, #40]	; 0x28
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 8001ef2:	251c      	movs	r5, #28
 8001ef4:	3040      	adds	r0, #64	; 0x40
 8001ef6:	6410      	str	r0, [r2, #64]	; 0x40
 8001ef8:	1c10      	adds	r0, r2, #0
 8001efa:	6315      	str	r5, [r2, #48]	; 0x30
  mp->align = align;
 8001efc:	4665      	mov	r5, ip
 8001efe:	3044      	adds	r0, #68	; 0x44
  ch.dbg.lock_cnt = (cnt_t)0;
 8001f00:	6361      	str	r1, [r4, #52]	; 0x34
 8001f02:	6091      	str	r1, [r2, #8]
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8001f04:	6151      	str	r1, [r2, #20]
 8001f06:	62d1      	str	r1, [r2, #44]	; 0x2c
  mp->object_size = size;
  mp->align = align;
 8001f08:	6355      	str	r5, [r2, #52]	; 0x34
 8001f0a:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8001f0c:	6052      	str	r2, [r2, #4]
 8001f0e:	6450      	str	r0, [r2, #68]	; 0x44
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8001f10:	4a65      	ldr	r2, [pc, #404]	; (80020a8 <main+0x3d8>)
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8001f12:	4866      	ldr	r0, [pc, #408]	; (80020ac <main+0x3dc>)
 8001f14:	50a3      	str	r3, [r4, r2]
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001f16:	4a66      	ldr	r2, [pc, #408]	; (80020b0 <main+0x3e0>)
 8001f18:	54a1      	strb	r1, [r4, r2]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8001f1a:	4a66      	ldr	r2, [pc, #408]	; (80020b4 <main+0x3e4>)
 8001f1c:	50a3      	str	r3, [r4, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8001f1e:	2201      	movs	r2, #1
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8001f20:	4b65      	ldr	r3, [pc, #404]	; (80020b8 <main+0x3e8>)
 8001f22:	50e1      	str	r1, [r4, r3]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8001f24:	4b65      	ldr	r3, [pc, #404]	; (80020bc <main+0x3ec>)
 8001f26:	50e1      	str	r1, [r4, r3]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8001f28:	4b65      	ldr	r3, [pc, #404]	; (80020c0 <main+0x3f0>)
  tp->name      = name;
 8001f2a:	4966      	ldr	r1, [pc, #408]	; (80020c4 <main+0x3f4>)
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8001f2c:	54e2      	strb	r2, [r4, r3]
  tp->name      = name;
 8001f2e:	4b66      	ldr	r3, [pc, #408]	; (80020c8 <main+0x3f8>)
 8001f30:	50e1      	str	r1, [r4, r3]
  REG_INSERT(tp);
 8001f32:	3b08      	subs	r3, #8
 8001f34:	4965      	ldr	r1, [pc, #404]	; (80020cc <main+0x3fc>)
 8001f36:	50e4      	str	r4, [r4, r3]
 8001f38:	4b65      	ldr	r3, [pc, #404]	; (80020d0 <main+0x400>)
 8001f3a:	5060      	str	r0, [r4, r1]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001f3c:	4965      	ldr	r1, [pc, #404]	; (80020d4 <main+0x404>)
 8001f3e:	4866      	ldr	r0, [pc, #408]	; (80020d8 <main+0x408>)
 8001f40:	50e4      	str	r4, [r4, r3]
 8001f42:	4b66      	ldr	r3, [pc, #408]	; (80020dc <main+0x40c>)
 8001f44:	5021      	str	r1, [r4, r0]
  tqp->prev = (thread_t *)tqp;
 8001f46:	3004      	adds	r0, #4
 8001f48:	6123      	str	r3, [r4, #16]
 8001f4a:	6163      	str	r3, [r4, #20]
 8001f4c:	5021      	str	r1, [r4, r0]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8001f4e:	61a3      	str	r3, [r4, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8001f50:	4963      	ldr	r1, [pc, #396]	; (80020e0 <main+0x410>)
 8001f52:	4b64      	ldr	r3, [pc, #400]	; (80020e4 <main+0x414>)
 8001f54:	50e1      	str	r1, [r4, r3]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8001f56:	3304      	adds	r3, #4
 8001f58:	54e2      	strb	r2, [r4, r3]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 8001f5a:	4a63      	ldr	r2, [pc, #396]	; (80020e8 <main+0x418>)
 8001f5c:	4b63      	ldr	r3, [pc, #396]	; (80020ec <main+0x41c>)
 8001f5e:	6a11      	ldr	r1, [r2, #32]
 8001f60:	400b      	ands	r3, r1
 8001f62:	6213      	str	r3, [r2, #32]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001f64:	b662      	cpsie	i
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  thread_t *tp;

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8001f66:	4b62      	ldr	r3, [pc, #392]	; (80020f0 <main+0x420>)
 8001f68:	1c18      	adds	r0, r3, #0
 8001f6a:	4698      	mov	r8, r3
 8001f6c:	f000 fd78 	bl	8002a60 <chRegFindThreadByWorkingArea>
 8001f70:	2800      	cmp	r0, #0
 8001f72:	d005      	beq.n	8001f80 <main+0x2b0>
 8001f74:	485f      	ldr	r0, [pc, #380]	; (80020f4 <main+0x424>)
 8001f76:	f000 fcfb 	bl	8002970 <chSysHalt>
  ADC->CCR = STM32_ADC_PRESC << 18;
#else
  ADC->CCR = 0;
#endif

  osalDbgAssert(ADC1->CR == 0, "invalid register state");
 8001f7a:	485f      	ldr	r0, [pc, #380]	; (80020f8 <main+0x428>)
 8001f7c:	f000 fcf8 	bl	8002970 <chSysHalt>
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 8001f80:	2355      	movs	r3, #85	; 0x55
 8001f82:	4642      	mov	r2, r8
 8001f84:	5413      	strb	r3, [r2, r0]
 8001f86:	3001      	adds	r0, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8001f88:	28d8      	cmp	r0, #216	; 0xd8
 8001f8a:	d1fa      	bne.n	8001f82 <main+0x2b2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001f8c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8001f8e:	f000 fd2f 	bl	80029f0 <_dbg_check_lock>
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  thread_t *tp;

  chDbgCheckClassI();
 8001f92:	f000 fd1d 	bl	80029d0 <chDbgCheckClassI>
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8001f96:	23ac      	movs	r3, #172	; 0xac
 8001f98:	4642      	mov	r2, r8
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001f9a:	4641      	mov	r1, r8
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8001f9c:	50d2      	str	r2, [r2, r3]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001f9e:	326c      	adds	r2, #108	; 0x6c
 8001fa0:	3b10      	subs	r3, #16
 8001fa2:	50ca      	str	r2, [r1, r3]
 8001fa4:	4b55      	ldr	r3, [pc, #340]	; (80020fc <main+0x42c>)
 8001fa6:	2280      	movs	r2, #128	; 0x80
 8001fa8:	67cb      	str	r3, [r1, #124]	; 0x7c
 8001faa:	2300      	movs	r3, #0
 8001fac:	508b      	str	r3, [r1, r2]
 8001fae:	4a54      	ldr	r2, [pc, #336]	; (8002100 <main+0x430>)
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8001fb0:	4645      	mov	r5, r8
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001fb2:	4691      	mov	r9, r2
 8001fb4:	228c      	movs	r2, #140	; 0x8c
 8001fb6:	4648      	mov	r0, r9
 8001fb8:	5088      	str	r0, [r1, r2]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8001fba:	2198      	movs	r1, #152	; 0x98
 8001fbc:	4640      	mov	r0, r8
 8001fbe:	3a8b      	subs	r2, #139	; 0x8b
 8001fc0:	5042      	str	r2, [r0, r1]
  tp->state     = CH_STATE_WTSTART;
 8001fc2:	2002      	movs	r0, #2
 8001fc4:	3118      	adds	r1, #24
 8001fc6:	5468      	strb	r0, [r5, r1]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001fc8:	3101      	adds	r1, #1
 8001fca:	546b      	strb	r3, [r5, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8001fcc:	311b      	adds	r1, #27
 8001fce:	506a      	str	r2, [r5, r1]
  tp->mtxlist   = NULL;
 8001fd0:	3904      	subs	r1, #4
 8001fd2:	506b      	str	r3, [r5, r1]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8001fd4:	3904      	subs	r1, #4
 8001fd6:	506b      	str	r3, [r5, r1]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8001fd8:	33b2      	adds	r3, #178	; 0xb2
 8001fda:	54ea      	strb	r2, [r5, r3]
  tp->name      = name;
 8001fdc:	4a49      	ldr	r2, [pc, #292]	; (8002104 <main+0x434>)
 8001fde:	3b0a      	subs	r3, #10
 8001fe0:	50ea      	str	r2, [r5, r3]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001fe2:	4640      	mov	r0, r8
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8001fe4:	22a4      	movs	r2, #164	; 0xa4
 8001fe6:	3b08      	subs	r3, #8
 8001fe8:	50ec      	str	r4, [r5, r3]
 8001fea:	6963      	ldr	r3, [r4, #20]
 8001fec:	3090      	adds	r0, #144	; 0x90
 8001fee:	50ab      	str	r3, [r5, r2]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8001ff0:	4642      	mov	r2, r8
 8001ff2:	6118      	str	r0, [r3, #16]
 8001ff4:	23b8      	movs	r3, #184	; 0xb8
 8001ff6:	32b8      	adds	r2, #184	; 0xb8
 8001ff8:	50ea      	str	r2, [r5, r3]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001ffa:	4643      	mov	r3, r8
 8001ffc:	22bc      	movs	r2, #188	; 0xbc
 8001ffe:	33bc      	adds	r3, #188	; 0xbc
 8002000:	50ab      	str	r3, [r5, r2]
  tqp->prev = (thread_t *)tqp;
 8002002:	3204      	adds	r2, #4
 8002004:	50ab      	str	r3, [r5, r2]
 8002006:	6160      	str	r0, [r4, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
  chSchWakeupS(tp, MSG_OK);
 8002008:	f002 fd72 	bl	8004af0 <chSchWakeupS.constprop.22>
  chSysUnlock();
 800200c:	f000 fd08 	bl	8002a20 <chSysUnlock.lto_priv.55>
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {

  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 8002010:	783b      	ldrb	r3, [r7, #0]
 8002012:	1e5a      	subs	r2, r3, #1
 8002014:	2a01      	cmp	r2, #1
 8002016:	d979      	bls.n	800210c <main+0x43c>
 8002018:	2b05      	cmp	r3, #5
 800201a:	d077      	beq.n	800210c <main+0x43c>
 800201c:	483a      	ldr	r0, [pc, #232]	; (8002108 <main+0x438>)
 800201e:	f000 fca7 	bl	8002970 <chSysHalt>
 8002022:	46c0      	nop			; (mov r8, r8)
 8002024:	40021000 	.word	0x40021000
 8002028:	ffa1ffff 	.word	0xffa1ffff
 800202c:	ffbfffff 	.word	0xffbfffff
 8002030:	40007000 	.word	0x40007000
 8002034:	20000424 	.word	0x20000424
 8002038:	40020008 	.word	0x40020008
 800203c:	4002001c 	.word	0x4002001c
 8002040:	40020030 	.word	0x40020030
 8002044:	40020044 	.word	0x40020044
 8002048:	40020058 	.word	0x40020058
 800204c:	40020000 	.word	0x40020000
 8002050:	2000045c 	.word	0x2000045c
 8002054:	40012400 	.word	0x40012400
 8002058:	0000258a 	.word	0x0000258a
 800205c:	40012708 	.word	0x40012708
 8002060:	fffffdff 	.word	0xfffffdff
 8002064:	20000f84 	.word	0x20000f84
 8002068:	20000f90 	.word	0x20000f90
 800206c:	40005400 	.word	0x40005400
 8002070:	40015800 	.word	0x40015800
 8002074:	40000400 	.word	0x40000400
 8002078:	0000095f 	.word	0x0000095f
 800207c:	0000ffff 	.word	0x0000ffff
 8002080:	20000700 	.word	0x20000700
 8002084:	2000071c 	.word	0x2000071c
 8002088:	20000740 	.word	0x20000740
 800208c:	2000041c 	.word	0x2000041c
 8002090:	20000fb8 	.word	0x20000fb8
 8002094:	20001000 	.word	0x20001000
 8002098:	20000400 	.word	0x20000400
 800209c:	08003281 	.word	0x08003281
 80020a0:	20000490 	.word	0x20000490
 80020a4:	08003221 	.word	0x08003221
 80020a8:	00000848 	.word	0x00000848
 80020ac:	20000f68 	.word	0x20000f68
 80020b0:	00000861 	.word	0x00000861
 80020b4:	0000087c 	.word	0x0000087c
 80020b8:	00000878 	.word	0x00000878
 80020bc:	00000874 	.word	0x00000874
 80020c0:	00000862 	.word	0x00000862
 80020c4:	080057e0 	.word	0x080057e0
 80020c8:	00000858 	.word	0x00000858
 80020cc:	00000868 	.word	0x00000868
 80020d0:	00000854 	.word	0x00000854
 80020d4:	20000f6c 	.word	0x20000f6c
 80020d8:	0000086c 	.word	0x0000086c
 80020dc:	20000f40 	.word	0x20000f40
 80020e0:	20000200 	.word	0x20000200
 80020e4:	0000085c 	.word	0x0000085c
 80020e8:	e000ed00 	.word	0xe000ed00
 80020ec:	ff00ffff 	.word	0xff00ffff
 80020f0:	20000628 	.word	0x20000628
 80020f4:	08005828 	.word	0x08005828
 80020f8:	08005770 	.word	0x08005770
 80020fc:	08002931 	.word	0x08002931
 8002100:	080001b9 	.word	0x080001b9
 8002104:	080057f8 	.word	0x080057f8
 8002108:	0800586c 	.word	0x0800586c
 800210c:	b672      	cpsid	i
 800210e:	f000 fc6f 	bl	80029f0 <_dbg_check_lock>
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 8002112:	4bc6      	ldr	r3, [pc, #792]	; (800242c <main+0x75c>)
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 8002114:	2201      	movs	r2, #1
 8002116:	607b      	str	r3, [r7, #4]
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8002118:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800211a:	4698      	mov	r8, r3

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 800211c:	681b      	ldr	r3, [r3, #0]
 800211e:	4393      	bics	r3, r2
 8002120:	4642      	mov	r2, r8
 8002122:	6013      	str	r3, [r2, #0]

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8002124:	783b      	ldrb	r3, [r7, #0]
 8002126:	469a      	mov	sl, r3
 8002128:	2b01      	cmp	r3, #1
 800212a:	d02a      	beq.n	8002182 <main+0x4b2>
#endif /* STM32_I2C_USE_I2C4 */
  }

#if STM32_I2C_USE_DMA == TRUE
  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->RXDR);
 800212c:	4642      	mov	r2, r8
 800212e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002130:	3224      	adds	r2, #36	; 0x24
 8002132:	685b      	ldr	r3, [r3, #4]
 8002134:	609a      	str	r2, [r3, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->TXDR);
 8002136:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002138:	3204      	adds	r2, #4
 800213a:	685b      	ldr	r3, [r3, #4]
 800213c:	609a      	str	r2, [r3, #8]
#endif

  /* Reset i2c peripheral, the TCIE bit will be handled separately.*/
  dp->CR1 = i2cp->config->cr1 |
 800213e:	687a      	ldr	r2, [r7, #4]
#if STM32_I2C_USE_DMA == TRUE
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;
 8002140:	4bbb      	ldr	r3, [pc, #748]	; (8002430 <main+0x760>)
 8002142:	6851      	ldr	r1, [r2, #4]
 8002144:	430b      	orrs	r3, r1
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->RXDR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->TXDR);
#endif

  /* Reset i2c peripheral, the TCIE bit will be handled separately.*/
  dp->CR1 = i2cp->config->cr1 |
 8002146:	4641      	mov	r1, r8
 8002148:	600b      	str	r3, [r1, #0]
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;

  /* Setup I2C parameters.*/
  dp->TIMINGR = i2cp->config->timingr;
 800214a:	6813      	ldr	r3, [r2, #0]

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 800214c:	2201      	movs	r2, #1
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;

  /* Setup I2C parameters.*/
  dp->TIMINGR = i2cp->config->timingr;
 800214e:	610b      	str	r3, [r1, #16]

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 8002150:	680b      	ldr	r3, [r1, #0]
 8002152:	4313      	orrs	r3, r2
 8002154:	600b      	str	r3, [r1, #0]
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 8002156:	2302      	movs	r3, #2
 8002158:	703b      	strb	r3, [r7, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 800215a:	f000 fc21 	bl	80029a0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800215e:	6823      	ldr	r3, [r4, #0]
 8002160:	42a3      	cmp	r3, r4
 8002162:	d004      	beq.n	800216e <main+0x49e>
 8002164:	69a2      	ldr	r2, [r4, #24]
 8002166:	689b      	ldr	r3, [r3, #8]
 8002168:	6892      	ldr	r2, [r2, #8]
 800216a:	429a      	cmp	r2, r3
 800216c:	d33b      	bcc.n	80021e6 <main+0x516>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800216e:	b662      	cpsie	i
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 8002170:	4fb0      	ldr	r7, [pc, #704]	; (8002434 <main+0x764>)
 8002172:	1c38      	adds	r0, r7, #0
 8002174:	f000 fc74 	bl	8002a60 <chRegFindThreadByWorkingArea>
 8002178:	2800      	cmp	r0, #0
 800217a:	d037      	beq.n	80021ec <main+0x51c>
 800217c:	48ae      	ldr	r0, [pc, #696]	; (8002438 <main+0x768>)
 800217e:	f000 fbf7 	bl	8002970 <chSysHalt>
#endif

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {

      rccResetI2C1();
 8002182:	2080      	movs	r0, #128	; 0x80
  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {

#if STM32_I2C_USE_DMA == TRUE
    /* Common DMA modes.*/
    i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
 8002184:	3399      	adds	r3, #153	; 0x99
 8002186:	627b      	str	r3, [r7, #36]	; 0x24
    i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
 8002188:	3b10      	subs	r3, #16
 800218a:	623b      	str	r3, [r7, #32]
#endif

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {

      rccResetI2C1();
 800218c:	4bab      	ldr	r3, [pc, #684]	; (800243c <main+0x76c>)
 800218e:	0380      	lsls	r0, r0, #14
 8002190:	691a      	ldr	r2, [r3, #16]
 8002192:	49ab      	ldr	r1, [pc, #684]	; (8002440 <main+0x770>)
 8002194:	4302      	orrs	r2, r0
 8002196:	611a      	str	r2, [r3, #16]
 8002198:	691a      	ldr	r2, [r3, #16]
 800219a:	4011      	ands	r1, r2
 800219c:	6119      	str	r1, [r3, #16]
 800219e:	691a      	ldr	r2, [r3, #16]
      rccEnableI2C1(true);
 80021a0:	69da      	ldr	r2, [r3, #28]
#if STM32_I2C_USE_DMA == TRUE
      {
        i2cp->dmarx = dmaStreamAllocI(STM32_I2C_I2C1_RX_DMA_STREAM,
 80021a2:	2103      	movs	r1, #3

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {

      rccResetI2C1();
      rccEnableI2C1(true);
 80021a4:	4302      	orrs	r2, r0
 80021a6:	61da      	str	r2, [r3, #28]
 80021a8:	69db      	ldr	r3, [r3, #28]
#if STM32_I2C_USE_DMA == TRUE
      {
        i2cp->dmarx = dmaStreamAllocI(STM32_I2C_I2C1_RX_DMA_STREAM,
 80021aa:	2002      	movs	r0, #2
 80021ac:	2200      	movs	r2, #0
 80021ae:	1c3b      	adds	r3, r7, #0
 80021b0:	f001 ff2e 	bl	8004010 <dmaStreamAllocI>
 80021b4:	62b8      	str	r0, [r7, #40]	; 0x28
                                      STM32_I2C_I2C1_IRQ_PRIORITY,
                                      NULL,
                                      (void *)i2cp);
        osalDbgAssert(i2cp->dmarx != NULL, "unable to allocate stream");
 80021b6:	2800      	cmp	r0, #0
 80021b8:	d076      	beq.n	80022a8 <main+0x5d8>
        i2cp->dmatx = dmaStreamAllocI(STM32_I2C_I2C1_TX_DMA_STREAM,
 80021ba:	4650      	mov	r0, sl
 80021bc:	2103      	movs	r1, #3
 80021be:	2200      	movs	r2, #0
 80021c0:	1c3b      	adds	r3, r7, #0
 80021c2:	f001 ff25 	bl	8004010 <dmaStreamAllocI>
 80021c6:	62f8      	str	r0, [r7, #44]	; 0x2c
                                      STM32_I2C_I2C1_IRQ_PRIORITY,
                                      NULL,
                                      (void *)i2cp);
        osalDbgAssert(i2cp->dmatx != NULL, "unable to allocate stream");
 80021c8:	2800      	cmp	r0, #0
 80021ca:	d06d      	beq.n	80022a8 <main+0x5d8>

        i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80021cc:	2380      	movs	r3, #128	; 0x80
 80021ce:	6a3a      	ldr	r2, [r7, #32]
 80021d0:	015b      	lsls	r3, r3, #5
 80021d2:	431a      	orrs	r2, r3
 80021d4:	623a      	str	r2, [r7, #32]
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
        i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80021d6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      }
#endif /* STM32_I2C_USE_DMA == TRUE */

#if defined(STM32_I2C1_GLOBAL_NUMBER) || defined(__DOXYGEN__)
      nvicEnableVector(STM32_I2C1_GLOBAL_NUMBER, STM32_I2C_I2C1_IRQ_PRIORITY);
 80021d8:	2017      	movs	r0, #23
                                      (void *)i2cp);
        osalDbgAssert(i2cp->dmatx != NULL, "unable to allocate stream");

        i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
        i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80021da:	4313      	orrs	r3, r2
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      }
#endif /* STM32_I2C_USE_DMA == TRUE */

#if defined(STM32_I2C1_GLOBAL_NUMBER) || defined(__DOXYGEN__)
      nvicEnableVector(STM32_I2C1_GLOBAL_NUMBER, STM32_I2C_I2C1_IRQ_PRIORITY);
 80021dc:	2103      	movs	r1, #3
                                      (void *)i2cp);
        osalDbgAssert(i2cp->dmatx != NULL, "unable to allocate stream");

        i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
        i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80021de:	627b      	str	r3, [r7, #36]	; 0x24
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      }
#endif /* STM32_I2C_USE_DMA == TRUE */

#if defined(STM32_I2C1_GLOBAL_NUMBER) || defined(__DOXYGEN__)
      nvicEnableVector(STM32_I2C1_GLOBAL_NUMBER, STM32_I2C_I2C1_IRQ_PRIORITY);
 80021e0:	f002 fb26 	bl	8004830 <nvicEnableVector>
 80021e4:	e7a2      	b.n	800212c <main+0x45c>
 80021e6:	4897      	ldr	r0, [pc, #604]	; (8002444 <main+0x774>)
 80021e8:	f000 fbc2 	bl	8002970 <chSysHalt>
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80021ec:	23a4      	movs	r3, #164	; 0xa4
    *startp++ = v;
 80021ee:	2255      	movs	r2, #85	; 0x55
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80021f0:	005b      	lsls	r3, r3, #1
    *startp++ = v;
 80021f2:	543a      	strb	r2, [r7, r0]
 80021f4:	3001      	adds	r0, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80021f6:	4298      	cmp	r0, r3
 80021f8:	d1fb      	bne.n	80021f2 <main+0x522>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80021fa:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80021fc:	f000 fbf8 	bl	80029f0 <_dbg_check_lock>
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8002200:	238e      	movs	r3, #142	; 0x8e
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002202:	1c3a      	adds	r2, r7, #0
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8002204:	005b      	lsls	r3, r3, #1
 8002206:	50ff      	str	r7, [r7, r3]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8002208:	32dc      	adds	r2, #220	; 0xdc
 800220a:	3b10      	subs	r3, #16
 800220c:	50fa      	str	r2, [r7, r3]
 800220e:	4a8e      	ldr	r2, [pc, #568]	; (8002448 <main+0x778>)
 8002210:	3b20      	subs	r3, #32
 8002212:	50fa      	str	r2, [r7, r3]
 8002214:	2300      	movs	r3, #0
 8002216:	4698      	mov	r8, r3
 8002218:	4642      	mov	r2, r8
 800221a:	33f0      	adds	r3, #240	; 0xf0
 800221c:	50fa      	str	r2, [r7, r3]
 800221e:	464a      	mov	r2, r9
 8002220:	330c      	adds	r3, #12
 8002222:	50fa      	str	r2, [r7, r3]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8002224:	2284      	movs	r2, #132	; 0x84
 8002226:	3b7c      	subs	r3, #124	; 0x7c
 8002228:	0052      	lsls	r2, r2, #1
 800222a:	50bb      	str	r3, [r7, r2]
  tp->state     = CH_STATE_WTSTART;
 800222c:	3a07      	subs	r2, #7
 800222e:	3aff      	subs	r2, #255	; 0xff
 8002230:	4691      	mov	r9, r2
 8002232:	4649      	mov	r1, r9
 8002234:	321f      	adds	r2, #31
 8002236:	32ff      	adds	r2, #255	; 0xff
 8002238:	54b9      	strb	r1, [r7, r2]
  tp->flags     = CH_FLAG_MODE_STATIC;
 800223a:	2222      	movs	r2, #34	; 0x22
 800223c:	4641      	mov	r1, r8
 800223e:	32ff      	adds	r2, #255	; 0xff
 8002240:	54b9      	strb	r1, [r7, r2]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8002242:	321b      	adds	r2, #27
 8002244:	50bb      	str	r3, [r7, r2]
  tp->mtxlist   = NULL;
 8002246:	4642      	mov	r2, r8
 8002248:	33b8      	adds	r3, #184	; 0xb8
 800224a:	50fa      	str	r2, [r7, r3]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 800224c:	3b04      	subs	r3, #4
 800224e:	50fa      	str	r2, [r7, r3]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8002250:	3201      	adds	r2, #1
 8002252:	3b12      	subs	r3, #18
 8002254:	54fa      	strb	r2, [r7, r3]
  tp->name      = name;
 8002256:	4a7d      	ldr	r2, [pc, #500]	; (800244c <main+0x77c>)
 8002258:	3b0a      	subs	r3, #10
 800225a:	50fa      	str	r2, [r7, r3]
  REG_INSERT(tp);
 800225c:	228a      	movs	r2, #138	; 0x8a
 800225e:	3b08      	subs	r3, #8
 8002260:	50fc      	str	r4, [r7, r3]
 8002262:	6963      	ldr	r3, [r4, #20]
 8002264:	0052      	lsls	r2, r2, #1
 8002266:	1c78      	adds	r0, r7, #1
 8002268:	50bb      	str	r3, [r7, r2]
 800226a:	30ff      	adds	r0, #255	; 0xff
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800226c:	1c3a      	adds	r2, r7, #0
 800226e:	6118      	str	r0, [r3, #16]
 8002270:	2394      	movs	r3, #148	; 0x94
 8002272:	3229      	adds	r2, #41	; 0x29
 8002274:	32ff      	adds	r2, #255	; 0xff
 8002276:	005b      	lsls	r3, r3, #1
 8002278:	50fa      	str	r2, [r7, r3]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800227a:	1c3b      	adds	r3, r7, #0
 800227c:	2296      	movs	r2, #150	; 0x96
 800227e:	332d      	adds	r3, #45	; 0x2d
 8002280:	33ff      	adds	r3, #255	; 0xff
 8002282:	0052      	lsls	r2, r2, #1
 8002284:	50bb      	str	r3, [r7, r2]
  tqp->prev = (thread_t *)tqp;
 8002286:	3204      	adds	r2, #4
 8002288:	50bb      	str	r3, [r7, r2]
 800228a:	6160      	str	r0, [r4, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 800228c:	f002 fc30 	bl	8004af0 <chSchWakeupS.constprop.22>
  chSysUnlock();
 8002290:	f000 fbc6 	bl	8002a20 <chSysUnlock.lto_priv.55>
 8002294:	b672      	cpsid	i
 8002296:	f000 fbab 	bl	80029f0 <_dbg_check_lock>
void adcStart(ADCDriver *adcp, const ADCConfig *config) {

  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 800229a:	7837      	ldrb	r7, [r6, #0]
 800229c:	1e7b      	subs	r3, r7, #1
 800229e:	2b01      	cmp	r3, #1
 80022a0:	d905      	bls.n	80022ae <main+0x5de>
 80022a2:	486b      	ldr	r0, [pc, #428]	; (8002450 <main+0x780>)
 80022a4:	f000 fb64 	bl	8002970 <chSysHalt>
      {
        i2cp->dmarx = dmaStreamAllocI(STM32_I2C_I2C1_RX_DMA_STREAM,
                                      STM32_I2C_I2C1_IRQ_PRIORITY,
                                      NULL,
                                      (void *)i2cp);
        osalDbgAssert(i2cp->dmarx != NULL, "unable to allocate stream");
 80022a8:	486a      	ldr	r0, [pc, #424]	; (8002454 <main+0x784>)
 80022aa:	f000 fb61 	bl	8002970 <chSysHalt>
                "invalid state");
  adcp->config = config;
 80022ae:	4643      	mov	r3, r8
 80022b0:	6073      	str	r3, [r6, #4]
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 80022b2:	2f01      	cmp	r7, #1
 80022b4:	d100      	bne.n	80022b8 <main+0x5e8>
 80022b6:	e178      	b.n	80025aa <main+0x8da>
  adc_lld_start(adcp);
  adcp->state = ADC_READY;
 80022b8:	2302      	movs	r3, #2
 80022ba:	7033      	strb	r3, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80022bc:	f000 fb70 	bl	80029a0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80022c0:	6823      	ldr	r3, [r4, #0]
 80022c2:	42a3      	cmp	r3, r4
 80022c4:	d005      	beq.n	80022d2 <main+0x602>
 80022c6:	69a2      	ldr	r2, [r4, #24]
 80022c8:	689b      	ldr	r3, [r3, #8]
 80022ca:	6892      	ldr	r2, [r2, #8]
 80022cc:	429a      	cmp	r2, r3
 80022ce:	d200      	bcs.n	80022d2 <main+0x602>
 80022d0:	e186      	b.n	80025e0 <main+0x910>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80022d2:	b662      	cpsie	i

  /*
   * Activates the ADC1 driver and the temperature sensor.
   */
   adcStart(&ADCD1, NULL);
   adcSTM32SetCCR(ADC_CCR_TSEN | ADC_CCR_VREFEN);
 80022d4:	22c0      	movs	r2, #192	; 0xc0
 80022d6:	4b60      	ldr	r3, [pc, #384]	; (8002458 <main+0x788>)
 80022d8:	0412      	lsls	r2, r2, #16
 80022da:	601a      	str	r2, [r3, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80022dc:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80022de:	f000 fb87 	bl	80029f0 <_dbg_check_lock>

  chThdSleepMilliseconds(1000);

  //turn on all LEDs
  palClearPad(GPIOA, GPIOA_LED1);
 80022e2:	2690      	movs	r6, #144	; 0x90
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 80022e4:	495d      	ldr	r1, [pc, #372]	; (800245c <main+0x78c>)
 80022e6:	2008      	movs	r0, #8
 80022e8:	f000 fde2 	bl	8002eb0 <chSchGoSleepTimeoutS>
 80022ec:	2520      	movs	r5, #32
 */
void chThdSleep(sysinterval_t time) {

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
 80022ee:	f000 fb97 	bl	8002a20 <chSysUnlock.lto_priv.55>
  palClearPad(GPIOA, GPIOA_LED2);
 80022f2:	2340      	movs	r3, #64	; 0x40
   adcSTM32SetCCR(ADC_CCR_TSEN | ADC_CCR_VREFEN);

  chThdSleepMilliseconds(1000);

  //turn on all LEDs
  palClearPad(GPIOA, GPIOA_LED1);
 80022f4:	05f6      	lsls	r6, r6, #23
 80022f6:	8375      	strh	r5, [r6, #26]
  palClearPad(GPIOA, GPIOA_LED2);
 80022f8:	469a      	mov	sl, r3
 80022fa:	8373      	strh	r3, [r6, #26]
  palClearPad(GPIOA, GPIOA_LED3);
 80022fc:	2380      	movs	r3, #128	; 0x80
 80022fe:	8373      	strh	r3, [r6, #26]
 8002300:	4699      	mov	r9, r3
  palClearPad(GPIOB, GPIOB_LED4);
 8002302:	2301      	movs	r3, #1
 8002304:	4f56      	ldr	r7, [pc, #344]	; (8002460 <main+0x790>)
 8002306:	4698      	mov	r8, r3
 8002308:	837b      	strh	r3, [r7, #26]
  palClearPad(GPIOB, GPIOB_LED5);
 800230a:	2302      	movs	r3, #2
 800230c:	837b      	strh	r3, [r7, #26]
 800230e:	b672      	cpsid	i
 8002310:	f000 fb6e 	bl	80029f0 <_dbg_check_lock>
 8002314:	4951      	ldr	r1, [pc, #324]	; (800245c <main+0x78c>)
 8002316:	2008      	movs	r0, #8
 8002318:	f000 fdca 	bl	8002eb0 <chSchGoSleepTimeoutS>
 800231c:	f000 fb80 	bl	8002a20 <chSysUnlock.lto_priv.55>

  chThdSleepMilliseconds(1000);
  //turn off all LEDs
  palSetPad(GPIOA, GPIOA_LED1);
  palSetPad(GPIOA, GPIOA_LED2);
 8002320:	4653      	mov	r3, sl
  palClearPad(GPIOB, GPIOB_LED4);
  palClearPad(GPIOB, GPIOB_LED5);

  chThdSleepMilliseconds(1000);
  //turn off all LEDs
  palSetPad(GPIOA, GPIOA_LED1);
 8002322:	8335      	strh	r5, [r6, #24]
  palSetPad(GPIOA, GPIOA_LED2);
 8002324:	8333      	strh	r3, [r6, #24]
  palSetPad(GPIOA, GPIOA_LED3);
 8002326:	464b      	mov	r3, r9
 8002328:	8333      	strh	r3, [r6, #24]
  palSetPad(GPIOB, GPIOB_LED4);
 800232a:	4643      	mov	r3, r8
 800232c:	833b      	strh	r3, [r7, #24]
  palSetPad(GPIOB, GPIOB_LED5);
 800232e:	2302      	movs	r3, #2
  i2cflags_t err;
  uint8_t tx_buffer[3];
  uint8_t CRCInput[3];

  //generate CRC
  CRCInput[0]=dev_address << 1;
 8002330:	212c      	movs	r1, #44	; 0x2c
 8002332:	833b      	strh	r3, [r7, #24]
 8002334:	2310      	movs	r3, #16
 8002336:	aa02      	add	r2, sp, #8
 8002338:	1852      	adds	r2, r2, r1
 800233a:	7013      	strb	r3, [r2, #0]
  CRCInput[1]=reg_address;
 800233c:	220b      	movs	r2, #11
 800233e:	4441      	add	r1, r8
 8002340:	ab02      	add	r3, sp, #8
 8002342:	185b      	adds	r3, r3, r1
  CRCInput[2]=data;
 8002344:	202e      	movs	r0, #46	; 0x2e
  uint8_t tx_buffer[3];
  uint8_t CRCInput[3];

  //generate CRC
  CRCInput[0]=dev_address << 1;
  CRCInput[1]=reg_address;
 8002346:	701a      	strb	r2, [r3, #0]
  CRCInput[2]=data;
 8002348:	2319      	movs	r3, #25
 800234a:	a902      	add	r1, sp, #8
 800234c:	1809      	adds	r1, r1, r0

  //generate data sequence
  tx_buffer[0] = reg_address;
 800234e:	ae0c      	add	r6, sp, #48	; 0x30
  uint8_t CRCInput[3];

  //generate CRC
  CRCInput[0]=dev_address << 1;
  CRCInput[1]=reg_address;
  CRCInput[2]=data;
 8002350:	700b      	strb	r3, [r1, #0]

  //generate data sequence
  tx_buffer[0] = reg_address;
  tx_buffer[1] = data;
 8002352:	7073      	strb	r3, [r6, #1]
  cellsVolt[4] = ADCtoVolt(cell_adc[4]);
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
 8002354:	2300      	movs	r3, #0
  CRCInput[0]=dev_address << 1;
  CRCInput[1]=reg_address;
  CRCInput[2]=data;

  //generate data sequence
  tx_buffer[0] = reg_address;
 8002356:	7032      	strb	r2, [r6, #0]
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8002358:	3827      	subs	r0, #39	; 0x27
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 800235a:	252c      	movs	r5, #44	; 0x2c
 800235c:	9901      	ldr	r1, [sp, #4]
 800235e:	aa02      	add	r2, sp, #8
 8002360:	1952      	adds	r2, r2, r5
 8002362:	5c52      	ldrb	r2, [r2, r1]
 8002364:	2708      	movs	r7, #8
 8002366:	4690      	mov	r8, r2
 8002368:	2180      	movs	r1, #128	; 0x80
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800236a:	1c02      	adds	r2, r0, #0
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800236c:	005d      	lsls	r5, r3, #1
 800236e:	b2ed      	uxtb	r5, r5
				crc ^= key;
 8002370:	406a      	eors	r2, r5
 8002372:	4691      	mov	r9, r2
 8002374:	b25a      	sxtb	r2, r3
 8002376:	2a00      	cmp	r2, #0
 8002378:	db53      	blt.n	8002422 <main+0x752>
 800237a:	1c2b      	adds	r3, r5, #0
 800237c:	4645      	mov	r5, r8
 800237e:	b2da      	uxtb	r2, r3
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8002380:	4042      	eors	r2, r0
 8002382:	420d      	tst	r5, r1
 8002384:	d000      	beq.n	8002388 <main+0x6b8>
 8002386:	1c13      	adds	r3, r2, #0
 8002388:	3f01      	subs	r7, #1
 800238a:	b2db      	uxtb	r3, r3
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 800238c:	0849      	lsrs	r1, r1, #1
 800238e:	2f00      	cmp	r7, #0
 8002390:	d1eb      	bne.n	800236a <main+0x69a>
 8002392:	9a01      	ldr	r2, [sp, #4]
 8002394:	3201      	adds	r2, #1
 8002396:	9201      	str	r2, [sp, #4]
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
 8002398:	2a03      	cmp	r2, #3
 800239a:	d1de      	bne.n	800235a <main+0x68a>
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800239c:	4658      	mov	r0, fp
  CRCInput[2]=data;

  //generate data sequence
  tx_buffer[0] = reg_address;
  tx_buffer[1] = data;
  tx_buffer[2] = CRC8(CRCInput, 3, 7);
 800239e:	70b3      	strb	r3, [r6, #2]
 80023a0:	f001 faa6 	bl	80038f0 <chMtxLock>

  //write data to i2c bus
  i2cAcquireBus(i2cp);
  msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, sizeof(tx_buffer),
 80023a4:	1c3a      	adds	r2, r7, #0
 80023a6:	1c3b      	adds	r3, r7, #0
 80023a8:	9901      	ldr	r1, [sp, #4]
 80023aa:	1c30      	adds	r0, r6, #0
 80023ac:	f002 faa8 	bl	8004900 <i2cMasterTransmitTimeout.constprop.30>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 80023b0:	4658      	mov	r0, fp
 80023b2:	f001 f92d 	bl	8003610 <chMtxUnlock>
  
  //Set CC_CFG to 0x19 as mentioned in datasheet
  msg = I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, CC_CFG, 0x19);

  //get gain for ADC-to-voltage conversion
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN1, &GAIN_buffer);
 80023b6:	a90d      	add	r1, sp, #52	; 0x34
 80023b8:	2050      	movs	r0, #80	; 0x50
 80023ba:	f003 f831 	bl	8005420 <I2CReadRegisterByteWithCRC.constprop.0>
  ADCGAIN_value = (GAIN_buffer &= 0b00001100) << 1;
 80023be:	222c      	movs	r2, #44	; 0x2c
 80023c0:	ab02      	add	r3, sp, #8
 80023c2:	189b      	adds	r3, r3, r2
 80023c4:	781a      	ldrb	r2, [r3, #0]
 80023c6:	230c      	movs	r3, #12
 80023c8:	212c      	movs	r1, #44	; 0x2c
 80023ca:	4013      	ands	r3, r2
 80023cc:	aa02      	add	r2, sp, #8
 80023ce:	1852      	adds	r2, r2, r1
 80023d0:	4d24      	ldr	r5, [pc, #144]	; (8002464 <main+0x794>)
 80023d2:	7013      	strb	r3, [r2, #0]
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN2, &GAIN_buffer);
 80023d4:	a90d      	add	r1, sp, #52	; 0x34
  //Set CC_CFG to 0x19 as mentioned in datasheet
  msg = I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, CC_CFG, 0x19);

  //get gain for ADC-to-voltage conversion
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN1, &GAIN_buffer);
  ADCGAIN_value = (GAIN_buffer &= 0b00001100) << 1;
 80023d6:	005b      	lsls	r3, r3, #1
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN2, &GAIN_buffer);
 80023d8:	2059      	movs	r0, #89	; 0x59
  //Set CC_CFG to 0x19 as mentioned in datasheet
  msg = I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, CC_CFG, 0x19);

  //get gain for ADC-to-voltage conversion
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN1, &GAIN_buffer);
  ADCGAIN_value = (GAIN_buffer &= 0b00001100) << 1;
 80023da:	702b      	strb	r3, [r5, #0]
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN2, &GAIN_buffer);
 80023dc:	f003 f820 	bl	8005420 <I2CReadRegisterByteWithCRC.constprop.0>
  ADCGAIN_value |= (GAIN_buffer &= 0b00011111);
 80023e0:	222c      	movs	r2, #44	; 0x2c
 80023e2:	ab02      	add	r3, sp, #8
 80023e4:	189b      	adds	r3, r3, r2
 80023e6:	781a      	ldrb	r2, [r3, #0]
 80023e8:	231f      	movs	r3, #31
 80023ea:	212c      	movs	r1, #44	; 0x2c
 80023ec:	401a      	ands	r2, r3
 80023ee:	ab02      	add	r3, sp, #8
 80023f0:	185b      	adds	r3, r3, r1
 80023f2:	701a      	strb	r2, [r3, #0]
 80023f4:	782b      	ldrb	r3, [r5, #0]
 80023f6:	4313      	orrs	r3, r2
 80023f8:	702b      	strb	r3, [r5, #0]
  else
    return raw;
}

int ADCGAINtoDec(uint8_t ADCGAIN_hex) {
  if (ADCGAIN_hex > 0x1F)
 80023fa:	2b1f      	cmp	r3, #31
 80023fc:	d813      	bhi.n	8002426 <main+0x756>
    return 396;
  else
    return ADCGAIN_hex + 365;
 80023fe:	336e      	adds	r3, #110	; 0x6e
 8002400:	33ff      	adds	r3, #255	; 0xff
  //get gain for ADC-to-voltage conversion
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN1, &GAIN_buffer);
  ADCGAIN_value = (GAIN_buffer &= 0b00001100) << 1;
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN2, &GAIN_buffer);
  ADCGAIN_value |= (GAIN_buffer &= 0b00011111);
  GAIN = ADCGAINtoDec(ADCGAIN_value);
 8002402:	4a19      	ldr	r2, [pc, #100]	; (8002468 <main+0x798>)

  //get offet for ADC-to-voltage conversion
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCOFFSET, &ADCOFFSET_value);
 8002404:	4919      	ldr	r1, [pc, #100]	; (800246c <main+0x79c>)
 8002406:	2051      	movs	r0, #81	; 0x51
  //get gain for ADC-to-voltage conversion
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN1, &GAIN_buffer);
  ADCGAIN_value = (GAIN_buffer &= 0b00001100) << 1;
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN2, &GAIN_buffer);
  ADCGAIN_value |= (GAIN_buffer &= 0b00011111);
  GAIN = ADCGAINtoDec(ADCGAIN_value);
 8002408:	6013      	str	r3, [r2, #0]

  //get offet for ADC-to-voltage conversion
  msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCOFFSET, &ADCOFFSET_value);
 800240a:	f003 f809 	bl	8005420 <I2CReadRegisterByteWithCRC.constprop.0>
 800240e:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002410:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002412:	2b00      	cmp	r3, #0
 8002414:	d102      	bne.n	800241c <main+0x74c>
 8002416:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002418:	2b00      	cmp	r3, #0
 800241a:	d02b      	beq.n	8002474 <main+0x7a4>
    chSysHalt("SV#4");
 800241c:	4814      	ldr	r0, [pc, #80]	; (8002470 <main+0x7a0>)
 800241e:	f000 faa7 	bl	8002970 <chSysHalt>
 8002422:	464b      	mov	r3, r9
 8002424:	e7aa      	b.n	800237c <main+0x6ac>
    return raw;
}

int ADCGAINtoDec(uint8_t ADCGAIN_hex) {
  if (ADCGAIN_hex > 0x1F)
    return 396;
 8002426:	23c6      	movs	r3, #198	; 0xc6
 8002428:	005b      	lsls	r3, r3, #1
 800242a:	e7ea      	b.n	8002402 <main+0x732>
 800242c:	08005764 	.word	0x08005764
 8002430:	0000c090 	.word	0x0000c090
 8002434:	200004e0 	.word	0x200004e0
 8002438:	08005840 	.word	0x08005840
 800243c:	40021000 	.word	0x40021000
 8002440:	ffdfffff 	.word	0xffdfffff
 8002444:	08005b0c 	.word	0x08005b0c
 8002448:	08003311 	.word	0x08003311
 800244c:	08005800 	.word	0x08005800
 8002450:	08005834 	.word	0x08005834
 8002454:	08005818 	.word	0x08005818
 8002458:	40012708 	.word	0x40012708
 800245c:	00002710 	.word	0x00002710
 8002460:	48000400 	.word	0x48000400
 8002464:	20000454 	.word	0x20000454
 8002468:	200004dc 	.word	0x200004dc
 800246c:	200004d8 	.word	0x200004d8
 8002470:	08005808 	.word	0x08005808
 8002474:	21fa      	movs	r1, #250	; 0xfa
  }
  _dbg_enter_lock();
 8002476:	3301      	adds	r3, #1
 8002478:	2008      	movs	r0, #8
 800247a:	0089      	lsls	r1, r1, #2
 800247c:	6363      	str	r3, [r4, #52]	; 0x34
 800247e:	f000 fd17 	bl	8002eb0 <chSchGoSleepTimeoutS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002482:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002484:	2b00      	cmp	r3, #0
 8002486:	d000      	beq.n	800248a <main+0x7ba>
 8002488:	e08c      	b.n	80025a4 <main+0x8d4>
 800248a:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800248c:	2a00      	cmp	r2, #0
 800248e:	dc00      	bgt.n	8002492 <main+0x7c2>
 8002490:	e088      	b.n	80025a4 <main+0x8d4>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8002492:	6363      	str	r3, [r4, #52]	; 0x34

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002494:	6823      	ldr	r3, [r4, #0]
 8002496:	42a3      	cmp	r3, r4
 8002498:	d005      	beq.n	80024a6 <main+0x7d6>
 800249a:	69a2      	ldr	r2, [r4, #24]
 800249c:	689b      	ldr	r3, [r3, #8]
 800249e:	6892      	ldr	r2, [r2, #8]
 80024a0:	429a      	cmp	r2, r3
 80024a2:	d200      	bcs.n	80024a6 <main+0x7d6>
 80024a4:	e0a2      	b.n	80025ec <main+0x91c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80024a6:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80024a8:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80024aa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80024ac:	2b00      	cmp	r3, #0
 80024ae:	d1b5      	bne.n	800241c <main+0x74c>
 80024b0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80024b2:	2b00      	cmp	r3, #0
 80024b4:	d1b2      	bne.n	800241c <main+0x74c>
 80024b6:	21fa      	movs	r1, #250	; 0xfa
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80024b8:	3301      	adds	r3, #1
 80024ba:	2008      	movs	r0, #8
 80024bc:	0089      	lsls	r1, r1, #2
 80024be:	6363      	str	r3, [r4, #52]	; 0x34
 80024c0:	f000 fcf6 	bl	8002eb0 <chSchGoSleepTimeoutS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80024c4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80024c6:	2b00      	cmp	r3, #0
 80024c8:	d16c      	bne.n	80025a4 <main+0x8d4>
 80024ca:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80024cc:	2a00      	cmp	r2, #0
 80024ce:	dd69      	ble.n	80025a4 <main+0x8d4>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80024d0:	6363      	str	r3, [r4, #52]	; 0x34
 80024d2:	6823      	ldr	r3, [r4, #0]
 80024d4:	42a3      	cmp	r3, r4
 80024d6:	d005      	beq.n	80024e4 <main+0x814>
 80024d8:	69a2      	ldr	r2, [r4, #24]
 80024da:	689b      	ldr	r3, [r3, #8]
 80024dc:	6892      	ldr	r2, [r2, #8]
 80024de:	429a      	cmp	r2, r3
 80024e0:	d200      	bcs.n	80024e4 <main+0x814>
 80024e2:	e083      	b.n	80025ec <main+0x91c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80024e4:	b662      	cpsie	i
    volatile float cellsVolt[5];
    volatile float battery_percentage;

    volatile uint16_t ucc_adc;
    volatile int16_t test_battery_adc;
    volatile bool cc_ok = false;
 80024e6:	ab02      	add	r3, sp, #8
 80024e8:	1dda      	adds	r2, r3, #7
 80024ea:	2300      	movs	r3, #0
}

msg_t I2CReadRegisterWordWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint16_t *data) {
  msg_t msg;
  i2cflags_t err;
  uint8_t tx_buffer[1] = {reg_address};
 80024ec:	ae03      	add	r6, sp, #12
 80024ee:	7013      	strb	r3, [r2, #0]
 80024f0:	332c      	adds	r3, #44	; 0x2c
 80024f2:	9201      	str	r2, [sp, #4]
 80024f4:	7033      	strb	r3, [r6, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80024f6:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80024f8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80024fa:	2b00      	cmp	r3, #0
 80024fc:	d18e      	bne.n	800241c <main+0x74c>
 80024fe:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002500:	2b00      	cmp	r3, #0
 8002502:	d18b      	bne.n	800241c <main+0x74c>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8002504:	3301      	adds	r3, #1
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8002506:	4658      	mov	r0, fp
 8002508:	6363      	str	r3, [r4, #52]	; 0x34
 800250a:	f001 f941 	bl	8003790 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800250e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002510:	2b00      	cmp	r3, #0
 8002512:	d147      	bne.n	80025a4 <main+0x8d4>
 8002514:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002516:	2a00      	cmp	r2, #0
 8002518:	dd44      	ble.n	80025a4 <main+0x8d4>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800251a:	6363      	str	r3, [r4, #52]	; 0x34
 800251c:	6823      	ldr	r3, [r4, #0]
 800251e:	42a3      	cmp	r3, r4
 8002520:	d004      	beq.n	800252c <main+0x85c>
 8002522:	69a2      	ldr	r2, [r4, #24]
 8002524:	689b      	ldr	r3, [r3, #8]
 8002526:	6892      	ldr	r2, [r2, #8]
 8002528:	429a      	cmp	r2, r3
 800252a:	d338      	bcc.n	800259e <main+0x8ce>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800252c:	b662      	cpsie	i
  volatile uint8_t CRCInput[2];
  volatile uint8_t crc[2];

  //read data from i2c bus
  i2cAcquireBus(i2cp);
  msg = i2cMasterTransmitTimeout(&I2CD1, addr_bq76920, tx_buffer, 1,
 800252e:	2101      	movs	r1, #1
 8002530:	aa0d      	add	r2, sp, #52	; 0x34
 8002532:	2304      	movs	r3, #4
 8002534:	1c30      	adds	r0, r6, #0
 8002536:	f002 f9e3 	bl	8004900 <i2cMasterTransmitTimeout.constprop.30>
 800253a:	4658      	mov	r0, fp
 800253c:	f001 f868 	bl	8003610 <chMtxUnlock>
  i2cReleaseBus(i2cp);
  if (msg != MSG_OK)
    err = i2cGetErrors(i2cp);

  //CRC check for first byte
  CRCInput[0] = (addr_bq76920 << 1) + 1;
 8002540:	2311      	movs	r3, #17
  CRCInput[1] = rx_buffer[0];
 8002542:	222c      	movs	r2, #44	; 0x2c
  i2cReleaseBus(i2cp);
  if (msg != MSG_OK)
    err = i2cGetErrors(i2cp);

  //CRC check for first byte
  CRCInput[0] = (addr_bq76920 << 1) + 1;
 8002544:	ae04      	add	r6, sp, #16
 8002546:	7033      	strb	r3, [r6, #0]
  CRCInput[1] = rx_buffer[0];
 8002548:	ab02      	add	r3, sp, #8
 800254a:	189b      	adds	r3, r3, r2
 800254c:	7818      	ldrb	r0, [r3, #0]
 800254e:	2100      	movs	r1, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8002550:	2307      	movs	r3, #7
  cellsVolt[4] = ADCtoVolt(cell_adc[4]);
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
 8002552:	1c0a      	adds	r2, r1, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8002554:	469c      	mov	ip, r3
 8002556:	4680      	mov	r8, r0
  if (msg != MSG_OK)
    err = i2cGetErrors(i2cp);

  //CRC check for first byte
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
 8002558:	7070      	strb	r0, [r6, #1]
				crc ^= key;
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 800255a:	2308      	movs	r3, #8
 800255c:	5c70      	ldrb	r0, [r6, r1]
 800255e:	4689      	mov	r9, r1
 8002560:	2780      	movs	r7, #128	; 0x80
 8002562:	1c19      	adds	r1, r3, #0
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8002564:	0053      	lsls	r3, r2, #1
 8002566:	b2db      	uxtb	r3, r3
 8002568:	469a      	mov	sl, r3
				crc ^= key;
 800256a:	4663      	mov	r3, ip
 800256c:	4655      	mov	r5, sl
 800256e:	b252      	sxtb	r2, r2
 8002570:	406b      	eors	r3, r5
 8002572:	2a00      	cmp	r2, #0
 8002574:	db11      	blt.n	800259a <main+0x8ca>
 8002576:	4652      	mov	r2, sl
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8002578:	4665      	mov	r5, ip
 800257a:	b2d3      	uxtb	r3, r2
 800257c:	406b      	eors	r3, r5
 800257e:	4238      	tst	r0, r7
 8002580:	d000      	beq.n	8002584 <main+0x8b4>
 8002582:	1c1a      	adds	r2, r3, #0
 8002584:	3901      	subs	r1, #1
 8002586:	b2d2      	uxtb	r2, r2
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 8002588:	087f      	lsrs	r7, r7, #1
 800258a:	2900      	cmp	r1, #0
 800258c:	d1ea      	bne.n	8002564 <main+0x894>
 800258e:	1c0b      	adds	r3, r1, #0
 8002590:	4649      	mov	r1, r9
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
 8002592:	2901      	cmp	r1, #1
 8002594:	d02d      	beq.n	80025f2 <main+0x922>
 8002596:	2101      	movs	r1, #1
 8002598:	e7df      	b.n	800255a <main+0x88a>
 800259a:	1c1a      	adds	r2, r3, #0
 800259c:	e7ec      	b.n	8002578 <main+0x8a8>
 800259e:	48d1      	ldr	r0, [pc, #836]	; (80028e4 <main+0xc14>)
 80025a0:	f000 f9e6 	bl	8002970 <chSysHalt>
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 80025a4:	48d0      	ldr	r0, [pc, #832]	; (80028e8 <main+0xc18>)
 80025a6:	f000 f9e3 	bl	8002970 <chSysHalt>
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
 80025aa:	4640      	mov	r0, r8
 80025ac:	4649      	mov	r1, r9
 80025ae:	4acf      	ldr	r2, [pc, #828]	; (80028ec <main+0xc1c>)
 80025b0:	1c33      	adds	r3, r6, #0
 80025b2:	f001 fd2d 	bl	8004010 <dmaStreamAllocI>
 80025b6:	62f0      	str	r0, [r6, #44]	; 0x2c
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 80025b8:	2800      	cmp	r0, #0
 80025ba:	d014      	beq.n	80025e6 <main+0x916>
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(true);
 80025bc:	2180      	movs	r1, #128	; 0x80
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 80025be:	6843      	ldr	r3, [r0, #4]
 80025c0:	4acb      	ldr	r2, [pc, #812]	; (80028f0 <main+0xc20>)
      rccEnableADC1(true);
 80025c2:	0089      	lsls	r1, r1, #2
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 80025c4:	609a      	str	r2, [r3, #8]
      rccEnableADC1(true);
 80025c6:	4bcb      	ldr	r3, [pc, #812]	; (80028f4 <main+0xc24>)
 80025c8:	699a      	ldr	r2, [r3, #24]
 80025ca:	430a      	orrs	r2, r1
 80025cc:	619a      	str	r2, [r3, #24]

      /* Clock settings.*/
      adcp->adc->CFGR2 = STM32_ADC_ADC1_CKMODE;
 80025ce:	4642      	mov	r2, r8
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(true);
 80025d0:	699b      	ldr	r3, [r3, #24]

      /* Clock settings.*/
      adcp->adc->CFGR2 = STM32_ADC_ADC1_CKMODE;
 80025d2:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 80025d4:	611a      	str	r2, [r3, #16]
    }
#endif /* STM32_ADC_USE_ADC1 */

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR = ADC_CR_ADEN;
 80025d6:	609f      	str	r7, [r3, #8]
    while (!(adcp->adc->ISR & ADC_ISR_ADRDY))
 80025d8:	681a      	ldr	r2, [r3, #0]
 80025da:	423a      	tst	r2, r7
 80025dc:	d0fc      	beq.n	80025d8 <main+0x908>
 80025de:	e66b      	b.n	80022b8 <main+0x5e8>
 80025e0:	48c5      	ldr	r0, [pc, #788]	; (80028f8 <main+0xc28>)
 80025e2:	f000 f9c5 	bl	8002970 <chSysHalt>
    if (&ADCD1 == adcp) {
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 80025e6:	48c5      	ldr	r0, [pc, #788]	; (80028fc <main+0xc2c>)
 80025e8:	f000 f9c2 	bl	8002970 <chSysHalt>
 80025ec:	48c4      	ldr	r0, [pc, #784]	; (8002900 <main+0xc30>)
 80025ee:	f000 f9bf 	bl	8002970 <chSysHalt>
  //CRC check for first byte
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
  crc[0] = CRC8(CRCInput, 2, 7) ;
  //CRC check for second byte
  CRCInput[0] = rx_buffer[2];
 80025f2:	252e      	movs	r5, #46	; 0x2e
    err = i2cGetErrors(i2cp);

  //CRC check for first byte
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
  crc[0] = CRC8(CRCInput, 2, 7) ;
 80025f4:	a905      	add	r1, sp, #20
 80025f6:	700a      	strb	r2, [r1, #0]
  //CRC check for second byte
  CRCInput[0] = rx_buffer[2];
 80025f8:	aa02      	add	r2, sp, #8
 80025fa:	1952      	adds	r2, r2, r5
 80025fc:	7812      	ldrb	r2, [r2, #0]
 80025fe:	4640      	mov	r0, r8
 8002600:	7032      	strb	r2, [r6, #0]
				crc ^= key;
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 8002602:	7835      	ldrb	r5, [r6, #0]
 8002604:	2708      	movs	r7, #8
 8002606:	46a8      	mov	r8, r5
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8002608:	2507      	movs	r5, #7
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 800260a:	2680      	movs	r6, #128	; 0x80
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800260c:	46ac      	mov	ip, r5
 800260e:	4691      	mov	r9, r2
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8002610:	005a      	lsls	r2, r3, #1
 8002612:	b2d2      	uxtb	r2, r2
 8002614:	4692      	mov	sl, r2
				crc ^= key;
 8002616:	4662      	mov	r2, ip
 8002618:	4655      	mov	r5, sl
 800261a:	406a      	eors	r2, r5
 800261c:	061b      	lsls	r3, r3, #24
 800261e:	d500      	bpl.n	8002622 <main+0x952>
 8002620:	e156      	b.n	80028d0 <main+0xc00>
 8002622:	4653      	mov	r3, sl
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8002624:	4665      	mov	r5, ip
 8002626:	b2da      	uxtb	r2, r3
 8002628:	406a      	eors	r2, r5
 800262a:	4645      	mov	r5, r8
 800262c:	4235      	tst	r5, r6
 800262e:	d000      	beq.n	8002632 <main+0x962>
 8002630:	1c13      	adds	r3, r2, #0
 8002632:	3f01      	subs	r7, #1
 8002634:	b2db      	uxtb	r3, r3
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 8002636:	0876      	lsrs	r6, r6, #1
 8002638:	2f00      	cmp	r7, #0
 800263a:	d1e9      	bne.n	8002610 <main+0x940>
  CRCInput[1] = rx_buffer[0];
  crc[0] = CRC8(CRCInput, 2, 7) ;
  //CRC check for second byte
  CRCInput[0] = rx_buffer[2];
  crc[1] = CRC8(CRCInput, 1, 7);
  if (crc[0] != rx_buffer[1] || crc[1]!= rx_buffer[3] )
 800263c:	262d      	movs	r6, #45	; 0x2d
 800263e:	ad02      	add	r5, sp, #8
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
  crc[0] = CRC8(CRCInput, 2, 7) ;
  //CRC check for second byte
  CRCInput[0] = rx_buffer[2];
  crc[1] = CRC8(CRCInput, 1, 7);
 8002640:	704b      	strb	r3, [r1, #1]
  if (crc[0] != rx_buffer[1] || crc[1]!= rx_buffer[3] )
 8002642:	19ad      	adds	r5, r5, r6
 8002644:	780b      	ldrb	r3, [r1, #0]
 8002646:	782e      	ldrb	r6, [r5, #0]
 8002648:	464a      	mov	r2, r9
 800264a:	429e      	cmp	r6, r3
 800264c:	d10d      	bne.n	800266a <main+0x99a>
 800264e:	252f      	movs	r5, #47	; 0x2f
 8002650:	784b      	ldrb	r3, [r1, #1]
 8002652:	a902      	add	r1, sp, #8
 8002654:	1949      	adds	r1, r1, r5
 8002656:	7809      	ldrb	r1, [r1, #0]
 8002658:	4299      	cmp	r1, r3
 800265a:	d106      	bne.n	800266a <main+0x99a>
    return -1;
  else 
    *data = (rx_buffer[0]<<8) + rx_buffer[2];
 800265c:	a902      	add	r1, sp, #8
 800265e:	230e      	movs	r3, #14
 8002660:	468c      	mov	ip, r1
 8002662:	0200      	lsls	r0, r0, #8
 8002664:	1882      	adds	r2, r0, r2
 8002666:	4463      	add	r3, ip
 8002668:	801a      	strh	r2, [r3, #0]
}

void GetCellsVolt(float cellsVolt[]) {
  msg_t msg;
  uint16_t cell_adc[5];
  msg = I2CReadRegisterWordWithCRC(&I2CD1, addr_bq76920, VC1_HI, &cell_adc[0]);
 800266a:	a90d      	add	r1, sp, #52	; 0x34
 800266c:	200c      	movs	r0, #12
 800266e:	f002 fab7 	bl	8004be0 <I2CReadRegisterWordWithCRC.constprop.8>
  msg = I2CReadRegisterWordWithCRC(&I2CD1, addr_bq76920, VC2_HI, &cell_adc[1]);
 8002672:	ab02      	add	r3, sp, #8
 8002674:	469c      	mov	ip, r3
 8002676:	212e      	movs	r1, #46	; 0x2e
 8002678:	200e      	movs	r0, #14
 800267a:	4461      	add	r1, ip
 800267c:	f002 fab0 	bl	8004be0 <I2CReadRegisterWordWithCRC.constprop.8>
  msg = I2CReadRegisterWordWithCRC(&I2CD1, addr_bq76920, VC3_HI, &cell_adc[2]);
 8002680:	a90e      	add	r1, sp, #56	; 0x38
 8002682:	2010      	movs	r0, #16
 8002684:	f002 faac 	bl	8004be0 <I2CReadRegisterWordWithCRC.constprop.8>
  msg = I2CReadRegisterWordWithCRC(&I2CD1, addr_bq76920, VC4_HI, &cell_adc[3]);
 8002688:	ab02      	add	r3, sp, #8
 800268a:	469c      	mov	ip, r3
 800268c:	2132      	movs	r1, #50	; 0x32
 800268e:	2012      	movs	r0, #18
 8002690:	4461      	add	r1, ip
 8002692:	f002 faa5 	bl	8004be0 <I2CReadRegisterWordWithCRC.constprop.8>
  msg = I2CReadRegisterWordWithCRC(&I2CD1, addr_bq76920, VC5_HI, &cell_adc[4]);
 8002696:	a90f      	add	r1, sp, #60	; 0x3c
 8002698:	2014      	movs	r0, #20
 800269a:	f002 faa1 	bl	8004be0 <I2CReadRegisterWordWithCRC.constprop.8>
  i2cflags_t err;
  uint8_t tx_buffer[3];
  uint8_t CRCInput[3];

  //generate CRC
  CRCInput[0]=dev_address << 1;
 800269e:	2310      	movs	r3, #16
 80026a0:	aa08      	add	r2, sp, #32
  CRCInput[1]=reg_address;
 80026a2:	2105      	movs	r1, #5
  CRCInput[2]=data;

  //generate data sequence
  tx_buffer[0] = reg_address;
 80026a4:	ae07      	add	r6, sp, #28
  i2cflags_t err;
  uint8_t tx_buffer[3];
  uint8_t CRCInput[3];

  //generate CRC
  CRCInput[0]=dev_address << 1;
 80026a6:	7013      	strb	r3, [r2, #0]
  CRCInput[1]=reg_address;
  CRCInput[2]=data;
 80026a8:	3332      	adds	r3, #50	; 0x32
 80026aa:	7093      	strb	r3, [r2, #2]

  //generate data sequence
  tx_buffer[0] = reg_address;
  tx_buffer[1] = data;
 80026ac:	7073      	strb	r3, [r6, #1]
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80026ae:	2007      	movs	r0, #7
  cellsVolt[4] = ADCtoVolt(cell_adc[4]);
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
 80026b0:	2300      	movs	r3, #0
  uint8_t tx_buffer[3];
  uint8_t CRCInput[3];

  //generate CRC
  CRCInput[0]=dev_address << 1;
  CRCInput[1]=reg_address;
 80026b2:	7051      	strb	r1, [r2, #1]
  CRCInput[2]=data;

  //generate data sequence
  tx_buffer[0] = reg_address;
 80026b4:	7031      	strb	r1, [r6, #0]
				crc ^= key;
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 80026b6:	5dd1      	ldrb	r1, [r2, r7]
 80026b8:	2580      	movs	r5, #128	; 0x80
 80026ba:	4688      	mov	r8, r1
 80026bc:	2108      	movs	r1, #8
 80026be:	46b9      	mov	r9, r7
 80026c0:	46ac      	mov	ip, r5
 80026c2:	1c0f      	adds	r7, r1, #0
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80026c4:	0059      	lsls	r1, r3, #1
 80026c6:	b2c9      	uxtb	r1, r1
 80026c8:	b25b      	sxtb	r3, r3
 80026ca:	468a      	mov	sl, r1
				crc ^= key;
 80026cc:	4041      	eors	r1, r0
 80026ce:	2b00      	cmp	r3, #0
 80026d0:	da00      	bge.n	80026d4 <main+0xa04>
 80026d2:	e0ff      	b.n	80028d4 <main+0xc04>
 80026d4:	4653      	mov	r3, sl
 80026d6:	b2d9      	uxtb	r1, r3
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80026d8:	4041      	eors	r1, r0
 80026da:	468a      	mov	sl, r1
 80026dc:	4645      	mov	r5, r8
 80026de:	4661      	mov	r1, ip
 80026e0:	420d      	tst	r5, r1
 80026e2:	d000      	beq.n	80026e6 <main+0xa16>
 80026e4:	4653      	mov	r3, sl
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 80026e6:	4661      	mov	r1, ip
 80026e8:	3f01      	subs	r7, #1
 80026ea:	0849      	lsrs	r1, r1, #1
 80026ec:	b2db      	uxtb	r3, r3
 80026ee:	468c      	mov	ip, r1
 80026f0:	2f00      	cmp	r7, #0
 80026f2:	d1e7      	bne.n	80026c4 <main+0x9f4>
 80026f4:	1c39      	adds	r1, r7, #0
 80026f6:	464f      	mov	r7, r9
 80026f8:	3701      	adds	r7, #1
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
 80026fa:	2f03      	cmp	r7, #3
 80026fc:	d1db      	bne.n	80026b6 <main+0x9e6>
 80026fe:	4688      	mov	r8, r1
  CRCInput[2]=data;

  //generate data sequence
  tx_buffer[0] = reg_address;
  tx_buffer[1] = data;
  tx_buffer[2] = CRC8(CRCInput, 3, 7);
 8002700:	70b3      	strb	r3, [r6, #2]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002702:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002704:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002706:	2b00      	cmp	r3, #0
 8002708:	d000      	beq.n	800270c <main+0xa3c>
 800270a:	e687      	b.n	800241c <main+0x74c>
 800270c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800270e:	2b00      	cmp	r3, #0
 8002710:	d000      	beq.n	8002714 <main+0xa44>
 8002712:	e683      	b.n	800241c <main+0x74c>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8002714:	3301      	adds	r3, #1
 8002716:	4658      	mov	r0, fp
 8002718:	6363      	str	r3, [r4, #52]	; 0x34
 800271a:	f001 f839 	bl	8003790 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800271e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002720:	2b00      	cmp	r3, #0
 8002722:	d000      	beq.n	8002726 <main+0xa56>
 8002724:	e73e      	b.n	80025a4 <main+0x8d4>
 8002726:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002728:	2b00      	cmp	r3, #0
 800272a:	dc00      	bgt.n	800272e <main+0xa5e>
 800272c:	e73a      	b.n	80025a4 <main+0x8d4>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800272e:	4643      	mov	r3, r8
 8002730:	6363      	str	r3, [r4, #52]	; 0x34
 8002732:	6823      	ldr	r3, [r4, #0]
 8002734:	42a3      	cmp	r3, r4
 8002736:	d005      	beq.n	8002744 <main+0xa74>
 8002738:	69a2      	ldr	r2, [r4, #24]
 800273a:	689b      	ldr	r3, [r3, #8]
 800273c:	6892      	ldr	r2, [r2, #8]
 800273e:	429a      	cmp	r2, r3
 8002740:	d200      	bcs.n	8002744 <main+0xa74>
 8002742:	e72c      	b.n	800259e <main+0x8ce>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002744:	b662      	cpsie	i

  //write data to i2c bus
  i2cAcquireBus(i2cp);
  msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, sizeof(tx_buffer),
 8002746:	2200      	movs	r2, #0
 8002748:	2103      	movs	r1, #3
 800274a:	1c13      	adds	r3, r2, #0
 800274c:	1c30      	adds	r0, r6, #0
 800274e:	f002 f8d7 	bl	8004900 <i2cMasterTransmitTimeout.constprop.30>
 8002752:	4658      	mov	r0, fp
 8002754:	f000 ff5c 	bl	8003610 <chMtxUnlock>
    uint8_t enableCCincontinuous = 0|(1<<CC_EN);
    enableCCincontinuous|=(1<<DSG_ON);
    enableCCincontinuous&=0xff|(0<<CHG_ON);
    I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, SYS_CTRL2, enableCCincontinuous);

    if (palReadPad(GPIOA, GPIOA_ALERT))
 8002758:	2390      	movs	r3, #144	; 0x90
 800275a:	05db      	lsls	r3, r3, #23
 800275c:	691a      	ldr	r2, [r3, #16]
 800275e:	2310      	movs	r3, #16
 8002760:	4013      	ands	r3, r2
 8002762:	d100      	bne.n	8002766 <main+0xa96>
 8002764:	e0ba      	b.n	80028dc <main+0xc0c>
      cc_ok = true;
 8002766:	2301      	movs	r3, #1
 8002768:	9a01      	ldr	r2, [sp, #4]
 800276a:	7013      	strb	r3, [r2, #0]
    else
      cc_ok = false;

    if(cc_ok)
 800276c:	9b01      	ldr	r3, [sp, #4]
 800276e:	781b      	ldrb	r3, [r3, #0]
 8002770:	2b00      	cmp	r3, #0
 8002772:	d100      	bne.n	8002776 <main+0xaa6>
 8002774:	e698      	b.n	80024a8 <main+0x7d8>
    {
      msg = I2CReadRegisterWordWithCRC(&I2CD1, addr_bq76920, CC_HI, &ucc_adc);
 8002776:	ae06      	add	r6, sp, #24
 8002778:	1c30      	adds	r0, r6, #0
 800277a:	f002 fc41 	bl	8005000 <I2CReadRegisterWordWithCRC.constprop.7>
      test_battery_adc = ucc_adc;
 800277e:	a902      	add	r1, sp, #8
 8002780:	468c      	mov	ip, r1
 8002782:	2212      	movs	r2, #18
 8002784:	8833      	ldrh	r3, [r6, #0]
 8002786:	4462      	add	r2, ip
 8002788:	8013      	strh	r3, [r2, #0]
  i2cflags_t err;
  uint8_t tx_buffer[3];
  uint8_t CRCInput[3];

  //generate CRC
  CRCInput[0]=dev_address << 1;
 800278a:	1c0b      	adds	r3, r1, #0
 800278c:	212c      	movs	r1, #44	; 0x2c
 800278e:	2210      	movs	r2, #16
 8002790:	185b      	adds	r3, r3, r1
  CRCInput[1]=reg_address;
 8002792:	202d      	movs	r0, #45	; 0x2d
 8002794:	4661      	mov	r1, ip
  i2cflags_t err;
  uint8_t tx_buffer[3];
  uint8_t CRCInput[3];

  //generate CRC
  CRCInput[0]=dev_address << 1;
 8002796:	701a      	strb	r2, [r3, #0]
  CRCInput[1]=reg_address;
 8002798:	2300      	movs	r3, #0
 800279a:	1809      	adds	r1, r1, r0
 800279c:	700b      	strb	r3, [r1, #0]
  CRCInput[2]=data;
 800279e:	4661      	mov	r1, ip
 80027a0:	3001      	adds	r0, #1
 80027a2:	1809      	adds	r1, r1, r0
 80027a4:	700a      	strb	r2, [r1, #0]
 80027a6:	4641      	mov	r1, r8

  //generate data sequence
  tx_buffer[0] = reg_address;
 80027a8:	ae09      	add	r6, sp, #36	; 0x24
 80027aa:	7033      	strb	r3, [r6, #0]
  tx_buffer[1] = data;
 80027ac:	7072      	strb	r2, [r6, #1]
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80027ae:	3827      	subs	r0, #39	; 0x27
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 80027b0:	252c      	movs	r5, #44	; 0x2c
 80027b2:	aa02      	add	r2, sp, #8
 80027b4:	1952      	adds	r2, r2, r5
 80027b6:	5c52      	ldrb	r2, [r2, r1]
 80027b8:	2708      	movs	r7, #8
 80027ba:	4690      	mov	r8, r2
 80027bc:	2280      	movs	r2, #128	; 0x80
 80027be:	4694      	mov	ip, r2
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80027c0:	005a      	lsls	r2, r3, #1
 80027c2:	b2d2      	uxtb	r2, r2
 80027c4:	4691      	mov	r9, r2
				crc ^= key;
 80027c6:	4042      	eors	r2, r0
 80027c8:	4692      	mov	sl, r2
 80027ca:	b25a      	sxtb	r2, r3
 80027cc:	2a00      	cmp	r2, #0
 80027ce:	da00      	bge.n	80027d2 <main+0xb02>
 80027d0:	e082      	b.n	80028d8 <main+0xc08>
 80027d2:	464b      	mov	r3, r9
 80027d4:	b2da      	uxtb	r2, r3
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80027d6:	4042      	eors	r2, r0
 80027d8:	4691      	mov	r9, r2
 80027da:	4645      	mov	r5, r8
 80027dc:	4662      	mov	r2, ip
 80027de:	4215      	tst	r5, r2
 80027e0:	d000      	beq.n	80027e4 <main+0xb14>
 80027e2:	464b      	mov	r3, r9
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 80027e4:	4662      	mov	r2, ip
 80027e6:	3f01      	subs	r7, #1
 80027e8:	0852      	lsrs	r2, r2, #1
 80027ea:	b2db      	uxtb	r3, r3
 80027ec:	4694      	mov	ip, r2
 80027ee:	2f00      	cmp	r7, #0
 80027f0:	d1e6      	bne.n	80027c0 <main+0xaf0>
 80027f2:	3101      	adds	r1, #1
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
 80027f4:	2903      	cmp	r1, #3
 80027f6:	d1db      	bne.n	80027b0 <main+0xae0>
  CRCInput[2]=data;

  //generate data sequence
  tx_buffer[0] = reg_address;
  tx_buffer[1] = data;
  tx_buffer[2] = CRC8(CRCInput, 3, 7);
 80027f8:	70b3      	strb	r3, [r6, #2]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80027fa:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80027fc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80027fe:	2b00      	cmp	r3, #0
 8002800:	d000      	beq.n	8002804 <main+0xb34>
 8002802:	e60b      	b.n	800241c <main+0x74c>
 8002804:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002806:	2b00      	cmp	r3, #0
 8002808:	d000      	beq.n	800280c <main+0xb3c>
 800280a:	e607      	b.n	800241c <main+0x74c>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 800280c:	3301      	adds	r3, #1
 800280e:	4658      	mov	r0, fp
 8002810:	6363      	str	r3, [r4, #52]	; 0x34
 8002812:	f000 ffbd 	bl	8003790 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002816:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002818:	2b00      	cmp	r3, #0
 800281a:	d000      	beq.n	800281e <main+0xb4e>
 800281c:	e6c2      	b.n	80025a4 <main+0x8d4>
 800281e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002820:	2b00      	cmp	r3, #0
 8002822:	dc00      	bgt.n	8002826 <main+0xb56>
 8002824:	e6be      	b.n	80025a4 <main+0x8d4>
 8002826:	6823      	ldr	r3, [r4, #0]
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8002828:	6367      	str	r7, [r4, #52]	; 0x34
 800282a:	42a3      	cmp	r3, r4
 800282c:	d005      	beq.n	800283a <main+0xb6a>
 800282e:	69a2      	ldr	r2, [r4, #24]
 8002830:	689b      	ldr	r3, [r3, #8]
 8002832:	6892      	ldr	r2, [r2, #8]
 8002834:	429a      	cmp	r2, r3
 8002836:	d200      	bcs.n	800283a <main+0xb6a>
 8002838:	e6b1      	b.n	800259e <main+0x8ce>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800283a:	b662      	cpsie	i

  //write data to i2c bus
  i2cAcquireBus(i2cp);
  msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, sizeof(tx_buffer),
 800283c:	2200      	movs	r2, #0
 800283e:	2103      	movs	r1, #3
 8002840:	1c13      	adds	r3, r2, #0
 8002842:	1c30      	adds	r0, r6, #0
 8002844:	f002 f85c 	bl	8004900 <i2cMasterTransmitTimeout.constprop.30>
 8002848:	4658      	mov	r0, fp
 800284a:	f000 fee1 	bl	8003610 <chMtxUnlock>
      I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, SYS_STAT, 0b00010000);
      cc_ok = false;
 800284e:	2300      	movs	r3, #0
 8002850:	9a01      	ldr	r2, [sp, #4]

// @ RcurrSense    current sense resister (mOhm)
float GetCurFlow_mA(float RcurrSense) {
  msg_t msg;
  int16_t cc_adc;
  msg = I2CReadRegisterWordWithCRC(&I2CD1, addr_bq76920, CC_HI, &cc_adc);
 8002852:	a80d      	add	r0, sp, #52	; 0x34
 8002854:	7013      	strb	r3, [r2, #0]
 8002856:	f002 fbd3 	bl	8005000 <I2CReadRegisterWordWithCRC.constprop.7>
  else
    return ADCGAIN_hex + 365;
}

float CCtoVolt(int16_t ADC_cc) {
  return ADC_cc * (8.44 / 1000000.0);
 800285a:	ab02      	add	r3, sp, #8
 800285c:	202c      	movs	r0, #44	; 0x2c
 800285e:	5e18      	ldrsh	r0, [r3, r0]
 8002860:	f7ff f862 	bl	8001928 <__aeabi_i2d>
 8002864:	4a27      	ldr	r2, [pc, #156]	; (8002904 <main+0xc34>)
 8002866:	4b28      	ldr	r3, [pc, #160]	; (8002908 <main+0xc38>)
 8002868:	f7fe fa4a 	bl	8000d00 <__aeabi_dmul>
 800286c:	f7ff f8ec 	bl	8001a48 <__aeabi_d2f>
float GetCurFlow_mA(float RcurrSense) {
  msg_t msg;
  int16_t cc_adc;
  msg = I2CReadRegisterWordWithCRC(&I2CD1, addr_bq76920, CC_HI, &cc_adc);
  // (((CC reading[V] / (RSNS[mohm] / 1000)[ohm]))[A] * 1000)[mA]
  return (CCtoVolt(cc_adc) / (RcurrSense/1000.0)) * 1000.0;
 8002870:	f7ff f896 	bl	80019a0 <__aeabi_f2d>
 8002874:	4a25      	ldr	r2, [pc, #148]	; (800290c <main+0xc3c>)
 8002876:	4b26      	ldr	r3, [pc, #152]	; (8002910 <main+0xc40>)
 8002878:	f7fd ff1e 	bl	80006b8 <__aeabi_ddiv>
 800287c:	2200      	movs	r2, #0
 800287e:	4b25      	ldr	r3, [pc, #148]	; (8002914 <main+0xc44>)
 8002880:	f7fe fa3e 	bl	8000d00 <__aeabi_dmul>
 8002884:	f7ff f8e0 	bl	8001a48 <__aeabi_d2f>

// @ BatMax        maximum capacity of battery (mAh)
// @ deltaT        time interval from last call (ms)
float GetBatPercentage(int deltaT) {
  volatile float mA = GetCurFlow_mA(0.25);
  BatLeft -= mA * (deltaT / 3600000.0);
 8002888:	4d23      	ldr	r5, [pc, #140]	; (8002918 <main+0xc48>)
}

// @ BatMax        maximum capacity of battery (mAh)
// @ deltaT        time interval from last call (ms)
float GetBatPercentage(int deltaT) {
  volatile float mA = GetCurFlow_mA(0.25);
 800288a:	900b      	str	r0, [sp, #44]	; 0x2c
  BatLeft -= mA * (deltaT / 3600000.0);
 800288c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800288e:	6828      	ldr	r0, [r5, #0]
 8002890:	4698      	mov	r8, r3
 8002892:	f7ff f885 	bl	80019a0 <__aeabi_f2d>
 8002896:	1c06      	adds	r6, r0, #0
 8002898:	4640      	mov	r0, r8
 800289a:	1c0f      	adds	r7, r1, #0
 800289c:	f7ff f880 	bl	80019a0 <__aeabi_f2d>
 80028a0:	4a1e      	ldr	r2, [pc, #120]	; (800291c <main+0xc4c>)
 80028a2:	4b1f      	ldr	r3, [pc, #124]	; (8002920 <main+0xc50>)
 80028a4:	f7fe fa2c 	bl	8000d00 <__aeabi_dmul>
 80028a8:	1c0b      	adds	r3, r1, #0
 80028aa:	1c02      	adds	r2, r0, #0
 80028ac:	1c39      	adds	r1, r7, #0
 80028ae:	1c30      	adds	r0, r6, #0
 80028b0:	f7fe fcc0 	bl	8001234 <__aeabi_dsub>
 80028b4:	f7ff f8c8 	bl	8001a48 <__aeabi_d2f>
 80028b8:	6028      	str	r0, [r5, #0]
  volatile float BatPercentage = (BatLeft / BatMax) * 100.0;
 80028ba:	6828      	ldr	r0, [r5, #0]
 80028bc:	2100      	movs	r1, #0
 80028be:	f7fd fc91 	bl	80001e4 <__aeabi_fdiv>
 80028c2:	4918      	ldr	r1, [pc, #96]	; (8002924 <main+0xc54>)
 80028c4:	f7fd fdc6 	bl	8000454 <__aeabi_fmul>
 80028c8:	900c      	str	r0, [sp, #48]	; 0x30
  return BatPercentage;
 80028ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
      battery_percentage = GetBatPercentage(100);
 80028cc:	930a      	str	r3, [sp, #40]	; 0x28
 80028ce:	e5eb      	b.n	80024a8 <main+0x7d8>
 80028d0:	1c13      	adds	r3, r2, #0
 80028d2:	e6a7      	b.n	8002624 <main+0x954>
 80028d4:	1c0b      	adds	r3, r1, #0
 80028d6:	e6fe      	b.n	80026d6 <main+0xa06>
 80028d8:	4653      	mov	r3, sl
 80028da:	e77b      	b.n	80027d4 <main+0xb04>
    I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, SYS_CTRL2, enableCCincontinuous);

    if (palReadPad(GPIOA, GPIOA_ALERT))
      cc_ok = true;
    else
      cc_ok = false;
 80028dc:	9a01      	ldr	r2, [sp, #4]
 80028de:	7013      	strb	r3, [r2, #0]
 80028e0:	e744      	b.n	800276c <main+0xa9c>
 80028e2:	46c0      	nop			; (mov r8, r8)
 80028e4:	08005b24 	.word	0x08005b24
 80028e8:	08005810 	.word	0x08005810
 80028ec:	080041d1 	.word	0x080041d1
 80028f0:	40012440 	.word	0x40012440
 80028f4:	40021000 	.word	0x40021000
 80028f8:	08005854 	.word	0x08005854
 80028fc:	080057d0 	.word	0x080057d0
 8002900:	08005860 	.word	0x08005860
 8002904:	c46e0393 	.word	0xc46e0393
 8002908:	3ee1b330 	.word	0x3ee1b330
 800290c:	d2f1a9fc 	.word	0xd2f1a9fc
 8002910:	3f30624d 	.word	0x3f30624d
 8002914:	408f4000 	.word	0x408f4000
 8002918:	20000458 	.word	0x20000458
 800291c:	5a912e32 	.word	0x5a912e32
 8002920:	3efd208a 	.word	0x3efd208a
 8002924:	42c80000 	.word	0x42c80000
	...

08002930 <_idle_thread.lto_priv.62>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8002930:	e7fe      	b.n	8002930 <_idle_thread.lto_priv.62>
 8002932:	46c0      	nop			; (mov r8, r8)
	...

08002940 <trace_next.lto_priv.49>:
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8002940:	4a08      	ldr	r2, [pc, #32]	; (8002964 <trace_next.lto_priv.49+0x24>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8002942:	4909      	ldr	r1, [pc, #36]	; (8002968 <trace_next.lto_priv.49+0x28>)
 8002944:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8002946:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8002948:	8099      	strh	r1, [r3, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
#else
  ch.dbg.trace_buffer.ptr->rtstamp = (rtcnt_t)0;
 800294a:	7819      	ldrb	r1, [r3, #0]
 800294c:	6019      	str	r1, [r3, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 800294e:	2184      	movs	r1, #132	; 0x84
 8002950:	0109      	lsls	r1, r1, #4
 8002952:	3310      	adds	r3, #16
 8002954:	1851      	adds	r1, r2, r1
 8002956:	428b      	cmp	r3, r1
 8002958:	d301      	bcc.n	800295e <trace_next.lto_priv.49+0x1e>
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 800295a:	1c13      	adds	r3, r2, #0
 800295c:	3340      	adds	r3, #64	; 0x40
 800295e:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 8002960:	4770      	bx	lr
 8002962:	46c0      	nop			; (mov r8, r8)
 8002964:	20000700 	.word	0x20000700
 8002968:	40000400 	.word	0x40000400
 800296c:	00000000 	.word	0x00000000

08002970 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002970:	b538      	push	{r3, r4, r5, lr}
 8002972:	1c05      	adds	r5, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002974:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8002976:	4c09      	ldr	r4, [pc, #36]	; (800299c <chSysHalt+0x2c>)
 8002978:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800297a:	075b      	lsls	r3, r3, #29
 800297c:	d501      	bpl.n	8002982 <chSysHalt+0x12>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800297e:	62e5      	str	r5, [r4, #44]	; 0x2c
 8002980:	e7fe      	b.n	8002980 <chSysHalt+0x10>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8002982:	2007      	movs	r0, #7
 8002984:	2204      	movs	r2, #4
 8002986:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002988:	780b      	ldrb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 800298a:	608d      	str	r5, [r1, #8]
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 800298c:	4383      	bics	r3, r0
 800298e:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state         = 0;
 8002990:	4003      	ands	r3, r0
 8002992:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
    trace_next();
 8002994:	f7ff ffd4 	bl	8002940 <trace_next.lto_priv.49>
 8002998:	62e5      	str	r5, [r4, #44]	; 0x2c
 800299a:	e7f1      	b.n	8002980 <chSysHalt+0x10>
 800299c:	20000700 	.word	0x20000700

080029a0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 80029a0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80029a2:	4b06      	ldr	r3, [pc, #24]	; (80029bc <_dbg_check_unlock+0x1c>)
 80029a4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80029a6:	2a00      	cmp	r2, #0
 80029a8:	d104      	bne.n	80029b4 <_dbg_check_unlock+0x14>
 80029aa:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80029ac:	2900      	cmp	r1, #0
 80029ae:	dd01      	ble.n	80029b4 <_dbg_check_unlock+0x14>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80029b0:	635a      	str	r2, [r3, #52]	; 0x34
}
 80029b2:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 80029b4:	4802      	ldr	r0, [pc, #8]	; (80029c0 <_dbg_check_unlock+0x20>)
 80029b6:	f7ff ffdb 	bl	8002970 <chSysHalt>
 80029ba:	46c0      	nop			; (mov r8, r8)
 80029bc:	20000700 	.word	0x20000700
 80029c0:	08005810 	.word	0x08005810
	...

080029d0 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 80029d0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80029d2:	4b05      	ldr	r3, [pc, #20]	; (80029e8 <chDbgCheckClassI+0x18>)
 80029d4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80029d6:	2a00      	cmp	r2, #0
 80029d8:	db03      	blt.n	80029e2 <chDbgCheckClassI+0x12>
 80029da:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80029dc:	2b00      	cmp	r3, #0
 80029de:	dd00      	ble.n	80029e2 <chDbgCheckClassI+0x12>
    chSysHalt("SV#10");
  }
}
 80029e0:	bd08      	pop	{r3, pc}
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#10");
 80029e2:	4802      	ldr	r0, [pc, #8]	; (80029ec <chDbgCheckClassI+0x1c>)
 80029e4:	f7ff ffc4 	bl	8002970 <chSysHalt>
 80029e8:	20000700 	.word	0x20000700
 80029ec:	080058dc 	.word	0x080058dc

080029f0 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 80029f0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80029f2:	4b06      	ldr	r3, [pc, #24]	; (8002a0c <_dbg_check_lock+0x1c>)
 80029f4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80029f6:	2a00      	cmp	r2, #0
 80029f8:	d102      	bne.n	8002a00 <_dbg_check_lock+0x10>
 80029fa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029fc:	2a00      	cmp	r2, #0
 80029fe:	d002      	beq.n	8002a06 <_dbg_check_lock+0x16>
    chSysHalt("SV#4");
 8002a00:	4803      	ldr	r0, [pc, #12]	; (8002a10 <_dbg_check_lock+0x20>)
 8002a02:	f7ff ffb5 	bl	8002970 <chSysHalt>
  }
  _dbg_enter_lock();
 8002a06:	2201      	movs	r2, #1
 8002a08:	635a      	str	r2, [r3, #52]	; 0x34
}
 8002a0a:	bd08      	pop	{r3, pc}
 8002a0c:	20000700 	.word	0x20000700
 8002a10:	08005808 	.word	0x08005808
	...

08002a20 <chSysUnlock.lto_priv.55>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002a20:	b508      	push	{r3, lr}
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002a22:	4b0c      	ldr	r3, [pc, #48]	; (8002a54 <chSysUnlock.lto_priv.55+0x34>)
 8002a24:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002a26:	2a00      	cmp	r2, #0
 8002a28:	d10d      	bne.n	8002a46 <chSysUnlock.lto_priv.55+0x26>
 8002a2a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8002a2c:	2900      	cmp	r1, #0
 8002a2e:	dd0a      	ble.n	8002a46 <chSysUnlock.lto_priv.55+0x26>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8002a30:	635a      	str	r2, [r3, #52]	; 0x34

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002a32:	681a      	ldr	r2, [r3, #0]
 8002a34:	429a      	cmp	r2, r3
 8002a36:	d004      	beq.n	8002a42 <chSysUnlock.lto_priv.55+0x22>
 8002a38:	699b      	ldr	r3, [r3, #24]
 8002a3a:	6899      	ldr	r1, [r3, #8]
 8002a3c:	6893      	ldr	r3, [r2, #8]
 8002a3e:	4299      	cmp	r1, r3
 8002a40:	d304      	bcc.n	8002a4c <chSysUnlock.lto_priv.55+0x2c>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a42:	b662      	cpsie	i
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
}
 8002a44:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 8002a46:	4804      	ldr	r0, [pc, #16]	; (8002a58 <chSysUnlock.lto_priv.55+0x38>)
 8002a48:	f7ff ff92 	bl	8002970 <chSysHalt>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002a4c:	4803      	ldr	r0, [pc, #12]	; (8002a5c <chSysUnlock.lto_priv.55+0x3c>)
 8002a4e:	f7ff ff8f 	bl	8002970 <chSysHalt>
 8002a52:	46c0      	nop			; (mov r8, r8)
 8002a54:	20000700 	.word	0x20000700
 8002a58:	08005810 	.word	0x08005810
 8002a5c:	08005860 	.word	0x08005860

08002a60 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8002a60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002a62:	464d      	mov	r5, r9
 8002a64:	465f      	mov	r7, fp
 8002a66:	4656      	mov	r6, sl
 8002a68:	4644      	mov	r4, r8
 8002a6a:	b4f0      	push	{r4, r5, r6, r7}
 8002a6c:	1c05      	adds	r5, r0, #0
 8002a6e:	b083      	sub	sp, #12
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a70:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 8002a72:	f7ff ffbd 	bl	80029f0 <_dbg_check_lock>
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8002a76:	2222      	movs	r2, #34	; 0x22
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 8002a78:	4c90      	ldr	r4, [pc, #576]	; (8002cbc <chRegFindThreadByWorkingArea+0x25c>)
 8002a7a:	6927      	ldr	r7, [r4, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8002a7c:	5cbb      	ldrb	r3, [r7, r2]
 8002a7e:	3301      	adds	r3, #1
 8002a80:	54bb      	strb	r3, [r7, r2]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8002a82:	f7ff ff8d 	bl	80029a0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002a86:	6823      	ldr	r3, [r4, #0]
 8002a88:	42a3      	cmp	r3, r4
 8002a8a:	d004      	beq.n	8002a96 <chRegFindThreadByWorkingArea+0x36>
 8002a8c:	69a2      	ldr	r2, [r4, #24]
 8002a8e:	689b      	ldr	r3, [r3, #8]
 8002a90:	6892      	ldr	r2, [r2, #8]
 8002a92:	429a      	cmp	r2, r3
 8002a94:	d327      	bcc.n	8002ae6 <chRegFindThreadByWorkingArea+0x86>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002a96:	b662      	cpsie	i
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8002a98:	2301      	movs	r3, #1
 8002a9a:	469b      	mov	fp, r3
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8002a9c:	3320      	adds	r3, #32
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8002a9e:	2622      	movs	r6, #34	; 0x22
 8002aa0:	4699      	mov	r9, r3
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8002aa2:	69fb      	ldr	r3, [r7, #28]
 8002aa4:	42ab      	cmp	r3, r5
 8002aa6:	d045      	beq.n	8002b34 <chRegFindThreadByWorkingArea+0xd4>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002aa8:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002aaa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002aac:	2b00      	cmp	r3, #0
 8002aae:	d102      	bne.n	8002ab6 <chRegFindThreadByWorkingArea+0x56>
 8002ab0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002ab2:	2b00      	cmp	r3, #0
 8002ab4:	d002      	beq.n	8002abc <chRegFindThreadByWorkingArea+0x5c>
    chSysHalt("SV#4");
 8002ab6:	4882      	ldr	r0, [pc, #520]	; (8002cc0 <chRegFindThreadByWorkingArea+0x260>)
 8002ab8:	f7ff ff5a 	bl	8002970 <chSysHalt>
  }
  _dbg_enter_lock();
 8002abc:	465a      	mov	r2, fp
 8002abe:	6362      	str	r2, [r4, #52]	; 0x34
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 8002ac0:	693a      	ldr	r2, [r7, #16]
 8002ac2:	4690      	mov	r8, r2
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8002ac4:	42a2      	cmp	r2, r4
 8002ac6:	d043      	beq.n	8002b50 <chRegFindThreadByWorkingArea+0xf0>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8002ac8:	5d93      	ldrb	r3, [r2, r6]
 8002aca:	2bff      	cmp	r3, #255	; 0xff
 8002acc:	d03a      	beq.n	8002b44 <chRegFindThreadByWorkingArea+0xe4>
    ntp->refs++;
 8002ace:	3301      	adds	r3, #1
 8002ad0:	5593      	strb	r3, [r2, r6]
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8002ad2:	2300      	movs	r3, #0
 8002ad4:	6363      	str	r3, [r4, #52]	; 0x34
 8002ad6:	6823      	ldr	r3, [r4, #0]
 8002ad8:	42a3      	cmp	r3, r4
 8002ada:	d007      	beq.n	8002aec <chRegFindThreadByWorkingArea+0x8c>
 8002adc:	69a2      	ldr	r2, [r4, #24]
 8002ade:	689b      	ldr	r3, [r3, #8]
 8002ae0:	6892      	ldr	r2, [r2, #8]
 8002ae2:	429a      	cmp	r2, r3
 8002ae4:	d202      	bcs.n	8002aec <chRegFindThreadByWorkingArea+0x8c>
 8002ae6:	4877      	ldr	r0, [pc, #476]	; (8002cc4 <chRegFindThreadByWorkingArea+0x264>)
 8002ae8:	f7ff ff42 	bl	8002970 <chSysHalt>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002aec:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002aee:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002af0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002af2:	2b00      	cmp	r3, #0
 8002af4:	d1df      	bne.n	8002ab6 <chRegFindThreadByWorkingArea+0x56>
 8002af6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002af8:	2b00      	cmp	r3, #0
 8002afa:	d1dc      	bne.n	8002ab6 <chRegFindThreadByWorkingArea+0x56>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8002afc:	465a      	mov	r2, fp
 8002afe:	6362      	str	r2, [r4, #52]	; 0x34
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8002b00:	5dba      	ldrb	r2, [r7, r6]
 8002b02:	2a00      	cmp	r2, #0
 8002b04:	d021      	beq.n	8002b4a <chRegFindThreadByWorkingArea+0xea>
  tp->refs--;
 8002b06:	3a01      	subs	r2, #1
 8002b08:	55ba      	strb	r2, [r7, r6]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8002b0a:	6a39      	ldr	r1, [r7, #32]
 8002b0c:	4a6e      	ldr	r2, [pc, #440]	; (8002cc8 <chRegFindThreadByWorkingArea+0x268>)
 8002b0e:	400a      	ands	r2, r1
 8002b10:	2a0f      	cmp	r2, #15
 8002b12:	d01f      	beq.n	8002b54 <chRegFindThreadByWorkingArea+0xf4>
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8002b14:	6363      	str	r3, [r4, #52]	; 0x34
 8002b16:	6823      	ldr	r3, [r4, #0]
 8002b18:	42a3      	cmp	r3, r4
 8002b1a:	d004      	beq.n	8002b26 <chRegFindThreadByWorkingArea+0xc6>
 8002b1c:	69a2      	ldr	r2, [r4, #24]
 8002b1e:	689b      	ldr	r3, [r3, #8]
 8002b20:	6892      	ldr	r2, [r2, #8]
 8002b22:	429a      	cmp	r2, r3
 8002b24:	d345      	bcc.n	8002bb2 <chRegFindThreadByWorkingArea+0x152>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b26:	b662      	cpsie	i
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 8002b28:	4643      	mov	r3, r8
 8002b2a:	2b00      	cmp	r3, #0
 8002b2c:	d100      	bne.n	8002b30 <chRegFindThreadByWorkingArea+0xd0>
 8002b2e:	e08a      	b.n	8002c46 <chRegFindThreadByWorkingArea+0x1e6>
 8002b30:	4647      	mov	r7, r8
 8002b32:	e7b6      	b.n	8002aa2 <chRegFindThreadByWorkingArea+0x42>
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8002b34:	1c38      	adds	r0, r7, #0
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
}
 8002b36:	b003      	add	sp, #12
 8002b38:	bc3c      	pop	{r2, r3, r4, r5}
 8002b3a:	4690      	mov	r8, r2
 8002b3c:	4699      	mov	r9, r3
 8002b3e:	46a2      	mov	sl, r4
 8002b40:	46ab      	mov	fp, r5
 8002b42:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8002b44:	4861      	ldr	r0, [pc, #388]	; (8002ccc <chRegFindThreadByWorkingArea+0x26c>)
 8002b46:	f7ff ff13 	bl	8002970 <chSysHalt>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8002b4a:	4861      	ldr	r0, [pc, #388]	; (8002cd0 <chRegFindThreadByWorkingArea+0x270>)
 8002b4c:	f7ff ff10 	bl	8002970 <chSysHalt>
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 8002b50:	4698      	mov	r8, r3
 8002b52:	e7be      	b.n	8002ad2 <chRegFindThreadByWorkingArea+0x72>

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
 8002b54:	6939      	ldr	r1, [r7, #16]
 8002b56:	697a      	ldr	r2, [r7, #20]
 8002b58:	6111      	str	r1, [r2, #16]
 8002b5a:	6939      	ldr	r1, [r7, #16]
 8002b5c:	614a      	str	r2, [r1, #20]
 8002b5e:	6363      	str	r3, [r4, #52]	; 0x34
 8002b60:	6823      	ldr	r3, [r4, #0]
 8002b62:	42a3      	cmp	r3, r4
 8002b64:	d004      	beq.n	8002b70 <chRegFindThreadByWorkingArea+0x110>
 8002b66:	69a2      	ldr	r2, [r4, #24]
 8002b68:	689b      	ldr	r3, [r3, #8]
 8002b6a:	6892      	ldr	r2, [r2, #8]
 8002b6c:	429a      	cmp	r2, r3
 8002b6e:	d320      	bcc.n	8002bb2 <chRegFindThreadByWorkingArea+0x152>
 8002b70:	b662      	cpsie	i
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8002b72:	464b      	mov	r3, r9
 8002b74:	5cfa      	ldrb	r2, [r7, r3]
 8002b76:	2303      	movs	r3, #3
 8002b78:	4013      	ands	r3, r2
 8002b7a:	2b01      	cmp	r3, #1
 8002b7c:	d01c      	beq.n	8002bb8 <chRegFindThreadByWorkingArea+0x158>
 8002b7e:	2b02      	cmp	r3, #2
 8002b80:	d1d2      	bne.n	8002b28 <chRegFindThreadByWorkingArea+0xc8>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8002b82:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 8002b84:	69f9      	ldr	r1, [r7, #28]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002b86:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002b88:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002b8a:	2b00      	cmp	r3, #0
 8002b8c:	d000      	beq.n	8002b90 <chRegFindThreadByWorkingArea+0x130>
 8002b8e:	e792      	b.n	8002ab6 <chRegFindThreadByWorkingArea+0x56>
 8002b90:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002b92:	2b00      	cmp	r3, #0
 8002b94:	d000      	beq.n	8002b98 <chRegFindThreadByWorkingArea+0x138>
 8002b96:	e78e      	b.n	8002ab6 <chRegFindThreadByWorkingArea+0x56>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8002b98:	465b      	mov	r3, fp
 8002b9a:	6363      	str	r3, [r4, #52]	; 0x34
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
 8002b9c:	2a00      	cmp	r2, #0
 8002b9e:	d005      	beq.n	8002bac <chRegFindThreadByWorkingArea+0x14c>
 8002ba0:	2900      	cmp	r1, #0
 8002ba2:	d003      	beq.n	8002bac <chRegFindThreadByWorkingArea+0x14c>
 8002ba4:	6893      	ldr	r3, [r2, #8]
 8002ba6:	3b01      	subs	r3, #1
 8002ba8:	400b      	ands	r3, r1
 8002baa:	d06f      	beq.n	8002c8c <chRegFindThreadByWorkingArea+0x22c>
 8002bac:	4849      	ldr	r0, [pc, #292]	; (8002cd4 <chRegFindThreadByWorkingArea+0x274>)
 8002bae:	f7ff fedf 	bl	8002970 <chSysHalt>
 8002bb2:	4849      	ldr	r0, [pc, #292]	; (8002cd8 <chRegFindThreadByWorkingArea+0x278>)
 8002bb4:	f7ff fedc 	bl	8002970 <chSysHalt>
 8002bb8:	69fa      	ldr	r2, [r7, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8002bba:	2a00      	cmp	r2, #0
 8002bbc:	d002      	beq.n	8002bc4 <chRegFindThreadByWorkingArea+0x164>
 8002bbe:	2107      	movs	r1, #7
 8002bc0:	420a      	tst	r2, r1
 8002bc2:	d002      	beq.n	8002bca <chRegFindThreadByWorkingArea+0x16a>
 8002bc4:	4845      	ldr	r0, [pc, #276]	; (8002cdc <chRegFindThreadByWorkingArea+0x27c>)
 8002bc6:	f7ff fed3 	bl	8002970 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8002bca:	3a08      	subs	r2, #8
 8002bcc:	1c17      	adds	r7, r2, #0
 8002bce:	6812      	ldr	r2, [r2, #0]
 8002bd0:	4692      	mov	sl, r2
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8002bd2:	687a      	ldr	r2, [r7, #4]
 8002bd4:	3207      	adds	r2, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8002bd6:	08d2      	lsrs	r2, r2, #3
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8002bd8:	607a      	str	r2, [r7, #4]
 8002bda:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002bdc:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8002bde:	2a00      	cmp	r2, #0
 8002be0:	d000      	beq.n	8002be4 <chRegFindThreadByWorkingArea+0x184>
 8002be2:	e768      	b.n	8002ab6 <chRegFindThreadByWorkingArea+0x56>
 8002be4:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002be6:	2a00      	cmp	r2, #0
 8002be8:	d000      	beq.n	8002bec <chRegFindThreadByWorkingArea+0x18c>
 8002bea:	e764      	b.n	8002ab6 <chRegFindThreadByWorkingArea+0x56>
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8002bec:	320c      	adds	r2, #12
 8002bee:	4452      	add	r2, sl
 8002bf0:	1c10      	adds	r0, r2, #0
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8002bf2:	6363      	str	r3, [r4, #52]	; 0x34
 8002bf4:	9201      	str	r2, [sp, #4]
 8002bf6:	f000 fdcb 	bl	8003790 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002bfa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002bfc:	2b00      	cmp	r3, #0
 8002bfe:	d156      	bne.n	8002cae <chRegFindThreadByWorkingArea+0x24e>
 8002c00:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002c02:	2a00      	cmp	r2, #0
 8002c04:	dd53      	ble.n	8002cae <chRegFindThreadByWorkingArea+0x24e>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8002c06:	6363      	str	r3, [r4, #52]	; 0x34
 8002c08:	6823      	ldr	r3, [r4, #0]
 8002c0a:	42a3      	cmp	r3, r4
 8002c0c:	d004      	beq.n	8002c18 <chRegFindThreadByWorkingArea+0x1b8>
 8002c0e:	69a2      	ldr	r2, [r4, #24]
 8002c10:	689b      	ldr	r3, [r3, #8]
 8002c12:	6892      	ldr	r2, [r2, #8]
 8002c14:	429a      	cmp	r2, r3
 8002c16:	d34d      	bcc.n	8002cb4 <chRegFindThreadByWorkingArea+0x254>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8002c18:	4651      	mov	r1, sl
 8002c1a:	3104      	adds	r1, #4
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002c1c:	b662      	cpsie	i
 8002c1e:	1c0b      	adds	r3, r1, #0

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8002c20:	429f      	cmp	r7, r3
 8002c22:	d305      	bcc.n	8002c30 <chRegFindThreadByWorkingArea+0x1d0>
 8002c24:	685a      	ldr	r2, [r3, #4]
 8002c26:	3201      	adds	r2, #1
 8002c28:	00d2      	lsls	r2, r2, #3
 8002c2a:	189a      	adds	r2, r3, r2
 8002c2c:	4297      	cmp	r7, r2
 8002c2e:	d3c9      	bcc.n	8002bc4 <chRegFindThreadByWorkingArea+0x164>

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8002c30:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8002c32:	4299      	cmp	r1, r3
 8002c34:	d001      	beq.n	8002c3a <chRegFindThreadByWorkingArea+0x1da>
 8002c36:	429f      	cmp	r7, r3
 8002c38:	d903      	bls.n	8002c42 <chRegFindThreadByWorkingArea+0x1e2>
 8002c3a:	2a00      	cmp	r2, #0
 8002c3c:	d005      	beq.n	8002c4a <chRegFindThreadByWorkingArea+0x1ea>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8002c3e:	4297      	cmp	r7, r2
 8002c40:	d303      	bcc.n	8002c4a <chRegFindThreadByWorkingArea+0x1ea>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 8002c42:	1c13      	adds	r3, r2, #0
 8002c44:	e7ec      	b.n	8002c20 <chRegFindThreadByWorkingArea+0x1c0>
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
 8002c46:	4640      	mov	r0, r8
 8002c48:	e775      	b.n	8002b36 <chRegFindThreadByWorkingArea+0xd6>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8002c4a:	6879      	ldr	r1, [r7, #4]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8002c4c:	603a      	str	r2, [r7, #0]
      H_NEXT(qp) = hp;
 8002c4e:	601f      	str	r7, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8002c50:	1c4a      	adds	r2, r1, #1
 8002c52:	00d2      	lsls	r2, r2, #3
 8002c54:	6838      	ldr	r0, [r7, #0]
 8002c56:	18ba      	adds	r2, r7, r2
 8002c58:	4282      	cmp	r2, r0
 8002c5a:	d106      	bne.n	8002c6a <chRegFindThreadByWorkingArea+0x20a>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8002c5c:	6850      	ldr	r0, [r2, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8002c5e:	6812      	ldr	r2, [r2, #0]
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8002c60:	4684      	mov	ip, r0
 8002c62:	4461      	add	r1, ip
 8002c64:	3101      	adds	r1, #1
 8002c66:	6079      	str	r1, [r7, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8002c68:	603a      	str	r2, [r7, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 8002c6a:	685a      	ldr	r2, [r3, #4]
 8002c6c:	1c51      	adds	r1, r2, #1
 8002c6e:	00c9      	lsls	r1, r1, #3
 8002c70:	1859      	adds	r1, r3, r1
 8002c72:	428f      	cmp	r7, r1
 8002c74:	d106      	bne.n	8002c84 <chRegFindThreadByWorkingArea+0x224>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8002c76:	6879      	ldr	r1, [r7, #4]
 8002c78:	468c      	mov	ip, r1
 8002c7a:	4462      	add	r2, ip
 8002c7c:	3201      	adds	r2, #1
 8002c7e:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8002c80:	683a      	ldr	r2, [r7, #0]
 8002c82:	601a      	str	r2, [r3, #0]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8002c84:	9801      	ldr	r0, [sp, #4]
 8002c86:	f000 fcc3 	bl	8003610 <chMtxUnlock>
 8002c8a:	e74d      	b.n	8002b28 <chRegFindThreadByWorkingArea+0xc8>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 8002c8c:	6810      	ldr	r0, [r2, #0]
 8002c8e:	6008      	str	r0, [r1, #0]
  mp->next = php;
 8002c90:	6011      	str	r1, [r2, #0]
 8002c92:	6363      	str	r3, [r4, #52]	; 0x34
 8002c94:	6823      	ldr	r3, [r4, #0]
 8002c96:	42a3      	cmp	r3, r4
 8002c98:	d100      	bne.n	8002c9c <chRegFindThreadByWorkingArea+0x23c>
 8002c9a:	e744      	b.n	8002b26 <chRegFindThreadByWorkingArea+0xc6>
 8002c9c:	69a2      	ldr	r2, [r4, #24]
 8002c9e:	689b      	ldr	r3, [r3, #8]
 8002ca0:	6892      	ldr	r2, [r2, #8]
 8002ca2:	429a      	cmp	r2, r3
 8002ca4:	d300      	bcc.n	8002ca8 <chRegFindThreadByWorkingArea+0x248>
 8002ca6:	e73e      	b.n	8002b26 <chRegFindThreadByWorkingArea+0xc6>
 8002ca8:	480d      	ldr	r0, [pc, #52]	; (8002ce0 <chRegFindThreadByWorkingArea+0x280>)
 8002caa:	f7ff fe61 	bl	8002970 <chSysHalt>
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 8002cae:	480d      	ldr	r0, [pc, #52]	; (8002ce4 <chRegFindThreadByWorkingArea+0x284>)
 8002cb0:	f7ff fe5e 	bl	8002970 <chSysHalt>
 8002cb4:	480c      	ldr	r0, [pc, #48]	; (8002ce8 <chRegFindThreadByWorkingArea+0x288>)
 8002cb6:	f7ff fe5b 	bl	8002970 <chSysHalt>
 8002cba:	46c0      	nop			; (mov r8, r8)
 8002cbc:	20000700 	.word	0x20000700
 8002cc0:	08005808 	.word	0x08005808
 8002cc4:	080058d0 	.word	0x080058d0
 8002cc8:	00ff00ff 	.word	0x00ff00ff
 8002ccc:	080058c0 	.word	0x080058c0
 8002cd0:	08005898 	.word	0x08005898
 8002cd4:	080058a8 	.word	0x080058a8
 8002cd8:	08005860 	.word	0x08005860
 8002cdc:	080058b4 	.word	0x080058b4
 8002ce0:	0800590c 	.word	0x0800590c
 8002ce4:	08005810 	.word	0x08005810
 8002ce8:	08005b24 	.word	0x08005b24
 8002cec:	00000000 	.word	0x00000000

08002cf0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8002cf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002cf2:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002cf4:	4c39      	ldr	r4, [pc, #228]	; (8002ddc <chThdExit+0xec>)
 8002cf6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002cf8:	2b00      	cmp	r3, #0
 8002cfa:	d102      	bne.n	8002d02 <chThdExit+0x12>
 8002cfc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002cfe:	2b00      	cmp	r3, #0
 8002d00:	d002      	beq.n	8002d08 <chThdExit+0x18>
    chSysHalt("SV#4");
 8002d02:	4837      	ldr	r0, [pc, #220]	; (8002de0 <chThdExit+0xf0>)
 8002d04:	f7ff fe34 	bl	8002970 <chSysHalt>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8002d08:	69a5      	ldr	r5, [r4, #24]
  }
  _dbg_enter_lock();
 8002d0a:	2301      	movs	r3, #1
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8002d0c:	1c2e      	adds	r6, r5, #0
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8002d0e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8002d10:	3628      	adds	r6, #40	; 0x28
 8002d12:	6363      	str	r3, [r4, #52]	; 0x34
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8002d14:	6268      	str	r0, [r5, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8002d16:	42b2      	cmp	r2, r6
 8002d18:	d024      	beq.n	8002d64 <chThdExit+0x74>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 8002d1a:	6813      	ldr	r3, [r2, #0]
 8002d1c:	62ab      	str	r3, [r5, #40]	; 0x28
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8002d1e:	2320      	movs	r3, #32
 8002d20:	5cd1      	ldrb	r1, [r2, r3]
 8002d22:	2900      	cmp	r1, #0
 8002d24:	d01b      	beq.n	8002d5e <chThdExit+0x6e>
 8002d26:	290f      	cmp	r1, #15
 8002d28:	d019      	beq.n	8002d5e <chThdExit+0x6e>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002d2a:	1c18      	adds	r0, r3, #0
 8002d2c:	2300      	movs	r3, #0
 8002d2e:	469c      	mov	ip, r3
 8002d30:	4663      	mov	r3, ip
 8002d32:	5413      	strb	r3, [r2, r0]
  cp = (thread_t *)&ch.rlist.queue;
 8002d34:	1c23      	adds	r3, r4, #0
 8002d36:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8002d38:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8002d3a:	689f      	ldr	r7, [r3, #8]
 8002d3c:	428f      	cmp	r7, r1
 8002d3e:	d2fb      	bcs.n	8002d38 <chThdExit+0x48>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8002d40:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8002d42:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8002d44:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8002d46:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8002d48:	605a      	str	r2, [r3, #4]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8002d4a:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8002d4c:	42b2      	cmp	r2, r6
 8002d4e:	d009      	beq.n	8002d64 <chThdExit+0x74>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 8002d50:	6813      	ldr	r3, [r2, #0]
 8002d52:	62ab      	str	r3, [r5, #40]	; 0x28
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8002d54:	5c13      	ldrb	r3, [r2, r0]
 8002d56:	2b00      	cmp	r3, #0
 8002d58:	d001      	beq.n	8002d5e <chThdExit+0x6e>
 8002d5a:	2b0f      	cmp	r3, #15
 8002d5c:	d1e8      	bne.n	8002d30 <chThdExit+0x40>
 8002d5e:	4821      	ldr	r0, [pc, #132]	; (8002de4 <chThdExit+0xf4>)
 8002d60:	f7ff fe06 	bl	8002970 <chSysHalt>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8002d64:	2322      	movs	r3, #34	; 0x22
 8002d66:	5ceb      	ldrb	r3, [r5, r3]
 8002d68:	2b00      	cmp	r3, #0
 8002d6a:	d108      	bne.n	8002d7e <chThdExit+0x8e>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8002d6c:	2321      	movs	r3, #33	; 0x21
 8002d6e:	5ceb      	ldrb	r3, [r5, r3]

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8002d70:	079b      	lsls	r3, r3, #30
 8002d72:	d104      	bne.n	8002d7e <chThdExit+0x8e>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 8002d74:	692a      	ldr	r2, [r5, #16]
 8002d76:	696b      	ldr	r3, [r5, #20]
 8002d78:	611a      	str	r2, [r3, #16]
 8002d7a:	692a      	ldr	r2, [r5, #16]
 8002d7c:	6153      	str	r3, [r2, #20]
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8002d7e:	2220      	movs	r2, #32
 8002d80:	230f      	movs	r3, #15
 8002d82:	54ab      	strb	r3, [r5, r2]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8002d84:	6823      	ldr	r3, [r4, #0]

  tqp->next             = tp->queue.next;
 8002d86:	6819      	ldr	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002d88:	604c      	str	r4, [r1, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002d8a:	6021      	str	r1, [r4, #0]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002d8c:	2101      	movs	r1, #1
 8002d8e:	5499      	strb	r1, [r3, r2]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002d90:	8f20      	ldrh	r0, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002d92:	61a3      	str	r3, [r4, #24]
 8002d94:	4208      	tst	r0, r1
 8002d96:	d00c      	beq.n	8002db2 <chThdExit+0xc2>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002d98:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002d9c:	69ea      	ldr	r2, [r5, #28]
 8002d9e:	3b24      	subs	r3, #36	; 0x24
 8002da0:	429a      	cmp	r2, r3
 8002da2:	d818      	bhi.n	8002dd6 <chThdExit+0xe6>
 8002da4:	69a0      	ldr	r0, [r4, #24]
 8002da6:	1c29      	adds	r1, r5, #0
 8002da8:	f7fd f9f6 	bl	8000198 <_port_switch>

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8002dac:	480e      	ldr	r0, [pc, #56]	; (8002de8 <chThdExit+0xf8>)
 8002dae:	f7ff fddf 	bl	8002970 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002db2:	2707      	movs	r7, #7
 8002db4:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8002db6:	7806      	ldrb	r6, [r0, #0]
 8002db8:	43be      	bics	r6, r7
 8002dba:	4331      	orrs	r1, r6
 8002dbc:	7001      	strb	r1, [r0, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002dbe:	5ca9      	ldrb	r1, [r5, r2]
 8002dc0:	7802      	ldrb	r2, [r0, #0]
 8002dc2:	00c9      	lsls	r1, r1, #3
 8002dc4:	403a      	ands	r2, r7
 8002dc6:	430a      	orrs	r2, r1
 8002dc8:	7002      	strb	r2, [r0, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8002dca:	6083      	str	r3, [r0, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002dcc:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8002dce:	60c3      	str	r3, [r0, #12]
    trace_next();
 8002dd0:	f7ff fdb6 	bl	8002940 <trace_next.lto_priv.49>
 8002dd4:	e7e0      	b.n	8002d98 <chThdExit+0xa8>
 8002dd6:	4805      	ldr	r0, [pc, #20]	; (8002dec <chThdExit+0xfc>)
 8002dd8:	f7ff fdca 	bl	8002970 <chSysHalt>
 8002ddc:	20000700 	.word	0x20000700
 8002de0:	08005808 	.word	0x08005808
 8002de4:	08005abc 	.word	0x08005abc
 8002de8:	08005918 	.word	0x08005918
 8002dec:	080058e4 	.word	0x080058e4

08002df0 <chSchDoReschedule>:
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002df0:	2001      	movs	r0, #1
 8002df2:	2120      	movs	r1, #32
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8002df4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *otp = currp;
 8002df6:	4c29      	ldr	r4, [pc, #164]	; (8002e9c <chSchDoReschedule+0xac>)
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8002df8:	6822      	ldr	r2, [r4, #0]
 8002dfa:	69a5      	ldr	r5, [r4, #24]

  tqp->next             = tp->queue.next;
 8002dfc:	6813      	ldr	r3, [r2, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002dfe:	605c      	str	r4, [r3, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002e00:	5450      	strb	r0, [r2, r1]
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002e02:	6b20      	ldr	r0, [r4, #48]	; 0x30
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002e04:	6023      	str	r3, [r4, #0]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002e06:	61a2      	str	r2, [r4, #24]
 8002e08:	2800      	cmp	r0, #0
 8002e0a:	db27      	blt.n	8002e5c <chSchDoReschedule+0x6c>
 8002e0c:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8002e0e:	2800      	cmp	r0, #0
 8002e10:	dd24      	ble.n	8002e5c <chSchDoReschedule+0x6c>
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 8002e12:	2d00      	cmp	r5, #0
 8002e14:	d01f      	beq.n	8002e56 <chSchDoReschedule+0x66>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8002e16:	5c68      	ldrb	r0, [r5, r1]
 8002e18:	2800      	cmp	r0, #0
 8002e1a:	d01c      	beq.n	8002e56 <chSchDoReschedule+0x66>
 8002e1c:	280f      	cmp	r0, #15
 8002e1e:	d01a      	beq.n	8002e56 <chSchDoReschedule+0x66>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002e20:	2000      	movs	r0, #0
 8002e22:	5468      	strb	r0, [r5, r1]
 8002e24:	68a9      	ldr	r1, [r5, #8]
 8002e26:	e000      	b.n	8002e2a <chSchDoReschedule+0x3a>
 8002e28:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 8002e2a:	6898      	ldr	r0, [r3, #8]
 8002e2c:	4288      	cmp	r0, r1
 8002e2e:	d8fb      	bhi.n	8002e28 <chSchDoReschedule+0x38>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8002e30:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8002e32:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8002e34:	6069      	str	r1, [r5, #4]
  tp->queue.prev->queue.next = tp;
 8002e36:	600d      	str	r5, [r1, #0]
  cp->queue.prev             = tp;
 8002e38:	605d      	str	r5, [r3, #4]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002e3a:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8002e3c:	07db      	lsls	r3, r3, #31
 8002e3e:	d513      	bpl.n	8002e68 <chSchDoReschedule+0x78>
 8002e40:	f3ef 8309 	mrs	r3, PSP
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002e44:	69ea      	ldr	r2, [r5, #28]
 8002e46:	3b24      	subs	r3, #36	; 0x24
 8002e48:	429a      	cmp	r2, r3
 8002e4a:	d80a      	bhi.n	8002e62 <chSchDoReschedule+0x72>
 8002e4c:	1c29      	adds	r1, r5, #0
 8002e4e:	69a0      	ldr	r0, [r4, #24]
 8002e50:	f7fd f9a2 	bl	8000198 <_port_switch>
}
 8002e54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 8002e56:	4812      	ldr	r0, [pc, #72]	; (8002ea0 <chSchDoReschedule+0xb0>)
 8002e58:	f7ff fd8a 	bl	8002970 <chSysHalt>
    chSysHalt("SV#10");
 8002e5c:	4811      	ldr	r0, [pc, #68]	; (8002ea4 <chSchDoReschedule+0xb4>)
 8002e5e:	f7ff fd87 	bl	8002970 <chSysHalt>
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002e62:	4811      	ldr	r0, [pc, #68]	; (8002ea8 <chSchDoReschedule+0xb8>)
 8002e64:	f7ff fd84 	bl	8002970 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002e68:	2707      	movs	r7, #7
 8002e6a:	2601      	movs	r6, #1
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002e6c:	2120      	movs	r1, #32
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002e6e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002e70:	7818      	ldrb	r0, [r3, #0]
 8002e72:	43b8      	bics	r0, r7
 8002e74:	4330      	orrs	r0, r6
 8002e76:	7018      	strb	r0, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002e78:	5c68      	ldrb	r0, [r5, r1]
 8002e7a:	7819      	ldrb	r1, [r3, #0]
 8002e7c:	00c0      	lsls	r0, r0, #3
 8002e7e:	4039      	ands	r1, r7
 8002e80:	4301      	orrs	r1, r0
 8002e82:	7019      	strb	r1, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8002e84:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002e86:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8002e88:	60da      	str	r2, [r3, #12]
    trace_next();
 8002e8a:	f7ff fd59 	bl	8002940 <trace_next.lto_priv.49>
 8002e8e:	f3ef 8309 	mrs	r3, PSP
 8002e92:	69ea      	ldr	r2, [r5, #28]
 8002e94:	3b24      	subs	r3, #36	; 0x24
 8002e96:	429a      	cmp	r2, r3
 8002e98:	d9d8      	bls.n	8002e4c <chSchDoReschedule+0x5c>
 8002e9a:	e7e2      	b.n	8002e62 <chSchDoReschedule+0x72>
 8002e9c:	20000700 	.word	0x20000700
 8002ea0:	08005aa8 	.word	0x08005aa8
 8002ea4:	080058dc 	.word	0x080058dc
 8002ea8:	080058e4 	.word	0x080058e4
 8002eac:	00000000 	.word	0x00000000

08002eb0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8002eb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002eb2:	4647      	mov	r7, r8
 8002eb4:	b480      	push	{r7}
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002eb6:	4c9d      	ldr	r4, [pc, #628]	; (800312c <chSchGoSleepTimeoutS+0x27c>)
 8002eb8:	b086      	sub	sp, #24
 8002eba:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002ebc:	2b00      	cmp	r3, #0
 8002ebe:	d000      	beq.n	8002ec2 <chSchGoSleepTimeoutS+0x12>
 8002ec0:	e09d      	b.n	8002ffe <chSchGoSleepTimeoutS+0x14e>
 8002ec2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002ec4:	2b00      	cmp	r3, #0
 8002ec6:	dc00      	bgt.n	8002eca <chSchGoSleepTimeoutS+0x1a>
 8002ec8:	e099      	b.n	8002ffe <chSchGoSleepTimeoutS+0x14e>

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
 8002eca:	1c4b      	adds	r3, r1, #1
 8002ecc:	d100      	bne.n	8002ed0 <chSchGoSleepTimeoutS+0x20>
 8002ece:	e09c      	b.n	800300a <chSchGoSleepTimeoutS+0x15a>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
 8002ed0:	69a3      	ldr	r3, [r4, #24]
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002ed2:	2900      	cmp	r1, #0
 8002ed4:	d100      	bne.n	8002ed8 <chSchGoSleepTimeoutS+0x28>
 8002ed6:	e095      	b.n	8003004 <chSchGoSleepTimeoutS+0x154>

  vtp->par = par;
 8002ed8:	ad01      	add	r5, sp, #4
 8002eda:	612b      	str	r3, [r5, #16]
  vtp->func = vtfunc;
 8002edc:	4b94      	ldr	r3, [pc, #592]	; (8003130 <chSchGoSleepTimeoutS+0x280>)
 8002ede:	60eb      	str	r3, [r5, #12]
 8002ee0:	4b94      	ldr	r3, [pc, #592]	; (8003134 <chSchGoSleepTimeoutS+0x284>)
 8002ee2:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002ee4:	69e3      	ldr	r3, [r4, #28]
 8002ee6:	b292      	uxth	r2, r2
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8002ee8:	2901      	cmp	r1, #1
 8002eea:	d100      	bne.n	8002eee <chSchGoSleepTimeoutS+0x3e>
 8002eec:	e0ad      	b.n	800304a <chSchGoSleepTimeoutS+0x19a>
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002eee:	1c26      	adds	r6, r4, #0
 8002ef0:	361c      	adds	r6, #28
 8002ef2:	42b3      	cmp	r3, r6
 8002ef4:	d100      	bne.n	8002ef8 <chSchGoSleepTimeoutS+0x48>
 8002ef6:	e0c3      	b.n	8003080 <chSchGoSleepTimeoutS+0x1d0>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8002ef8:	8d26      	ldrh	r6, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002efa:	1b92      	subs	r2, r2, r6
 8002efc:	b292      	uxth	r2, r2
 8002efe:	1889      	adds	r1, r1, r2

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8002f00:	428a      	cmp	r2, r1
 8002f02:	d900      	bls.n	8002f06 <chSchGoSleepTimeoutS+0x56>
 8002f04:	e099      	b.n	800303a <chSchGoSleepTimeoutS+0x18a>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 8002f06:	689a      	ldr	r2, [r3, #8]
 8002f08:	4291      	cmp	r1, r2
 8002f0a:	d213      	bcs.n	8002f34 <chSchGoSleepTimeoutS+0x84>
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8002f0c:	4f89      	ldr	r7, [pc, #548]	; (8003134 <chSchGoSleepTimeoutS+0x284>)
 8002f0e:	68ff      	ldr	r7, [r7, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8002f10:	07bf      	lsls	r7, r7, #30
 8002f12:	d400      	bmi.n	8002f16 <chSchGoSleepTimeoutS+0x66>
 8002f14:	e0d5      	b.n	80030c2 <chSchGoSleepTimeoutS+0x212>
 8002f16:	4f88      	ldr	r7, [pc, #544]	; (8003138 <chSchGoSleepTimeoutS+0x288>)
 8002f18:	4688      	mov	r8, r1
 8002f1a:	42b9      	cmp	r1, r7
 8002f1c:	d900      	bls.n	8002f20 <chSchGoSleepTimeoutS+0x70>
 8002f1e:	46b8      	mov	r8, r7

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8002f20:	4446      	add	r6, r8
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002f22:	4f84      	ldr	r7, [pc, #528]	; (8003134 <chSchGoSleepTimeoutS+0x284>)
 8002f24:	b2b6      	uxth	r6, r6
 8002f26:	637e      	str	r6, [r7, #52]	; 0x34
 8002f28:	e004      	b.n	8002f34 <chSchGoSleepTimeoutS+0x84>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 8002f2a:	42ab      	cmp	r3, r5
 8002f2c:	d06a      	beq.n	8003004 <chSchGoSleepTimeoutS+0x154>

    delta -= p->delta;
    p = p->next;
 8002f2e:	681b      	ldr	r3, [r3, #0]
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
 8002f30:	1a89      	subs	r1, r1, r2
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8002f32:	689a      	ldr	r2, [r3, #8]
 8002f34:	4291      	cmp	r1, r2
 8002f36:	d8f8      	bhi.n	8002f2a <chSchGoSleepTimeoutS+0x7a>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8002f38:	685a      	ldr	r2, [r3, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8002f3a:	9301      	str	r3, [sp, #4]
  vtp->prev = vtp->next->prev;
 8002f3c:	606a      	str	r2, [r5, #4]
  vtp->prev->next = vtp;
 8002f3e:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
 8002f40:	605d      	str	r5, [r3, #4]
  vtp->delta = delta;
 8002f42:	60a9      	str	r1, [r5, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8002f44:	689a      	ldr	r2, [r3, #8]
 8002f46:	1a51      	subs	r1, r2, r1
 8002f48:	6099      	str	r1, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8002f4a:	2301      	movs	r3, #1
 8002f4c:	425b      	negs	r3, r3
 8002f4e:	6263      	str	r3, [r4, #36]	; 0x24
 8002f50:	6b23      	ldr	r3, [r4, #48]	; 0x30
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8002f52:	69a6      	ldr	r6, [r4, #24]
 8002f54:	2b00      	cmp	r3, #0
 8002f56:	d152      	bne.n	8002ffe <chSchGoSleepTimeoutS+0x14e>
 8002f58:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002f5a:	2b00      	cmp	r3, #0
 8002f5c:	dd4f      	ble.n	8002ffe <chSchGoSleepTimeoutS+0x14e>

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8002f5e:	2220      	movs	r2, #32
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8002f60:	6823      	ldr	r3, [r4, #0]
 8002f62:	54b0      	strb	r0, [r6, r2]

  tqp->next             = tp->queue.next;
 8002f64:	6819      	ldr	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002f66:	604c      	str	r4, [r1, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8002f68:	6021      	str	r1, [r4, #0]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8002f6a:	2101      	movs	r1, #1
 8002f6c:	5499      	strb	r1, [r3, r2]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002f6e:	8f20      	ldrh	r0, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8002f70:	61a3      	str	r3, [r4, #24]
 8002f72:	4201      	tst	r1, r0
 8002f74:	d114      	bne.n	8002fa0 <chSchGoSleepTimeoutS+0xf0>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002f76:	2707      	movs	r7, #7
 8002f78:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002f7a:	46bc      	mov	ip, r7
 8002f7c:	7808      	ldrb	r0, [r1, #0]
 8002f7e:	43b8      	bics	r0, r7
 8002f80:	1c07      	adds	r7, r0, #0
 8002f82:	2001      	movs	r0, #1
 8002f84:	4338      	orrs	r0, r7
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002f86:	4667      	mov	r7, ip
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002f88:	7008      	strb	r0, [r1, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002f8a:	5cb0      	ldrb	r0, [r6, r2]
 8002f8c:	780a      	ldrb	r2, [r1, #0]
 8002f8e:	00c0      	lsls	r0, r0, #3
 8002f90:	403a      	ands	r2, r7
 8002f92:	4302      	orrs	r2, r0
 8002f94:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8002f96:	608b      	str	r3, [r1, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002f98:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8002f9a:	60cb      	str	r3, [r1, #12]
    trace_next();
 8002f9c:	f7ff fcd0 	bl	8002940 <trace_next.lto_priv.49>
 8002fa0:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002fa4:	69f2      	ldr	r2, [r6, #28]
 8002fa6:	3b24      	subs	r3, #36	; 0x24
 8002fa8:	429a      	cmp	r2, r3
 8002faa:	d84b      	bhi.n	8003044 <chSchGoSleepTimeoutS+0x194>
 8002fac:	69a0      	ldr	r0, [r4, #24]
 8002fae:	1c31      	adds	r1, r6, #0
 8002fb0:	f7fd f8f2 	bl	8000198 <_port_switch>
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002fb4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002fb6:	2b00      	cmp	r3, #0
 8002fb8:	da00      	bge.n	8002fbc <chSchGoSleepTimeoutS+0x10c>
 8002fba:	e07f      	b.n	80030bc <chSchGoSleepTimeoutS+0x20c>
 8002fbc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002fbe:	2b00      	cmp	r3, #0
 8002fc0:	dc00      	bgt.n	8002fc4 <chSchGoSleepTimeoutS+0x114>
 8002fc2:	e07b      	b.n	80030bc <chSchGoSleepTimeoutS+0x20c>
  if (TIME_INFINITE != timeout) {
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt)) {
 8002fc4:	9b04      	ldr	r3, [sp, #16]
 8002fc6:	2b00      	cmp	r3, #0
 8002fc8:	d013      	beq.n	8002ff2 <chSchGoSleepTimeoutS+0x142>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8002fca:	69e3      	ldr	r3, [r4, #28]
 8002fcc:	42ab      	cmp	r3, r5
 8002fce:	d100      	bne.n	8002fd2 <chSchGoSleepTimeoutS+0x122>
 8002fd0:	e07d      	b.n	80030ce <chSchGoSleepTimeoutS+0x21e>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8002fd2:	686a      	ldr	r2, [r5, #4]
 8002fd4:	9b01      	ldr	r3, [sp, #4]
 8002fd6:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8002fd8:	9b01      	ldr	r3, [sp, #4]
 8002fda:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8002fdc:	2200      	movs	r2, #0
 8002fde:	60ea      	str	r2, [r5, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002fe0:	1c22      	adds	r2, r4, #0
 8002fe2:	321c      	adds	r2, #28
 8002fe4:	4293      	cmp	r3, r2
 8002fe6:	d004      	beq.n	8002ff2 <chSchGoSleepTimeoutS+0x142>
      vtp->next->delta += vtp->delta;
 8002fe8:	6899      	ldr	r1, [r3, #8]
 8002fea:	68aa      	ldr	r2, [r5, #8]
 8002fec:	468c      	mov	ip, r1
 8002fee:	4462      	add	r2, ip
 8002ff0:	609a      	str	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8002ff2:	69a3      	ldr	r3, [r4, #24]
 8002ff4:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 8002ff6:	b006      	add	sp, #24
 8002ff8:	bc04      	pop	{r2}
 8002ffa:	4690      	mov	r8, r2
 8002ffc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#11");
 8002ffe:	484f      	ldr	r0, [pc, #316]	; (800313c <chSchGoSleepTimeoutS+0x28c>)
 8003000:	f7ff fcb6 	bl	8002970 <chSysHalt>
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8003004:	484e      	ldr	r0, [pc, #312]	; (8003140 <chSchGoSleepTimeoutS+0x290>)
 8003006:	f7ff fcb3 	bl	8002970 <chSysHalt>
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 800300a:	2620      	movs	r6, #32
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800300c:	6821      	ldr	r1, [r4, #0]
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 800300e:	69a5      	ldr	r5, [r4, #24]

  tqp->next             = tp->queue.next;
 8003010:	680b      	ldr	r3, [r1, #0]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8003012:	55a8      	strb	r0, [r5, r6]
 8003014:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003016:	605c      	str	r4, [r3, #4]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8003018:	2301      	movs	r3, #1
 800301a:	558b      	strb	r3, [r1, r6]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800301c:	8f22      	ldrh	r2, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800301e:	61a1      	str	r1, [r4, #24]
 8003020:	4213      	tst	r3, r2
 8003022:	d018      	beq.n	8003056 <chSchGoSleepTimeoutS+0x1a6>
 8003024:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8003028:	69ea      	ldr	r2, [r5, #28]
 800302a:	3b24      	subs	r3, #36	; 0x24
 800302c:	429a      	cmp	r2, r3
 800302e:	d809      	bhi.n	8003044 <chSchGoSleepTimeoutS+0x194>
 8003030:	69a0      	ldr	r0, [r4, #24]
 8003032:	1c29      	adds	r1, r5, #0
 8003034:	f7fd f8b0 	bl	8000198 <_port_switch>
 8003038:	e7db      	b.n	8002ff2 <chSchGoSleepTimeoutS+0x142>

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 800303a:	689a      	ldr	r2, [r3, #8]
      p = p->next;
 800303c:	681b      	ldr	r3, [r3, #0]

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 800303e:	1a89      	subs	r1, r1, r2
 8003040:	689a      	ldr	r2, [r3, #8]
 8003042:	e777      	b.n	8002f34 <chSchGoSleepTimeoutS+0x84>
 8003044:	483f      	ldr	r0, [pc, #252]	; (8003144 <chSchGoSleepTimeoutS+0x294>)
 8003046:	f7ff fc93 	bl	8002970 <chSysHalt>
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800304a:	1c21      	adds	r1, r4, #0
 800304c:	311c      	adds	r1, #28
 800304e:	428b      	cmp	r3, r1
 8003050:	d02b      	beq.n	80030aa <chSchGoSleepTimeoutS+0x1fa>
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003052:	2102      	movs	r1, #2
 8003054:	e750      	b.n	8002ef8 <chSchGoSleepTimeoutS+0x48>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003056:	2207      	movs	r2, #7
 8003058:	2701      	movs	r7, #1
 800305a:	4694      	mov	ip, r2
 800305c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800305e:	7818      	ldrb	r0, [r3, #0]
 8003060:	4390      	bics	r0, r2
 8003062:	4338      	orrs	r0, r7
 8003064:	7018      	strb	r0, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003066:	5da8      	ldrb	r0, [r5, r6]
 8003068:	4666      	mov	r6, ip
 800306a:	781a      	ldrb	r2, [r3, #0]
 800306c:	00c0      	lsls	r0, r0, #3
 800306e:	4032      	ands	r2, r6
 8003070:	4302      	orrs	r2, r0
 8003072:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8003074:	6099      	str	r1, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8003076:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8003078:	60da      	str	r2, [r3, #12]
    trace_next();
 800307a:	f7ff fc61 	bl	8002940 <trace_next.lto_priv.49>
 800307e:	e7d1      	b.n	8003024 <chSchGoSleepTimeoutS+0x174>
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8003080:	602b      	str	r3, [r5, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8003082:	606b      	str	r3, [r5, #4]
      vtp->delta = delay;

#if CH_CFG_INTERVALS_SIZE > CH_CFG_ST_RESOLUTION
      /* The delta could be too large for the physical timer to handle.*/
      if (delay > (sysinterval_t)TIME_MAX_SYSTIME) {
 8003084:	4b2c      	ldr	r3, [pc, #176]	; (8003138 <chSchGoSleepTimeoutS+0x288>)
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8003086:	8522      	strh	r2, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 8003088:	61e5      	str	r5, [r4, #28]
      ch.vtlist.prev = vtp;
 800308a:	6225      	str	r5, [r4, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 800308c:	60a9      	str	r1, [r5, #8]

#if CH_CFG_INTERVALS_SIZE > CH_CFG_ST_RESOLUTION
      /* The delta could be too large for the physical timer to handle.*/
      if (delay > (sysinterval_t)TIME_MAX_SYSTIME) {
 800308e:	1c1e      	adds	r6, r3, #0
 8003090:	4299      	cmp	r1, r3
 8003092:	d911      	bls.n	80030b8 <chSchGoSleepTimeoutS+0x208>
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8003094:	2702      	movs	r7, #2
 8003096:	4927      	ldr	r1, [pc, #156]	; (8003134 <chSchGoSleepTimeoutS+0x284>)
 8003098:	68cb      	ldr	r3, [r1, #12]
 800309a:	403b      	ands	r3, r7
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800309c:	d114      	bne.n	80030c8 <chSchGoSleepTimeoutS+0x218>
 800309e:	18b2      	adds	r2, r6, r2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80030a0:	b292      	uxth	r2, r2
 80030a2:	634a      	str	r2, [r1, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80030a4:	610b      	str	r3, [r1, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80030a6:	60cf      	str	r7, [r1, #12]
 80030a8:	e752      	b.n	8002f50 <chSchGoSleepTimeoutS+0xa0>
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 80030aa:	2102      	movs	r1, #2
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 80030ac:	8522      	strh	r2, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 80030ae:	61e5      	str	r5, [r4, #28]
      ch.vtlist.prev = vtp;
 80030b0:	6225      	str	r5, [r4, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 80030b2:	602b      	str	r3, [r5, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80030b4:	606b      	str	r3, [r5, #4]
      vtp->delta = delay;
 80030b6:	60a9      	str	r1, [r5, #8]
 80030b8:	b28e      	uxth	r6, r1
 80030ba:	e7eb      	b.n	8003094 <chSchGoSleepTimeoutS+0x1e4>
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#10");
 80030bc:	4822      	ldr	r0, [pc, #136]	; (8003148 <chSchGoSleepTimeoutS+0x298>)
 80030be:	f7ff fc57 	bl	8002970 <chSysHalt>
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80030c2:	4822      	ldr	r0, [pc, #136]	; (800314c <chSchGoSleepTimeoutS+0x29c>)
 80030c4:	f7ff fc54 	bl	8002970 <chSysHalt>
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80030c8:	4821      	ldr	r0, [pc, #132]	; (8003150 <chSchGoSleepTimeoutS+0x2a0>)
 80030ca:	f7ff fc51 	bl	8002970 <chSysHalt>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 80030ce:	2300      	movs	r3, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 80030d0:	6829      	ldr	r1, [r5, #0]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80030d2:	4a20      	ldr	r2, [pc, #128]	; (8003154 <chSchGoSleepTimeoutS+0x2a4>)

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 80030d4:	61e1      	str	r1, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80030d6:	604a      	str	r2, [r1, #4]
  vtp->func = NULL;
 80030d8:	60eb      	str	r3, [r5, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80030da:	4291      	cmp	r1, r2
 80030dc:	d022      	beq.n	8003124 <chSchGoSleepTimeoutS+0x274>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80030de:	68ab      	ldr	r3, [r5, #8]
 80030e0:	688a      	ldr	r2, [r1, #8]
 80030e2:	189a      	adds	r2, r3, r2
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80030e4:	4b13      	ldr	r3, [pc, #76]	; (8003134 <chSchGoSleepTimeoutS+0x284>)
 80030e6:	608a      	str	r2, [r1, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 80030e8:	8d20      	ldrh	r0, [r4, #40]	; 0x28
 80030ea:	6a59      	ldr	r1, [r3, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80030ec:	1a09      	subs	r1, r1, r0
 80030ee:	b289      	uxth	r1, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 80030f0:	428a      	cmp	r2, r1
 80030f2:	d800      	bhi.n	80030f6 <chSchGoSleepTimeoutS+0x246>
 80030f4:	e77d      	b.n	8002ff2 <chSchGoSleepTimeoutS+0x142>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 80030f6:	1a53      	subs	r3, r2, r1

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 80030f8:	2b01      	cmp	r3, #1
 80030fa:	d90c      	bls.n	8003116 <chSchGoSleepTimeoutS+0x266>
 80030fc:	1e13      	subs	r3, r2, #0
 80030fe:	4a0e      	ldr	r2, [pc, #56]	; (8003138 <chSchGoSleepTimeoutS+0x288>)
 8003100:	4293      	cmp	r3, r2
 8003102:	d900      	bls.n	8003106 <chSchGoSleepTimeoutS+0x256>
 8003104:	1c13      	adds	r3, r2, #0
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8003106:	4a0b      	ldr	r2, [pc, #44]	; (8003134 <chSchGoSleepTimeoutS+0x284>)
 8003108:	68d1      	ldr	r1, [r2, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800310a:	0789      	lsls	r1, r1, #30
 800310c:	d5d9      	bpl.n	80030c2 <chSchGoSleepTimeoutS+0x212>

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 800310e:	18c3      	adds	r3, r0, r3
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003110:	b29b      	uxth	r3, r3
 8003112:	6353      	str	r3, [r2, #52]	; 0x34
 8003114:	e76d      	b.n	8002ff2 <chSchGoSleepTimeoutS+0x142>
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
 8003116:	4a08      	ldr	r2, [pc, #32]	; (8003138 <chSchGoSleepTimeoutS+0x288>)
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003118:	1c8b      	adds	r3, r1, #2
 800311a:	4293      	cmp	r3, r2
 800311c:	d9f3      	bls.n	8003106 <chSchGoSleepTimeoutS+0x256>
 800311e:	480e      	ldr	r0, [pc, #56]	; (8003158 <chSchGoSleepTimeoutS+0x2a8>)
 8003120:	f7ff fc26 	bl	8002970 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003124:	4a03      	ldr	r2, [pc, #12]	; (8003134 <chSchGoSleepTimeoutS+0x284>)
 8003126:	60d3      	str	r3, [r2, #12]
 8003128:	e763      	b.n	8002ff2 <chSchGoSleepTimeoutS+0x142>
 800312a:	46c0      	nop			; (mov r8, r8)
 800312c:	20000700 	.word	0x20000700
 8003130:	08003161 	.word	0x08003161
 8003134:	40000400 	.word	0x40000400
 8003138:	0000ffff 	.word	0x0000ffff
 800313c:	080058f4 	.word	0x080058f4
 8003140:	08005950 	.word	0x08005950
 8003144:	080058e4 	.word	0x080058e4
 8003148:	080058dc 	.word	0x080058dc
 800314c:	0800595c 	.word	0x0800595c
 8003150:	0800597c 	.word	0x0800597c
 8003154:	2000071c 	.word	0x2000071c
 8003158:	08005968 	.word	0x08005968
 800315c:	00000000 	.word	0x00000000

08003160 <wakeup.lto_priv.64>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8003160:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003162:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003164:	4b27      	ldr	r3, [pc, #156]	; (8003204 <wakeup.lto_priv.64+0xa4>)
 8003166:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8003168:	2900      	cmp	r1, #0
 800316a:	dd02      	ble.n	8003172 <wakeup.lto_priv.64+0x12>
 800316c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800316e:	2a00      	cmp	r2, #0
 8003170:	d002      	beq.n	8003178 <wakeup.lto_priv.64+0x18>
    chSysHalt("SV#6");
 8003172:	4825      	ldr	r0, [pc, #148]	; (8003208 <wakeup.lto_priv.64+0xa8>)
 8003174:	f7ff fbfc 	bl	8002970 <chSysHalt>
  }
  _dbg_enter_lock();
 8003178:	2201      	movs	r2, #1
 800317a:	635a      	str	r2, [r3, #52]	; 0x34
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 800317c:	321f      	adds	r2, #31
 800317e:	5c82      	ldrb	r2, [r0, r2]
 8003180:	2a07      	cmp	r2, #7
 8003182:	d831      	bhi.n	80031e8 <wakeup.lto_priv.64+0x88>
 8003184:	4c21      	ldr	r4, [pc, #132]	; (800320c <wakeup.lto_priv.64+0xac>)
 8003186:	0092      	lsls	r2, r2, #2
 8003188:	58a2      	ldr	r2, [r4, r2]
 800318a:	4697      	mov	pc, r2
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 800318c:	6a41      	ldr	r1, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 800318e:	688a      	ldr	r2, [r1, #8]
 8003190:	3201      	adds	r2, #1
 8003192:	608a      	str	r2, [r1, #8]
 8003194:	6b19      	ldr	r1, [r3, #48]	; 0x30
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8003196:	6842      	ldr	r2, [r0, #4]
 8003198:	6804      	ldr	r4, [r0, #0]
 800319a:	6014      	str	r4, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 800319c:	6804      	ldr	r4, [r0, #0]
 800319e:	6062      	str	r2, [r4, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 80031a0:	2201      	movs	r2, #1
 80031a2:	4252      	negs	r2, r2
 80031a4:	6242      	str	r2, [r0, #36]	; 0x24
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80031a6:	2900      	cmp	r1, #0
 80031a8:	db22      	blt.n	80031f0 <wakeup.lto_priv.64+0x90>
 80031aa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80031ac:	2a00      	cmp	r2, #0
 80031ae:	dd1f      	ble.n	80031f0 <wakeup.lto_priv.64+0x90>
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80031b0:	2420      	movs	r4, #32
 80031b2:	5d02      	ldrb	r2, [r0, r4]
 80031b4:	2a00      	cmp	r2, #0
 80031b6:	d01e      	beq.n	80031f6 <wakeup.lto_priv.64+0x96>
 80031b8:	2a0f      	cmp	r2, #15
 80031ba:	d01c      	beq.n	80031f6 <wakeup.lto_priv.64+0x96>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80031bc:	2200      	movs	r2, #0
 80031be:	5502      	strb	r2, [r0, r4]
  cp = (thread_t *)&ch.rlist.queue;
 80031c0:	1c1a      	adds	r2, r3, #0
 80031c2:	6884      	ldr	r4, [r0, #8]
  do {
    cp = cp->queue.next;
 80031c4:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 80031c6:	6895      	ldr	r5, [r2, #8]
 80031c8:	42ac      	cmp	r4, r5
 80031ca:	d9fb      	bls.n	80031c4 <wakeup.lto_priv.64+0x64>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80031cc:	6854      	ldr	r4, [r2, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80031ce:	6002      	str	r2, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 80031d0:	6044      	str	r4, [r0, #4]
  tp->queue.prev->queue.next = tp;
 80031d2:	6020      	str	r0, [r4, #0]
  cp->queue.prev             = tp;
 80031d4:	6050      	str	r0, [r2, #4]
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80031d6:	2900      	cmp	r1, #0
 80031d8:	d010      	beq.n	80031fc <wakeup.lto_priv.64+0x9c>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 80031da:	2200      	movs	r2, #0
 80031dc:	635a      	str	r2, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80031de:	b662      	cpsie	i
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80031e0:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 80031e2:	2400      	movs	r4, #0
 80031e4:	6a42      	ldr	r2, [r0, #36]	; 0x24
 80031e6:	6014      	str	r4, [r2, #0]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 80031e8:	2201      	movs	r2, #1
 80031ea:	4252      	negs	r2, r2
 80031ec:	6242      	str	r2, [r0, #36]	; 0x24
 80031ee:	e7dc      	b.n	80031aa <wakeup.lto_priv.64+0x4a>
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#10");
 80031f0:	4807      	ldr	r0, [pc, #28]	; (8003210 <wakeup.lto_priv.64+0xb0>)
 80031f2:	f7ff fbbd 	bl	8002970 <chSysHalt>
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80031f6:	4807      	ldr	r0, [pc, #28]	; (8003214 <wakeup.lto_priv.64+0xb4>)
 80031f8:	f7ff fbba 	bl	8002970 <chSysHalt>
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
 80031fc:	4806      	ldr	r0, [pc, #24]	; (8003218 <wakeup.lto_priv.64+0xb8>)
 80031fe:	f7ff fbb7 	bl	8002970 <chSysHalt>
 8003202:	46c0      	nop			; (mov r8, r8)
 8003204:	20000700 	.word	0x20000700
 8003208:	080058fc 	.word	0x080058fc
 800320c:	08005878 	.word	0x08005878
 8003210:	080058dc 	.word	0x080058dc
 8003214:	08005abc 	.word	0x08005abc
 8003218:	08005904 	.word	0x08005904
 800321c:	00000000 	.word	0x00000000

08003220 <chCoreAllocAlignedI.lto_priv.61>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003220:	4b12      	ldr	r3, [pc, #72]	; (800326c <chCoreAllocAlignedI.lto_priv.61+0x4c>)
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8003222:	b570      	push	{r4, r5, r6, lr}
 8003224:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003226:	2a00      	cmp	r2, #0
 8003228:	db1b      	blt.n	8003262 <chCoreAllocAlignedI.lto_priv.61+0x42>
 800322a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800322c:	2b00      	cmp	r3, #0
 800322e:	dd18      	ble.n	8003262 <chCoreAllocAlignedI.lto_priv.61+0x42>
                                    unsigned align,
                                    size_t offset) {
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8003230:	2900      	cmp	r1, #0
 8003232:	d013      	beq.n	800325c <chCoreAllocAlignedI.lto_priv.61+0x3c>
 8003234:	1e4b      	subs	r3, r1, #1
 8003236:	4219      	tst	r1, r3
 8003238:	d110      	bne.n	800325c <chCoreAllocAlignedI.lto_priv.61+0x3c>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800323a:	4a0d      	ldr	r2, [pc, #52]	; (8003270 <chCoreAllocAlignedI.lto_priv.61+0x50>)
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 800323c:	424c      	negs	r4, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800323e:	6815      	ldr	r5, [r2, #0]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8003240:	1818      	adds	r0, r3, r0
 8003242:	1e6e      	subs	r6, r5, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8003244:	1871      	adds	r1, r6, r1
 8003246:	4021      	ands	r1, r4
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8003248:	4020      	ands	r0, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800324a:	6853      	ldr	r3, [r2, #4]
  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;
 800324c:	1808      	adds	r0, r1, r0

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800324e:	4298      	cmp	r0, r3
 8003250:	d80a      	bhi.n	8003268 <chCoreAllocAlignedI.lto_priv.61+0x48>
 8003252:	4285      	cmp	r5, r0
 8003254:	d808      	bhi.n	8003268 <chCoreAllocAlignedI.lto_priv.61+0x48>
    return NULL;
  }

  ch_memcore.nextmem = next;
 8003256:	6010      	str	r0, [r2, #0]

  return p;
 8003258:	1c08      	adds	r0, r1, #0

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 800325a:	bd70      	pop	{r4, r5, r6, pc}
                                    unsigned align,
                                    size_t offset) {
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800325c:	4805      	ldr	r0, [pc, #20]	; (8003274 <chCoreAllocAlignedI.lto_priv.61+0x54>)
 800325e:	f7ff fb87 	bl	8002970 <chSysHalt>
    chSysHalt("SV#10");
 8003262:	4805      	ldr	r0, [pc, #20]	; (8003278 <chCoreAllocAlignedI.lto_priv.61+0x58>)
 8003264:	f7ff fb84 	bl	8002970 <chSysHalt>
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
    return NULL;
 8003268:	2000      	movs	r0, #0
 800326a:	e7f6      	b.n	800325a <chCoreAllocAlignedI.lto_priv.61+0x3a>
 800326c:	20000700 	.word	0x20000700
 8003270:	2000041c 	.word	0x2000041c
 8003274:	08005924 	.word	0x08005924
 8003278:	080058dc 	.word	0x080058dc
 800327c:	00000000 	.word	0x00000000

08003280 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8003280:	b570      	push	{r4, r5, r6, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003282:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003284:	4b1a      	ldr	r3, [pc, #104]	; (80032f0 <chCoreAllocAlignedWithOffset+0x70>)
 8003286:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8003288:	2c00      	cmp	r4, #0
 800328a:	d102      	bne.n	8003292 <chCoreAllocAlignedWithOffset+0x12>
 800328c:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 800328e:	2c00      	cmp	r4, #0
 8003290:	d002      	beq.n	8003298 <chCoreAllocAlignedWithOffset+0x18>
    chSysHalt("SV#4");
 8003292:	4818      	ldr	r0, [pc, #96]	; (80032f4 <chCoreAllocAlignedWithOffset+0x74>)
 8003294:	f7ff fb6c 	bl	8002970 <chSysHalt>
  }
  _dbg_enter_lock();
 8003298:	2401      	movs	r4, #1
 800329a:	635c      	str	r4, [r3, #52]	; 0x34
                                    unsigned align,
                                    size_t offset) {
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800329c:	2900      	cmp	r1, #0
 800329e:	d01e      	beq.n	80032de <chCoreAllocAlignedWithOffset+0x5e>
 80032a0:	1e4c      	subs	r4, r1, #1
 80032a2:	4221      	tst	r1, r4
 80032a4:	d11b      	bne.n	80032de <chCoreAllocAlignedWithOffset+0x5e>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80032a6:	4d14      	ldr	r5, [pc, #80]	; (80032f8 <chCoreAllocAlignedWithOffset+0x78>)
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80032a8:	4249      	negs	r1, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80032aa:	682e      	ldr	r6, [r5, #0]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80032ac:	1820      	adds	r0, r4, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 80032ae:	18b2      	adds	r2, r6, r2
 80032b0:	1912      	adds	r2, r2, r4
 80032b2:	400a      	ands	r2, r1
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80032b4:	4001      	ands	r1, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 80032b6:	6868      	ldr	r0, [r5, #4]
  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;
 80032b8:	1851      	adds	r1, r2, r1

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 80032ba:	4281      	cmp	r1, r0
 80032bc:	d812      	bhi.n	80032e4 <chCoreAllocAlignedWithOffset+0x64>
 80032be:	428e      	cmp	r6, r1
 80032c0:	d810      	bhi.n	80032e4 <chCoreAllocAlignedWithOffset+0x64>
    return NULL;
  }

  ch_memcore.nextmem = next;
 80032c2:	6029      	str	r1, [r5, #0]
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80032c4:	2100      	movs	r1, #0
 80032c6:	6359      	str	r1, [r3, #52]	; 0x34
 80032c8:	6819      	ldr	r1, [r3, #0]
 80032ca:	4299      	cmp	r1, r3
 80032cc:	d004      	beq.n	80032d8 <chCoreAllocAlignedWithOffset+0x58>
 80032ce:	699b      	ldr	r3, [r3, #24]
 80032d0:	6898      	ldr	r0, [r3, #8]
 80032d2:	688b      	ldr	r3, [r1, #8]
 80032d4:	4298      	cmp	r0, r3
 80032d6:	d307      	bcc.n	80032e8 <chCoreAllocAlignedWithOffset+0x68>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80032d8:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 80032da:	1c10      	adds	r0, r2, #0
 80032dc:	bd70      	pop	{r4, r5, r6, pc}
                                    unsigned align,
                                    size_t offset) {
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 80032de:	4807      	ldr	r0, [pc, #28]	; (80032fc <chCoreAllocAlignedWithOffset+0x7c>)
 80032e0:	f7ff fb46 	bl	8002970 <chSysHalt>
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
    return NULL;
 80032e4:	2200      	movs	r2, #0
 80032e6:	e7ed      	b.n	80032c4 <chCoreAllocAlignedWithOffset+0x44>
 80032e8:	4805      	ldr	r0, [pc, #20]	; (8003300 <chCoreAllocAlignedWithOffset+0x80>)
 80032ea:	f7ff fb41 	bl	8002970 <chSysHalt>
 80032ee:	46c0      	nop			; (mov r8, r8)
 80032f0:	20000700 	.word	0x20000700
 80032f4:	08005808 	.word	0x08005808
 80032f8:	2000041c 	.word	0x2000041c
 80032fc:	08005924 	.word	0x08005924
 8003300:	0800598c 	.word	0x0800598c
	...

08003310 <Thread1.lto_priv.53>:

/*
 * LEDs batLED thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8003310:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003312:	4644      	mov	r4, r8
 8003314:	465f      	mov	r7, fp
 8003316:	4656      	mov	r6, sl
 8003318:	464d      	mov	r5, r9
 800331a:	b4f0      	push	{r4, r5, r6, r7}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 800331c:	4ca3      	ldr	r4, [pc, #652]	; (80035ac <Thread1.lto_priv.53+0x29c>)
 800331e:	4aa4      	ldr	r2, [pc, #656]	; (80035b0 <Thread1.lto_priv.53+0x2a0>)
 8003320:	69a3      	ldr	r3, [r4, #24]
 8003322:	b087      	sub	sp, #28
 8003324:	619a      	str	r2, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003326:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003328:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800332a:	2b00      	cmp	r3, #0
 800332c:	d102      	bne.n	8003334 <Thread1.lto_priv.53+0x24>
 800332e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003330:	2b00      	cmp	r3, #0
 8003332:	d002      	beq.n	800333a <Thread1.lto_priv.53+0x2a>
    chSysHalt("SV#4");
 8003334:	489f      	ldr	r0, [pc, #636]	; (80035b4 <Thread1.lto_priv.53+0x2a4>)
 8003336:	f7ff fb1b 	bl	8002970 <chSysHalt>
 800333a:	4b9f      	ldr	r3, [pc, #636]	; (80035b8 <Thread1.lto_priv.53+0x2a8>)

  (void)arg;
  chRegSetThreadName("batLED");
  while (true) {
    chThdSleepMilliseconds(500);
    palSetPad(GPIOA, GPIOA_LED1);
 800333c:	2690      	movs	r6, #144	; 0x90
  }
  _dbg_enter_lock();
 800333e:	2501      	movs	r5, #1
 8003340:	469b      	mov	fp, r3
 8003342:	05f6      	lsls	r6, r6, #23
 8003344:	2008      	movs	r0, #8
 8003346:	499c      	ldr	r1, [pc, #624]	; (80035b8 <Thread1.lto_priv.53+0x2a8>)
 8003348:	6365      	str	r5, [r4, #52]	; 0x34
 800334a:	f7ff fdb1 	bl	8002eb0 <chSchGoSleepTimeoutS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800334e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003350:	2b00      	cmp	r3, #0
 8003352:	d000      	beq.n	8003356 <Thread1.lto_priv.53+0x46>
 8003354:	e0bb      	b.n	80034ce <Thread1.lto_priv.53+0x1be>
 8003356:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003358:	2a00      	cmp	r2, #0
 800335a:	dc00      	bgt.n	800335e <Thread1.lto_priv.53+0x4e>
 800335c:	e0b7      	b.n	80034ce <Thread1.lto_priv.53+0x1be>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800335e:	6363      	str	r3, [r4, #52]	; 0x34
 8003360:	6823      	ldr	r3, [r4, #0]
 8003362:	42a3      	cmp	r3, r4
 8003364:	d005      	beq.n	8003372 <Thread1.lto_priv.53+0x62>
 8003366:	69a2      	ldr	r2, [r4, #24]
 8003368:	689b      	ldr	r3, [r3, #8]
 800336a:	6892      	ldr	r2, [r2, #8]
 800336c:	429a      	cmp	r2, r3
 800336e:	d200      	bcs.n	8003372 <Thread1.lto_priv.53+0x62>
 8003370:	e0b0      	b.n	80034d4 <Thread1.lto_priv.53+0x1c4>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003372:	b662      	cpsie	i
 8003374:	2320      	movs	r3, #32
    palSetPad(GPIOB, GPIOB_LED5);
 8003376:	4a91      	ldr	r2, [pc, #580]	; (80035bc <Thread1.lto_priv.53+0x2ac>)

  (void)arg;
  chRegSetThreadName("batLED");
  while (true) {
    chThdSleepMilliseconds(500);
    palSetPad(GPIOA, GPIOA_LED1);
 8003378:	8333      	strh	r3, [r6, #24]
    palSetPad(GPIOB, GPIOB_LED5);
 800337a:	3b1e      	subs	r3, #30
 800337c:	8313      	strh	r3, [r2, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800337e:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003380:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8003382:	2a00      	cmp	r2, #0
 8003384:	d1d6      	bne.n	8003334 <Thread1.lto_priv.53+0x24>
 8003386:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003388:	2a00      	cmp	r2, #0
 800338a:	d1d3      	bne.n	8003334 <Thread1.lto_priv.53+0x24>
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 800338c:	aa01      	add	r2, sp, #4
 800338e:	4690      	mov	r8, r2
 8003390:	69a1      	ldr	r1, [r4, #24]
  vtp->func = vtfunc;
 8003392:	4a8b      	ldr	r2, [pc, #556]	; (80035c0 <Thread1.lto_priv.53+0x2b0>)
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8003394:	9105      	str	r1, [sp, #20]
  vtp->func = vtfunc;
 8003396:	4641      	mov	r1, r8
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003398:	488a      	ldr	r0, [pc, #552]	; (80035c4 <Thread1.lto_priv.53+0x2b4>)
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 800339a:	6365      	str	r5, [r4, #52]	; 0x34
 800339c:	60ca      	str	r2, [r1, #12]
 800339e:	6a42      	ldr	r2, [r0, #36]	; 0x24
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80033a0:	4f89      	ldr	r7, [pc, #548]	; (80035c8 <Thread1.lto_priv.53+0x2b8>)
 80033a2:	b291      	uxth	r1, r2
 80033a4:	69e2      	ldr	r2, [r4, #28]
 80033a6:	46b9      	mov	r9, r7
 80033a8:	42ba      	cmp	r2, r7
 80033aa:	d100      	bne.n	80033ae <Thread1.lto_priv.53+0x9e>
 80033ac:	e0ac      	b.n	8003508 <Thread1.lto_priv.53+0x1f8>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 80033ae:	8d27      	ldrh	r7, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80033b0:	1bc9      	subs	r1, r1, r7
 80033b2:	b289      	uxth	r1, r1
 80033b4:	468a      	mov	sl, r1
 80033b6:	4980      	ldr	r1, [pc, #512]	; (80035b8 <Thread1.lto_priv.53+0x2a8>)
 80033b8:	46bc      	mov	ip, r7
 80033ba:	4451      	add	r1, sl

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 80033bc:	458a      	cmp	sl, r1
 80033be:	d800      	bhi.n	80033c2 <Thread1.lto_priv.53+0xb2>
 80033c0:	e08b      	b.n	80034da <Thread1.lto_priv.53+0x1ca>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 80033c2:	6893      	ldr	r3, [r2, #8]
      p = p->next;
 80033c4:	6812      	ldr	r2, [r2, #0]

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 80033c6:	1ac9      	subs	r1, r1, r3
 80033c8:	e004      	b.n	80033d4 <Thread1.lto_priv.53+0xc4>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 80033ca:	4542      	cmp	r2, r8
 80033cc:	d100      	bne.n	80033d0 <Thread1.lto_priv.53+0xc0>
 80033ce:	e095      	b.n	80034fc <Thread1.lto_priv.53+0x1ec>

    delta -= p->delta;
    p = p->next;
 80033d0:	6812      	ldr	r2, [r2, #0]
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
 80033d2:	1ac9      	subs	r1, r1, r3
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 80033d4:	6893      	ldr	r3, [r2, #8]
 80033d6:	4299      	cmp	r1, r3
 80033d8:	d8f7      	bhi.n	80033ca <Thread1.lto_priv.53+0xba>
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 80033da:	4643      	mov	r3, r8
  vtp->prev = vtp->next->prev;
 80033dc:	4640      	mov	r0, r8
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 80033de:	601a      	str	r2, [r3, #0]
  vtp->prev = vtp->next->prev;
 80033e0:	6853      	ldr	r3, [r2, #4]
 80033e2:	6043      	str	r3, [r0, #4]
  vtp->prev->next = vtp;
 80033e4:	6018      	str	r0, [r3, #0]
  p->prev = vtp;
 80033e6:	6050      	str	r0, [r2, #4]
  vtp->delta = delta;
 80033e8:	6081      	str	r1, [r0, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 80033ea:	6893      	ldr	r3, [r2, #8]
 80033ec:	1a5b      	subs	r3, r3, r1
 80033ee:	6093      	str	r3, [r2, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 80033f0:	2301      	movs	r3, #1
 80033f2:	425b      	negs	r3, r3
 80033f4:	6263      	str	r3, [r4, #36]	; 0x24
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 80033f6:	69a3      	ldr	r3, [r4, #24]
 80033f8:	469a      	mov	sl, r3
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80033fa:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80033fc:	2b00      	cmp	r3, #0
 80033fe:	d000      	beq.n	8003402 <Thread1.lto_priv.53+0xf2>
 8003400:	e07f      	b.n	8003502 <Thread1.lto_priv.53+0x1f2>
 8003402:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003404:	2b00      	cmp	r3, #0
 8003406:	dd7c      	ble.n	8003502 <Thread1.lto_priv.53+0x1f2>

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8003408:	2220      	movs	r2, #32
 800340a:	2308      	movs	r3, #8
 800340c:	4651      	mov	r1, sl
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800340e:	6820      	ldr	r0, [r4, #0]
 8003410:	548b      	strb	r3, [r1, r2]

  tqp->next             = tp->queue.next;
 8003412:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003414:	605c      	str	r4, [r3, #4]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8003416:	5485      	strb	r5, [r0, r2]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8003418:	6023      	str	r3, [r4, #0]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800341a:	8f23      	ldrh	r3, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800341c:	61a0      	str	r0, [r4, #24]
 800341e:	422b      	tst	r3, r5
 8003420:	d112      	bne.n	8003448 <Thread1.lto_priv.53+0x138>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8003422:	2707      	movs	r7, #7
 8003424:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003426:	7819      	ldrb	r1, [r3, #0]
 8003428:	43b9      	bics	r1, r7
 800342a:	4329      	orrs	r1, r5
 800342c:	7019      	strb	r1, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800342e:	4651      	mov	r1, sl
 8003430:	5c8a      	ldrb	r2, [r1, r2]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8003432:	6098      	str	r0, [r3, #8]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003434:	00d1      	lsls	r1, r2, #3
 8003436:	781a      	ldrb	r2, [r3, #0]
 8003438:	403a      	ands	r2, r7
 800343a:	430a      	orrs	r2, r1
 800343c:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800343e:	4652      	mov	r2, sl
 8003440:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8003442:	60da      	str	r2, [r3, #12]
    trace_next();
 8003444:	f7ff fa7c 	bl	8002940 <trace_next.lto_priv.49>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003448:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800344c:	4652      	mov	r2, sl
 800344e:	69d2      	ldr	r2, [r2, #28]
 8003450:	3b24      	subs	r3, #36	; 0x24
 8003452:	429a      	cmp	r2, r3
 8003454:	d86d      	bhi.n	8003532 <Thread1.lto_priv.53+0x222>
 8003456:	69a0      	ldr	r0, [r4, #24]
 8003458:	4651      	mov	r1, sl
 800345a:	f7fc fe9d 	bl	8000198 <_port_switch>
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800345e:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8003460:	2800      	cmp	r0, #0
 8003462:	db69      	blt.n	8003538 <Thread1.lto_priv.53+0x228>
 8003464:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003466:	2b00      	cmp	r3, #0
 8003468:	dd66      	ble.n	8003538 <Thread1.lto_priv.53+0x228>
  if (TIME_INFINITE != timeout) {
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt)) {
 800346a:	9b04      	ldr	r3, [sp, #16]
 800346c:	2b00      	cmp	r3, #0
 800346e:	d013      	beq.n	8003498 <Thread1.lto_priv.53+0x188>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8003470:	69e3      	ldr	r3, [r4, #28]
 8003472:	4543      	cmp	r3, r8
 8003474:	d069      	beq.n	800354a <Thread1.lto_priv.53+0x23a>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8003476:	4643      	mov	r3, r8
 8003478:	685a      	ldr	r2, [r3, #4]
 800347a:	681b      	ldr	r3, [r3, #0]
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;
 800347c:	4641      	mov	r1, r8

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800347e:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8003480:	4643      	mov	r3, r8
 8003482:	681b      	ldr	r3, [r3, #0]
 8003484:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8003486:	2200      	movs	r2, #0
 8003488:	60ca      	str	r2, [r1, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800348a:	454b      	cmp	r3, r9
 800348c:	d004      	beq.n	8003498 <Thread1.lto_priv.53+0x188>
      vtp->next->delta += vtp->delta;
 800348e:	688a      	ldr	r2, [r1, #8]
 8003490:	6899      	ldr	r1, [r3, #8]
 8003492:	468c      	mov	ip, r1
 8003494:	4462      	add	r2, ip
 8003496:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003498:	2800      	cmp	r0, #0
 800349a:	d118      	bne.n	80034ce <Thread1.lto_priv.53+0x1be>
 800349c:	6823      	ldr	r3, [r4, #0]
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800349e:	6360      	str	r0, [r4, #52]	; 0x34
 80034a0:	42a3      	cmp	r3, r4
 80034a2:	d004      	beq.n	80034ae <Thread1.lto_priv.53+0x19e>
 80034a4:	69a2      	ldr	r2, [r4, #24]
 80034a6:	689b      	ldr	r3, [r3, #8]
 80034a8:	6892      	ldr	r2, [r2, #8]
 80034aa:	429a      	cmp	r2, r3
 80034ac:	d312      	bcc.n	80034d4 <Thread1.lto_priv.53+0x1c4>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80034ae:	b662      	cpsie	i
    chThdSleepMilliseconds(500);
    palClearPad(GPIOA, GPIOA_LED1);
 80034b0:	2320      	movs	r3, #32
    palClearPad(GPIOB, GPIOB_LED5);
 80034b2:	2202      	movs	r2, #2
  while (true) {
    chThdSleepMilliseconds(500);
    palSetPad(GPIOA, GPIOA_LED1);
    palSetPad(GPIOB, GPIOB_LED5);
    chThdSleepMilliseconds(500);
    palClearPad(GPIOA, GPIOA_LED1);
 80034b4:	8373      	strh	r3, [r6, #26]
    palClearPad(GPIOB, GPIOB_LED5);
 80034b6:	4b41      	ldr	r3, [pc, #260]	; (80035bc <Thread1.lto_priv.53+0x2ac>)
 80034b8:	835a      	strh	r2, [r3, #26]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80034ba:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80034bc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80034be:	2b00      	cmp	r3, #0
 80034c0:	d000      	beq.n	80034c4 <Thread1.lto_priv.53+0x1b4>
 80034c2:	e737      	b.n	8003334 <Thread1.lto_priv.53+0x24>
 80034c4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80034c6:	2b00      	cmp	r3, #0
 80034c8:	d000      	beq.n	80034cc <Thread1.lto_priv.53+0x1bc>
 80034ca:	e733      	b.n	8003334 <Thread1.lto_priv.53+0x24>
 80034cc:	e73a      	b.n	8003344 <Thread1.lto_priv.53+0x34>
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 80034ce:	483f      	ldr	r0, [pc, #252]	; (80035cc <Thread1.lto_priv.53+0x2bc>)
 80034d0:	f7ff fa4e 	bl	8002970 <chSysHalt>
 80034d4:	483e      	ldr	r0, [pc, #248]	; (80035d0 <Thread1.lto_priv.53+0x2c0>)
 80034d6:	f7ff fa4b 	bl	8002970 <chSysHalt>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 80034da:	6897      	ldr	r7, [r2, #8]
 80034dc:	42b9      	cmp	r1, r7
 80034de:	d300      	bcc.n	80034e2 <Thread1.lto_priv.53+0x1d2>
 80034e0:	e778      	b.n	80033d4 <Thread1.lto_priv.53+0xc4>
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80034e2:	68c0      	ldr	r0, [r0, #12]
 80034e4:	4218      	tst	r0, r3
 80034e6:	d02d      	beq.n	8003544 <Thread1.lto_priv.53+0x234>
 80034e8:	483a      	ldr	r0, [pc, #232]	; (80035d4 <Thread1.lto_priv.53+0x2c4>)
 80034ea:	1e0b      	subs	r3, r1, #0
 80034ec:	4283      	cmp	r3, r0
 80034ee:	d900      	bls.n	80034f2 <Thread1.lto_priv.53+0x1e2>
 80034f0:	1c03      	adds	r3, r0, #0

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 80034f2:	4463      	add	r3, ip
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80034f4:	4833      	ldr	r0, [pc, #204]	; (80035c4 <Thread1.lto_priv.53+0x2b4>)
 80034f6:	b29b      	uxth	r3, r3
 80034f8:	6343      	str	r3, [r0, #52]	; 0x34
 80034fa:	e76b      	b.n	80033d4 <Thread1.lto_priv.53+0xc4>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 80034fc:	4836      	ldr	r0, [pc, #216]	; (80035d8 <Thread1.lto_priv.53+0x2c8>)
 80034fe:	f7ff fa37 	bl	8002970 <chSysHalt>
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#11");
 8003502:	4836      	ldr	r0, [pc, #216]	; (80035dc <Thread1.lto_priv.53+0x2cc>)
 8003504:	f7ff fa34 	bl	8002970 <chSysHalt>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
 8003508:	4647      	mov	r7, r8
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 800350a:	9201      	str	r2, [sp, #4]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800350c:	607a      	str	r2, [r7, #4]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
 800350e:	61e7      	str	r7, [r4, #28]
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 8003510:	4642      	mov	r2, r8

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
 8003512:	6227      	str	r7, [r4, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 8003514:	465f      	mov	r7, fp
 8003516:	6097      	str	r7, [r2, #8]
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8003518:	68c2      	ldr	r2, [r0, #12]
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 800351a:	8521      	strh	r1, [r4, #40]	; 0x28
 800351c:	401a      	ands	r2, r3
 800351e:	4694      	mov	ip, r2
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8003520:	d10d      	bne.n	800353e <Thread1.lto_priv.53+0x22e>
 8003522:	4a25      	ldr	r2, [pc, #148]	; (80035b8 <Thread1.lto_priv.53+0x2a8>)
 8003524:	188a      	adds	r2, r1, r2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003526:	b292      	uxth	r2, r2
 8003528:	6342      	str	r2, [r0, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800352a:	4662      	mov	r2, ip
 800352c:	6102      	str	r2, [r0, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800352e:	60c3      	str	r3, [r0, #12]
 8003530:	e761      	b.n	80033f6 <Thread1.lto_priv.53+0xe6>
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8003532:	482b      	ldr	r0, [pc, #172]	; (80035e0 <Thread1.lto_priv.53+0x2d0>)
 8003534:	f7ff fa1c 	bl	8002970 <chSysHalt>
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#10");
 8003538:	482a      	ldr	r0, [pc, #168]	; (80035e4 <Thread1.lto_priv.53+0x2d4>)
 800353a:	f7ff fa19 	bl	8002970 <chSysHalt>
 800353e:	482a      	ldr	r0, [pc, #168]	; (80035e8 <Thread1.lto_priv.53+0x2d8>)
 8003540:	f7ff fa16 	bl	8002970 <chSysHalt>
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8003544:	4829      	ldr	r0, [pc, #164]	; (80035ec <Thread1.lto_priv.53+0x2dc>)
 8003546:	f7ff fa13 	bl	8002970 <chSysHalt>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 800354a:	4643      	mov	r3, r8
 800354c:	6819      	ldr	r1, [r3, #0]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 800354e:	464b      	mov	r3, r9

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8003550:	61e1      	str	r1, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8003552:	4642      	mov	r2, r8
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8003554:	604b      	str	r3, [r1, #4]
  vtp->func = NULL;
 8003556:	2300      	movs	r3, #0
 8003558:	60d3      	str	r3, [r2, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800355a:	4549      	cmp	r1, r9
 800355c:	d023      	beq.n	80035a6 <Thread1.lto_priv.53+0x296>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800355e:	6893      	ldr	r3, [r2, #8]
 8003560:	688a      	ldr	r2, [r1, #8]
 8003562:	189a      	adds	r2, r3, r2
 8003564:	608a      	str	r2, [r1, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8003566:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8003568:	469c      	mov	ip, r3
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800356a:	4b16      	ldr	r3, [pc, #88]	; (80035c4 <Thread1.lto_priv.53+0x2b4>)
 800356c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 800356e:	4663      	mov	r3, ip
 8003570:	1ac9      	subs	r1, r1, r3
 8003572:	b289      	uxth	r1, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8003574:	428a      	cmp	r2, r1
 8003576:	d98f      	bls.n	8003498 <Thread1.lto_priv.53+0x188>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8003578:	1a53      	subs	r3, r2, r1

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 800357a:	2b01      	cmp	r3, #1
 800357c:	d90c      	bls.n	8003598 <Thread1.lto_priv.53+0x288>
 800357e:	1e13      	subs	r3, r2, #0
 8003580:	4a14      	ldr	r2, [pc, #80]	; (80035d4 <Thread1.lto_priv.53+0x2c4>)
 8003582:	4293      	cmp	r3, r2
 8003584:	d900      	bls.n	8003588 <Thread1.lto_priv.53+0x278>
 8003586:	1c13      	adds	r3, r2, #0
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8003588:	4a0e      	ldr	r2, [pc, #56]	; (80035c4 <Thread1.lto_priv.53+0x2b4>)

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 800358a:	4463      	add	r3, ip
 800358c:	68d1      	ldr	r1, [r2, #12]
 800358e:	b29b      	uxth	r3, r3
 8003590:	0789      	lsls	r1, r1, #30
 8003592:	d5d7      	bpl.n	8003544 <Thread1.lto_priv.53+0x234>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003594:	6353      	str	r3, [r2, #52]	; 0x34
 8003596:	e77f      	b.n	8003498 <Thread1.lto_priv.53+0x188>
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
 8003598:	4a0e      	ldr	r2, [pc, #56]	; (80035d4 <Thread1.lto_priv.53+0x2c4>)
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800359a:	1c8b      	adds	r3, r1, #2
 800359c:	4293      	cmp	r3, r2
 800359e:	d9f3      	bls.n	8003588 <Thread1.lto_priv.53+0x278>
 80035a0:	4813      	ldr	r0, [pc, #76]	; (80035f0 <Thread1.lto_priv.53+0x2e0>)
 80035a2:	f7ff f9e5 	bl	8002970 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80035a6:	4a07      	ldr	r2, [pc, #28]	; (80035c4 <Thread1.lto_priv.53+0x2b4>)
 80035a8:	60d3      	str	r3, [r2, #12]
 80035aa:	e775      	b.n	8003498 <Thread1.lto_priv.53+0x188>
 80035ac:	20000700 	.word	0x20000700
 80035b0:	08005974 	.word	0x08005974
 80035b4:	08005808 	.word	0x08005808
 80035b8:	00001388 	.word	0x00001388
 80035bc:	48000400 	.word	0x48000400
 80035c0:	08003161 	.word	0x08003161
 80035c4:	40000400 	.word	0x40000400
 80035c8:	2000071c 	.word	0x2000071c
 80035cc:	08005810 	.word	0x08005810
 80035d0:	08005860 	.word	0x08005860
 80035d4:	0000ffff 	.word	0x0000ffff
 80035d8:	08005950 	.word	0x08005950
 80035dc:	080058f4 	.word	0x080058f4
 80035e0:	080058e4 	.word	0x080058e4
 80035e4:	080058dc 	.word	0x080058dc
 80035e8:	0800597c 	.word	0x0800597c
 80035ec:	0800595c 	.word	0x0800595c
 80035f0:	08005968 	.word	0x08005968
	...

08003600 <NMI_Handler>:
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003600:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8003604:	3320      	adds	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8003606:	f383 8809 	msr	PSP, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800360a:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 800360c:	4770      	bx	lr
 800360e:	46c0      	nop			; (mov r8, r8)

08003610 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8003610:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8003612:	4c54      	ldr	r4, [pc, #336]	; (8003764 <chMtxUnlock+0x154>)
 8003614:	69a3      	ldr	r3, [r4, #24]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8003616:	2800      	cmp	r0, #0
 8003618:	d011      	beq.n	800363e <chMtxUnlock+0x2e>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800361a:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800361c:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800361e:	2a00      	cmp	r2, #0
 8003620:	d102      	bne.n	8003628 <chMtxUnlock+0x18>
 8003622:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003624:	2a00      	cmp	r2, #0
 8003626:	d002      	beq.n	800362e <chMtxUnlock+0x1e>
    chSysHalt("SV#4");
 8003628:	484f      	ldr	r0, [pc, #316]	; (8003768 <chMtxUnlock+0x158>)
 800362a:	f7ff f9a1 	bl	8002970 <chSysHalt>
  }
  _dbg_enter_lock();
 800362e:	2101      	movs	r1, #1
 8003630:	6361      	str	r1, [r4, #52]	; 0x34

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8003632:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8003634:	2900      	cmp	r1, #0
 8003636:	d002      	beq.n	800363e <chMtxUnlock+0x2e>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8003638:	688d      	ldr	r5, [r1, #8]
 800363a:	429d      	cmp	r5, r3
 800363c:	d002      	beq.n	8003644 <chMtxUnlock+0x34>
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800363e:	484b      	ldr	r0, [pc, #300]	; (800376c <chMtxUnlock+0x15c>)
 8003640:	f7ff f996 	bl	8002970 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8003644:	4288      	cmp	r0, r1
 8003646:	d1fa      	bne.n	800363e <chMtxUnlock+0x2e>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8003648:	68c3      	ldr	r3, [r0, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800364a:	6801      	ldr	r1, [r0, #0]
 800364c:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800364e:	4288      	cmp	r0, r1
 8003650:	d033      	beq.n	80036ba <chMtxUnlock+0xaa>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8003652:	6bee      	ldr	r6, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8003654:	2b00      	cmp	r3, #0
 8003656:	d009      	beq.n	800366c <chMtxUnlock+0x5c>
 8003658:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800365a:	4293      	cmp	r3, r2
 800365c:	d003      	beq.n	8003666 <chMtxUnlock+0x56>
            (lmp->queue.next->prio > newprio)) {
 800365e:	6892      	ldr	r2, [r2, #8]
 8003660:	4296      	cmp	r6, r2
 8003662:	d200      	bcs.n	8003666 <chMtxUnlock+0x56>
 8003664:	1c16      	adds	r6, r2, #0
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8003666:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8003668:	2b00      	cmp	r3, #0
 800366a:	d1f5      	bne.n	8003658 <chMtxUnlock+0x48>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800366c:	680b      	ldr	r3, [r1, #0]
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800366e:	60ae      	str	r6, [r5, #8]
 8003670:	6003      	str	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003672:	6058      	str	r0, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8003674:	6b8b      	ldr	r3, [r1, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8003676:	6081      	str	r1, [r0, #8]
      mp->next = tp->mtxlist;
 8003678:	60c3      	str	r3, [r0, #12]
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800367a:	2320      	movs	r3, #32
      tp->mtxlist = mp;
 800367c:	6388      	str	r0, [r1, #56]	; 0x38
 800367e:	5cca      	ldrb	r2, [r1, r3]
 8003680:	2a00      	cmp	r2, #0
 8003682:	d02a      	beq.n	80036da <chMtxUnlock+0xca>
 8003684:	2a0f      	cmp	r2, #15
 8003686:	d028      	beq.n	80036da <chMtxUnlock+0xca>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8003688:	2200      	movs	r2, #0
 800368a:	54ca      	strb	r2, [r1, r3]
  cp = (thread_t *)&ch.rlist.queue;
 800368c:	1c23      	adds	r3, r4, #0
 800368e:	688a      	ldr	r2, [r1, #8]
  do {
    cp = cp->queue.next;
 8003690:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8003692:	6898      	ldr	r0, [r3, #8]
 8003694:	4290      	cmp	r0, r2
 8003696:	d2fb      	bcs.n	8003690 <chMtxUnlock+0x80>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8003698:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800369a:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 800369c:	604a      	str	r2, [r1, #4]
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 800369e:	69a5      	ldr	r5, [r4, #24]
  tp->queue.prev->queue.next = tp;
 80036a0:	6011      	str	r1, [r2, #0]
 80036a2:	6822      	ldr	r2, [r4, #0]
  cp->queue.prev             = tp;
 80036a4:	6059      	str	r1, [r3, #4]
 80036a6:	68a9      	ldr	r1, [r5, #8]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 80036a8:	6893      	ldr	r3, [r2, #8]
 80036aa:	428b      	cmp	r3, r1
 80036ac:	d81b      	bhi.n	80036e6 <chMtxUnlock+0xd6>
 80036ae:	6b23      	ldr	r3, [r4, #48]	; 0x30
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80036b0:	2b00      	cmp	r3, #0
 80036b2:	d003      	beq.n	80036bc <chMtxUnlock+0xac>
    chSysHalt("SV#5");
 80036b4:	482e      	ldr	r0, [pc, #184]	; (8003770 <chMtxUnlock+0x160>)
 80036b6:	f7ff f95b 	bl	8002970 <chSysHalt>
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 80036ba:	6082      	str	r2, [r0, #8]
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80036bc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80036be:	2b00      	cmp	r3, #0
 80036c0:	ddf8      	ble.n	80036b4 <chMtxUnlock+0xa4>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80036c2:	2300      	movs	r3, #0
 80036c4:	6363      	str	r3, [r4, #52]	; 0x34
 80036c6:	6823      	ldr	r3, [r4, #0]
 80036c8:	42a3      	cmp	r3, r4
 80036ca:	d004      	beq.n	80036d6 <chMtxUnlock+0xc6>
 80036cc:	69a2      	ldr	r2, [r4, #24]
 80036ce:	689b      	ldr	r3, [r3, #8]
 80036d0:	6892      	ldr	r2, [r2, #8]
 80036d2:	429a      	cmp	r2, r3
 80036d4:	d304      	bcc.n	80036e0 <chMtxUnlock+0xd0>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80036d6:	b662      	cpsie	i
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 80036d8:	bd70      	pop	{r4, r5, r6, pc}
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80036da:	4826      	ldr	r0, [pc, #152]	; (8003774 <chMtxUnlock+0x164>)
 80036dc:	f7ff f948 	bl	8002970 <chSysHalt>
 80036e0:	4825      	ldr	r0, [pc, #148]	; (8003778 <chMtxUnlock+0x168>)
 80036e2:	f7ff f945 	bl	8002970 <chSysHalt>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80036e6:	6813      	ldr	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80036e8:	2001      	movs	r0, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80036ea:	605c      	str	r4, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80036ec:	6023      	str	r3, [r4, #0]
 80036ee:	2320      	movs	r3, #32
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80036f0:	61a2      	str	r2, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 80036f2:	54d0      	strb	r0, [r2, r3]
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80036f4:	5ce8      	ldrb	r0, [r5, r3]
 80036f6:	2800      	cmp	r0, #0
 80036f8:	d02e      	beq.n	8003758 <chMtxUnlock+0x148>
 80036fa:	280f      	cmp	r0, #15
 80036fc:	d02c      	beq.n	8003758 <chMtxUnlock+0x148>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80036fe:	2000      	movs	r0, #0
 8003700:	54e8      	strb	r0, [r5, r3]
  cp = (thread_t *)&ch.rlist.queue;
 8003702:	1c23      	adds	r3, r4, #0
  do {
    cp = cp->queue.next;
 8003704:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8003706:	6898      	ldr	r0, [r3, #8]
 8003708:	4281      	cmp	r1, r0
 800370a:	d3fb      	bcc.n	8003704 <chMtxUnlock+0xf4>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800370c:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800370e:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8003710:	6069      	str	r1, [r5, #4]
  tp->queue.prev->queue.next = tp;
 8003712:	600d      	str	r5, [r1, #0]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8003714:	2101      	movs	r1, #1
  cp->queue.prev             = tp;
 8003716:	605d      	str	r5, [r3, #4]
 8003718:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800371a:	420b      	tst	r3, r1
 800371c:	d111      	bne.n	8003742 <chMtxUnlock+0x132>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800371e:	2607      	movs	r6, #7
 8003720:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8003722:	7818      	ldrb	r0, [r3, #0]
 8003724:	43b0      	bics	r0, r6
 8003726:	4308      	orrs	r0, r1
 8003728:	7018      	strb	r0, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800372a:	311f      	adds	r1, #31
 800372c:	5c69      	ldrb	r1, [r5, r1]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800372e:	609a      	str	r2, [r3, #8]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8003730:	00c8      	lsls	r0, r1, #3
 8003732:	7819      	ldrb	r1, [r3, #0]
 8003734:	4031      	ands	r1, r6
 8003736:	4301      	orrs	r1, r0
 8003738:	7019      	strb	r1, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800373a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800373c:	60da      	str	r2, [r3, #12]
    trace_next();
 800373e:	f7ff f8ff 	bl	8002940 <trace_next.lto_priv.49>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003742:	f3ef 8309 	mrs	r3, PSP

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8003746:	69ea      	ldr	r2, [r5, #28]
 8003748:	3b24      	subs	r3, #36	; 0x24
 800374a:	429a      	cmp	r2, r3
 800374c:	d807      	bhi.n	800375e <chMtxUnlock+0x14e>
 800374e:	69a0      	ldr	r0, [r4, #24]
 8003750:	1c29      	adds	r1, r5, #0
 8003752:	f7fc fd21 	bl	8000198 <_port_switch>
 8003756:	e7aa      	b.n	80036ae <chMtxUnlock+0x9e>
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003758:	4808      	ldr	r0, [pc, #32]	; (800377c <chMtxUnlock+0x16c>)
 800375a:	f7ff f909 	bl	8002970 <chSysHalt>

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800375e:	4808      	ldr	r0, [pc, #32]	; (8003780 <chMtxUnlock+0x170>)
 8003760:	f7ff f906 	bl	8002970 <chSysHalt>
 8003764:	20000700 	.word	0x20000700
 8003768:	08005808 	.word	0x08005808
 800376c:	08005944 	.word	0x08005944
 8003770:	08005810 	.word	0x08005810
 8003774:	08005abc 	.word	0x08005abc
 8003778:	08005b24 	.word	0x08005b24
 800377c:	08005aa8 	.word	0x08005aa8
 8003780:	080058e4 	.word	0x080058e4
	...

08003790 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8003790:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8003792:	4e53      	ldr	r6, [pc, #332]	; (80038e0 <chMtxLockS+0x150>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8003794:	1c05      	adds	r5, r0, #0
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003796:	6b33      	ldr	r3, [r6, #48]	; 0x30
  thread_t *ctp = currp;
 8003798:	69b4      	ldr	r4, [r6, #24]
 800379a:	2b00      	cmp	r3, #0
 800379c:	d142      	bne.n	8003824 <chMtxLockS+0x94>
 800379e:	6b73      	ldr	r3, [r6, #52]	; 0x34
 80037a0:	2b00      	cmp	r3, #0
 80037a2:	dd3f      	ble.n	8003824 <chMtxLockS+0x94>

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);
 80037a4:	2800      	cmp	r0, #0
 80037a6:	d03a      	beq.n	800381e <chMtxLockS+0x8e>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 80037a8:	6882      	ldr	r2, [r0, #8]
 80037aa:	2a00      	cmp	r2, #0
 80037ac:	d077      	beq.n	800389e <chMtxLockS+0x10e>
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80037ae:	2320      	movs	r3, #32
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80037b0:	68a1      	ldr	r1, [r4, #8]
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80037b2:	469c      	mov	ip, r3
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80037b4:	6893      	ldr	r3, [r2, #8]
 80037b6:	428b      	cmp	r3, r1
 80037b8:	d208      	bcs.n	80037cc <chMtxLockS+0x3c>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80037ba:	4663      	mov	r3, ip

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 80037bc:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80037be:	5cd3      	ldrb	r3, [r2, r3]
 80037c0:	2b06      	cmp	r3, #6
 80037c2:	d053      	beq.n	800386c <chMtxLockS+0xdc>
 80037c4:	2b07      	cmp	r3, #7
 80037c6:	d042      	beq.n	800384e <chMtxLockS+0xbe>
 80037c8:	2b00      	cmp	r3, #0
 80037ca:	d02e      	beq.n	800382a <chMtxLockS+0x9a>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80037cc:	1c2b      	adds	r3, r5, #0
 80037ce:	e003      	b.n	80037d8 <chMtxLockS+0x48>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80037d0:	689a      	ldr	r2, [r3, #8]
 80037d2:	68a1      	ldr	r1, [r4, #8]
 80037d4:	428a      	cmp	r2, r1
 80037d6:	d302      	bcc.n	80037de <chMtxLockS+0x4e>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80037d8:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80037da:	429d      	cmp	r5, r3
 80037dc:	d1f8      	bne.n	80037d0 <chMtxLockS+0x40>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80037de:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80037e0:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 80037e2:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 80037e4:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80037e6:	605c      	str	r4, [r3, #4]
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 80037e8:	2220      	movs	r2, #32
 80037ea:	2306      	movs	r3, #6
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 80037ec:	6265      	str	r5, [r4, #36]	; 0x24
 80037ee:	54a3      	strb	r3, [r4, r2]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80037f0:	6833      	ldr	r3, [r6, #0]

  tqp->next             = tp->queue.next;
 80037f2:	6819      	ldr	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80037f4:	604e      	str	r6, [r1, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80037f6:	6031      	str	r1, [r6, #0]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80037f8:	2101      	movs	r1, #1
 80037fa:	5499      	strb	r1, [r3, r2]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80037fc:	8f30      	ldrh	r0, [r6, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80037fe:	61b3      	str	r3, [r6, #24]
 8003800:	4201      	tst	r1, r0
 8003802:	d051      	beq.n	80038a8 <chMtxLockS+0x118>
 8003804:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8003808:	69e2      	ldr	r2, [r4, #28]
 800380a:	3b24      	subs	r3, #36	; 0x24
 800380c:	429a      	cmp	r2, r3
 800380e:	d860      	bhi.n	80038d2 <chMtxLockS+0x142>
 8003810:	69b0      	ldr	r0, [r6, #24]
 8003812:	1c21      	adds	r1, r4, #0
 8003814:	f7fc fcc0 	bl	8000198 <_port_switch>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 8003818:	68ab      	ldr	r3, [r5, #8]
 800381a:	42a3      	cmp	r3, r4
 800381c:	d05c      	beq.n	80038d8 <chMtxLockS+0x148>
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);
 800381e:	4831      	ldr	r0, [pc, #196]	; (80038e4 <chMtxLockS+0x154>)
 8003820:	f7ff f8a6 	bl	8002970 <chSysHalt>
    chSysHalt("SV#11");
 8003824:	4830      	ldr	r0, [pc, #192]	; (80038e8 <chMtxLockS+0x158>)
 8003826:	f7ff f8a3 	bl	8002970 <chSysHalt>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800382a:	6850      	ldr	r0, [r2, #4]
 800382c:	6817      	ldr	r7, [r2, #0]
 800382e:	6007      	str	r7, [r0, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8003830:	6817      	ldr	r7, [r2, #0]
 8003832:	6078      	str	r0, [r7, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8003834:	2020      	movs	r0, #32
 8003836:	5413      	strb	r3, [r2, r0]
  cp = (thread_t *)&ch.rlist.queue;
 8003838:	1c33      	adds	r3, r6, #0
  do {
    cp = cp->queue.next;
 800383a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800383c:	6898      	ldr	r0, [r3, #8]
 800383e:	4281      	cmp	r1, r0
 8003840:	d9fb      	bls.n	800383a <chMtxLockS+0xaa>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8003842:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8003844:	6859      	ldr	r1, [r3, #4]
 8003846:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8003848:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 800384a:	605a      	str	r2, [r3, #4]
 800384c:	e7be      	b.n	80037cc <chMtxLockS+0x3c>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800384e:	6853      	ldr	r3, [r2, #4]
 8003850:	6810      	ldr	r0, [r2, #0]
 8003852:	6018      	str	r0, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8003854:	6810      	ldr	r0, [r2, #0]
 8003856:	6043      	str	r3, [r0, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8003858:	6a50      	ldr	r0, [r2, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800385a:	1c03      	adds	r3, r0, #0
 800385c:	e002      	b.n	8003864 <chMtxLockS+0xd4>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800385e:	689f      	ldr	r7, [r3, #8]
 8003860:	428f      	cmp	r7, r1
 8003862:	d3ee      	bcc.n	8003842 <chMtxLockS+0xb2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8003864:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8003866:	4298      	cmp	r0, r3
 8003868:	d1f9      	bne.n	800385e <chMtxLockS+0xce>
 800386a:	e7ea      	b.n	8003842 <chMtxLockS+0xb2>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800386c:	6853      	ldr	r3, [r2, #4]
 800386e:	6810      	ldr	r0, [r2, #0]
 8003870:	6018      	str	r0, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8003872:	6810      	ldr	r0, [r2, #0]
 8003874:	6043      	str	r3, [r0, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8003876:	6a50      	ldr	r0, [r2, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8003878:	1c03      	adds	r3, r0, #0
 800387a:	e002      	b.n	8003882 <chMtxLockS+0xf2>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800387c:	689f      	ldr	r7, [r3, #8]
 800387e:	428f      	cmp	r7, r1
 8003880:	d302      	bcc.n	8003888 <chMtxLockS+0xf8>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8003882:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8003884:	4298      	cmp	r0, r3
 8003886:	d1f9      	bne.n	800387c <chMtxLockS+0xec>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8003888:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800388a:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 800388c:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 800388e:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8003890:	605a      	str	r2, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 8003892:	6882      	ldr	r2, [r0, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8003894:	68a1      	ldr	r1, [r4, #8]
 8003896:	6893      	ldr	r3, [r2, #8]
 8003898:	428b      	cmp	r3, r1
 800389a:	d38e      	bcc.n	80037ba <chMtxLockS+0x2a>
 800389c:	e796      	b.n	80037cc <chMtxLockS+0x3c>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 800389e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 80038a0:	6084      	str	r4, [r0, #8]
    mp->next = ctp->mtxlist;
 80038a2:	60c3      	str	r3, [r0, #12]
    ctp->mtxlist = mp;
 80038a4:	63a0      	str	r0, [r4, #56]	; 0x38
  }
}
 80038a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80038a8:	2707      	movs	r7, #7
 80038aa:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
 80038ac:	46bc      	mov	ip, r7
 80038ae:	7808      	ldrb	r0, [r1, #0]
 80038b0:	43b8      	bics	r0, r7
 80038b2:	2701      	movs	r7, #1
 80038b4:	4338      	orrs	r0, r7
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80038b6:	4667      	mov	r7, ip
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80038b8:	7008      	strb	r0, [r1, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80038ba:	5ca0      	ldrb	r0, [r4, r2]
 80038bc:	780a      	ldrb	r2, [r1, #0]
 80038be:	00c0      	lsls	r0, r0, #3
 80038c0:	403a      	ands	r2, r7
 80038c2:	4302      	orrs	r2, r0
 80038c4:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80038c6:	608b      	str	r3, [r1, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80038c8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80038ca:	60cb      	str	r3, [r1, #12]
    trace_next();
 80038cc:	f7ff f838 	bl	8002940 <trace_next.lto_priv.49>
 80038d0:	e798      	b.n	8003804 <chMtxLockS+0x74>
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80038d2:	4806      	ldr	r0, [pc, #24]	; (80038ec <chMtxLockS+0x15c>)
 80038d4:	f7ff f84c 	bl	8002970 <chSysHalt>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 80038d8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80038da:	42ab      	cmp	r3, r5
 80038dc:	d19f      	bne.n	800381e <chMtxLockS+0x8e>
 80038de:	e7e2      	b.n	80038a6 <chMtxLockS+0x116>
 80038e0:	20000700 	.word	0x20000700
 80038e4:	08005998 	.word	0x08005998
 80038e8:	080058f4 	.word	0x080058f4
 80038ec:	080058e4 	.word	0x080058e4

080038f0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80038f0:	b510      	push	{r4, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80038f2:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80038f4:	4c12      	ldr	r4, [pc, #72]	; (8003940 <chMtxLock+0x50>)
 80038f6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80038f8:	2b00      	cmp	r3, #0
 80038fa:	d102      	bne.n	8003902 <chMtxLock+0x12>
 80038fc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80038fe:	2b00      	cmp	r3, #0
 8003900:	d002      	beq.n	8003908 <chMtxLock+0x18>
    chSysHalt("SV#4");
 8003902:	4810      	ldr	r0, [pc, #64]	; (8003944 <chMtxLock+0x54>)
 8003904:	f7ff f834 	bl	8002970 <chSysHalt>
  }
  _dbg_enter_lock();
 8003908:	2301      	movs	r3, #1
 800390a:	6363      	str	r3, [r4, #52]	; 0x34

  chSysLock();
  chMtxLockS(mp);
 800390c:	f7ff ff40 	bl	8003790 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003910:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003912:	2b00      	cmp	r3, #0
 8003914:	d10d      	bne.n	8003932 <chMtxLock+0x42>
 8003916:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003918:	2a00      	cmp	r2, #0
 800391a:	dd0a      	ble.n	8003932 <chMtxLock+0x42>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800391c:	6363      	str	r3, [r4, #52]	; 0x34
 800391e:	6823      	ldr	r3, [r4, #0]
 8003920:	42a3      	cmp	r3, r4
 8003922:	d004      	beq.n	800392e <chMtxLock+0x3e>
 8003924:	69a2      	ldr	r2, [r4, #24]
 8003926:	689b      	ldr	r3, [r3, #8]
 8003928:	6892      	ldr	r2, [r2, #8]
 800392a:	429a      	cmp	r2, r3
 800392c:	d304      	bcc.n	8003938 <chMtxLock+0x48>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800392e:	b662      	cpsie	i
  chSysUnlock();
}
 8003930:	bd10      	pop	{r4, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 8003932:	4805      	ldr	r0, [pc, #20]	; (8003948 <chMtxLock+0x58>)
 8003934:	f7ff f81c 	bl	8002970 <chSysHalt>
 8003938:	4804      	ldr	r0, [pc, #16]	; (800394c <chMtxLock+0x5c>)
 800393a:	f7ff f819 	bl	8002970 <chSysHalt>
 800393e:	46c0      	nop			; (mov r8, r8)
 8003940:	20000700 	.word	0x20000700
 8003944:	08005808 	.word	0x08005808
 8003948:	08005810 	.word	0x08005810
 800394c:	08005b24 	.word	0x08005b24

08003950 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 8003950:	20bc      	movs	r0, #188	; 0xbc
 8003952:	4a47      	ldr	r2, [pc, #284]	; (8003a70 <__early_init+0x120>)
 8003954:	03c0      	lsls	r0, r0, #15
 8003956:	6a91      	ldr	r1, [r2, #40]	; 0x28
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8003958:	b530      	push	{r4, r5, lr}

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 800395a:	4301      	orrs	r1, r0
 800395c:	6291      	str	r1, [r2, #40]	; 0x28
 800395e:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8003960:	4944      	ldr	r1, [pc, #272]	; (8003a74 <__early_init+0x124>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8003962:	4c45      	ldr	r4, [pc, #276]	; (8003a78 <__early_init+0x128>)

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 8003964:	4019      	ands	r1, r3
 8003966:	6291      	str	r1, [r2, #40]	; 0x28
 8003968:	6a93      	ldr	r3, [r2, #40]	; 0x28
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 800396a:	6953      	ldr	r3, [r2, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800396c:	2180      	movs	r1, #128	; 0x80
static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 800396e:	4303      	orrs	r3, r0
 8003970:	6153      	str	r3, [r2, #20]
 8003972:	6953      	ldr	r3, [r2, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003974:	2390      	movs	r3, #144	; 0x90
  gpiop->OSPEEDR = config->ospeedr;
 8003976:	2001      	movs	r0, #1
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003978:	05db      	lsls	r3, r3, #23
 800397a:	00c9      	lsls	r1, r1, #3
 800397c:	6059      	str	r1, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 800397e:	493f      	ldr	r1, [pc, #252]	; (8003a7c <__early_init+0x12c>)
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8003980:	4240      	negs	r0, r0
 8003982:	6098      	str	r0, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8003984:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 8003986:	493e      	ldr	r1, [pc, #248]	; (8003a80 <__early_init+0x130>)
  gpiop->AFRL    = config->afrl;
 8003988:	2588      	movs	r5, #136	; 0x88
static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 800398a:	6159      	str	r1, [r3, #20]
  gpiop->AFRL    = config->afrl;
 800398c:	2188      	movs	r1, #136	; 0x88
 800398e:	0149      	lsls	r1, r1, #5
 8003990:	6219      	str	r1, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8003992:	2100      	movs	r1, #0
 8003994:	6259      	str	r1, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8003996:	601c      	str	r4, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003998:	24c0      	movs	r4, #192	; 0xc0
 800399a:	4b3a      	ldr	r3, [pc, #232]	; (8003a84 <__early_init+0x134>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 800399c:	056d      	lsls	r5, r5, #21
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800399e:	605c      	str	r4, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80039a0:	4c39      	ldr	r4, [pc, #228]	; (8003a88 <__early_init+0x138>)
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80039a2:	6098      	str	r0, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80039a4:	60dc      	str	r4, [r3, #12]
  gpiop->ODR     = config->odr;
 80039a6:	4c39      	ldr	r4, [pc, #228]	; (8003a8c <__early_init+0x13c>)
 80039a8:	615c      	str	r4, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80039aa:	621d      	str	r5, [r3, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 80039ac:	4d38      	ldr	r5, [pc, #224]	; (8003a90 <__early_init+0x140>)
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 80039ae:	6259      	str	r1, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80039b0:	601d      	str	r5, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80039b2:	4b38      	ldr	r3, [pc, #224]	; (8003a94 <__early_init+0x144>)
 80039b4:	6059      	str	r1, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80039b6:	6098      	str	r0, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80039b8:	4837      	ldr	r0, [pc, #220]	; (8003a98 <__early_init+0x148>)
 80039ba:	60d8      	str	r0, [r3, #12]
  gpiop->ODR     = config->odr;
 80039bc:	615c      	str	r4, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80039be:	6219      	str	r1, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80039c0:	6259      	str	r1, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80039c2:	6019      	str	r1, [r3, #0]
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80039c4:	2301      	movs	r3, #1
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80039c6:	2002      	movs	r0, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80039c8:	6811      	ldr	r1, [r2, #0]
 80039ca:	430b      	orrs	r3, r1
 80039cc:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80039ce:	6811      	ldr	r1, [r2, #0]
 80039d0:	4b27      	ldr	r3, [pc, #156]	; (8003a70 <__early_init+0x120>)
 80039d2:	4208      	tst	r0, r1
 80039d4:	d0fb      	beq.n	80039ce <__early_init+0x7e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 80039d6:	2103      	movs	r1, #3
 80039d8:	685a      	ldr	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80039da:	200c      	movs	r0, #12
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 80039dc:	438a      	bics	r2, r1
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80039de:	1c19      	adds	r1, r3, #0
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 80039e0:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80039e2:	684b      	ldr	r3, [r1, #4]
 80039e4:	4a22      	ldr	r2, [pc, #136]	; (8003a70 <__early_init+0x120>)
 80039e6:	4003      	ands	r3, r0
 80039e8:	d1fb      	bne.n	80039e2 <__early_init+0x92>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80039ea:	20f9      	movs	r0, #249	; 0xf9
 80039ec:	6811      	ldr	r1, [r2, #0]
 80039ee:	4001      	ands	r1, r0
 80039f0:	6011      	str	r1, [r2, #0]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 80039f2:	2180      	movs	r1, #128	; 0x80
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 80039f4:	2080      	movs	r0, #128	; 0x80
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80039f6:	6053      	str	r3, [r2, #4]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 80039f8:	6813      	ldr	r3, [r2, #0]
 80039fa:	0249      	lsls	r1, r1, #9
 80039fc:	430b      	orrs	r3, r1
 80039fe:	6013      	str	r3, [r2, #0]
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 8003a00:	0280      	lsls	r0, r0, #10
 8003a02:	6811      	ldr	r1, [r2, #0]
 8003a04:	4b1a      	ldr	r3, [pc, #104]	; (8003a70 <__early_init+0x120>)
 8003a06:	4201      	tst	r1, r0
 8003a08:	d0fb      	beq.n	8003a02 <__early_init+0xb2>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8003a0a:	2201      	movs	r2, #1
 8003a0c:	6b59      	ldr	r1, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8003a0e:	2002      	movs	r0, #2
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8003a10:	430a      	orrs	r2, r1
 8003a12:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8003a14:	1c1a      	adds	r2, r3, #0
 8003a16:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8003a18:	4b15      	ldr	r3, [pc, #84]	; (8003a70 <__early_init+0x120>)
 8003a1a:	4208      	tst	r0, r1
 8003a1c:	d0fb      	beq.n	8003a16 <__early_init+0xc6>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8003a1e:	2201      	movs	r2, #1
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8003a20:	2002      	movs	r0, #2
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8003a22:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8003a24:	430a      	orrs	r2, r1
 8003a26:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8003a28:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003a2a:	4911      	ldr	r1, [pc, #68]	; (8003a70 <__early_init+0x120>)
 8003a2c:	4210      	tst	r0, r2
 8003a2e:	d0fb      	beq.n	8003a28 <__early_init+0xd8>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  /* CFGR2 must be configured first since CFGR value could change CFGR2 */
  RCC->CFGR2 = STM32_PREDIV;
 8003a30:	2302      	movs	r3, #2
 8003a32:	62cb      	str	r3, [r1, #44]	; 0x2c
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8003a34:	23a0      	movs	r3, #160	; 0xa0
 8003a36:	02db      	lsls	r3, r3, #11
 8003a38:	604b      	str	r3, [r1, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE |
               ((STM32_PREDIV & STM32_PLLXTPRE_MASK) << STM32_PLLXTPRE_OFFSET);
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
 8003a3a:	2311      	movs	r3, #17
 8003a3c:	630b      	str	r3, [r1, #48]	; 0x30
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8003a3e:	2101      	movs	r1, #1
  while (!(RCC->CR & RCC_CR_PLLRDY))
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8003a40:	4a16      	ldr	r2, [pc, #88]	; (8003a9c <__early_init+0x14c>)
 8003a42:	3b01      	subs	r3, #1
 8003a44:	6013      	str	r3, [r2, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8003a46:	6813      	ldr	r3, [r2, #0]
 8003a48:	4219      	tst	r1, r3
 8003a4a:	d1fc      	bne.n	8003a46 <__early_init+0xf6>
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8003a4c:	2301      	movs	r3, #1
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8003a4e:	200c      	movs	r0, #12
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8003a50:	4a07      	ldr	r2, [pc, #28]	; (8003a70 <__early_init+0x120>)
 8003a52:	6851      	ldr	r1, [r2, #4]
 8003a54:	430b      	orrs	r3, r1
 8003a56:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8003a58:	6853      	ldr	r3, [r2, #4]
 8003a5a:	4905      	ldr	r1, [pc, #20]	; (8003a70 <__early_init+0x120>)
 8003a5c:	4003      	ands	r3, r0
 8003a5e:	2b04      	cmp	r3, #4
 8003a60:	d1fa      	bne.n	8003a58 <__early_init+0x108>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8003a62:	698a      	ldr	r2, [r1, #24]
 8003a64:	3b03      	subs	r3, #3
 8003a66:	4313      	orrs	r3, r2
 8003a68:	618b      	str	r3, [r1, #24]
 8003a6a:	698b      	ldr	r3, [r1, #24]
 */
void __early_init(void) {

  stm32_gpio_init();
  stm32_clock_init();
}
 8003a6c:	bd30      	pop	{r4, r5, pc}
 8003a6e:	46c0      	nop			; (mov r8, r8)
 8003a70:	40021000 	.word	0x40021000
 8003a74:	ffa1ffff 	.word	0xffa1ffff
 8003a78:	282054ac 	.word	0x282054ac
 8003a7c:	65555555 	.word	0x65555555
 8003a80:	0000ff1f 	.word	0x0000ff1f
 8003a84:	48000400 	.word	0x48000400
 8003a88:	55555555 	.word	0x55555555
 8003a8c:	0000ffff 	.word	0x0000ffff
 8003a90:	0000a005 	.word	0x0000a005
 8003a94:	48000800 	.word	0x48000800
 8003a98:	05555555 	.word	0x05555555
 8003a9c:	40022000 	.word	0x40022000

08003aa0 <Vector80>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8003aa0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003aa2:	4645      	mov	r5, r8
 8003aa4:	4657      	mov	r7, sl
 8003aa6:	464e      	mov	r6, r9
 8003aa8:	b4e0      	push	{r5, r6, r7}
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003aaa:	4c66      	ldr	r4, [pc, #408]	; (8003c44 <Vector80+0x1a4>)

  OSAL_IRQ_PROLOGUE();
 8003aac:	4675      	mov	r5, lr
 8003aae:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8003ab0:	079b      	lsls	r3, r3, #30
 8003ab2:	d40d      	bmi.n	8003ad0 <Vector80+0x30>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ab4:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003ab6:	2007      	movs	r0, #7
 8003ab8:	2202      	movs	r2, #2
 8003aba:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8003abc:	780b      	ldrb	r3, [r1, #0]
 8003abe:	4383      	bics	r3, r0
 8003ac0:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8003ac2:	4003      	ands	r3, r0
 8003ac4:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8003ac6:	4b60      	ldr	r3, [pc, #384]	; (8003c48 <Vector80+0x1a8>)
 8003ac8:	608b      	str	r3, [r1, #8]
    trace_next();
 8003aca:	f7fe ff39 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ace:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ad0:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003ad2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003ad4:	2b00      	cmp	r3, #0
 8003ad6:	db02      	blt.n	8003ade <Vector80+0x3e>
 8003ad8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003ada:	2a00      	cmp	r2, #0
 8003adc:	d002      	beq.n	8003ae4 <Vector80+0x44>
    chSysHalt("SV#8");
 8003ade:	485b      	ldr	r0, [pc, #364]	; (8003c4c <Vector80+0x1ac>)
 8003ae0:	f7fe ff46 	bl	8002970 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8003ae4:	3301      	adds	r3, #1
 8003ae6:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ae8:	b662      	cpsie	i

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8003aea:	4b59      	ldr	r3, [pc, #356]	; (8003c50 <Vector80+0x1b0>)
 8003aec:	6919      	ldr	r1, [r3, #16]
 8003aee:	0789      	lsls	r1, r1, #30
 8003af0:	d409      	bmi.n	8003b06 <Vector80+0x66>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003af2:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003af4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003af6:	2b00      	cmp	r3, #0
 8003af8:	dd02      	ble.n	8003b00 <Vector80+0x60>
 8003afa:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003afc:	2a00      	cmp	r2, #0
 8003afe:	d00d      	beq.n	8003b1c <Vector80+0x7c>
    chSysHalt("SV#9");
 8003b00:	4854      	ldr	r0, [pc, #336]	; (8003c54 <Vector80+0x1b4>)
 8003b02:	f7fe ff35 	bl	8002970 <chSysHalt>
    STM32_ST_TIM->SR = 0U;
 8003b06:	611a      	str	r2, [r3, #16]
 8003b08:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003b0a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8003b0c:	2a00      	cmp	r2, #0
 8003b0e:	dd02      	ble.n	8003b16 <Vector80+0x76>
 8003b10:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003b12:	2a00      	cmp	r2, #0
 8003b14:	d032      	beq.n	8003b7c <Vector80+0xdc>
    chSysHalt("SV#6");
 8003b16:	4850      	ldr	r0, [pc, #320]	; (8003c58 <Vector80+0x1b8>)
 8003b18:	f7fe ff2a 	bl	8002970 <chSysHalt>

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 8003b1c:	3b01      	subs	r3, #1
 8003b1e:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003b20:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003b22:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8003b24:	079b      	lsls	r3, r3, #30
 8003b26:	d517      	bpl.n	8003b58 <Vector80+0xb8>
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8003b28:	350f      	adds	r5, #15
 8003b2a:	d010      	beq.n	8003b4e <Vector80+0xae>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003b2c:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003b2e:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8003b32:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8003b34:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8003b38:	2280      	movs	r2, #128	; 0x80
 8003b3a:	0452      	lsls	r2, r2, #17
 8003b3c:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8003b3e:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8003b40:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8003b42:	6889      	ldr	r1, [r1, #8]
 8003b44:	6892      	ldr	r2, [r2, #8]
 8003b46:	4291      	cmp	r1, r2
 8003b48:	d815      	bhi.n	8003b76 <Vector80+0xd6>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8003b4a:	4a44      	ldr	r2, [pc, #272]	; (8003c5c <Vector80+0x1bc>)
 8003b4c:	619a      	str	r2, [r3, #24]
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8003b4e:	bc1c      	pop	{r2, r3, r4}
 8003b50:	4690      	mov	r8, r2
 8003b52:	4699      	mov	r9, r3
 8003b54:	46a2      	mov	sl, r4
 8003b56:	bdf0      	pop	{r4, r5, r6, r7, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003b58:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003b5a:	2007      	movs	r0, #7
 8003b5c:	2203      	movs	r2, #3
 8003b5e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8003b60:	780b      	ldrb	r3, [r1, #0]
 8003b62:	4383      	bics	r3, r0
 8003b64:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8003b66:	4003      	ands	r3, r0
 8003b68:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8003b6a:	4b37      	ldr	r3, [pc, #220]	; (8003c48 <Vector80+0x1a8>)
 8003b6c:	608b      	str	r3, [r1, #8]
    trace_next();
 8003b6e:	f7fe fee7 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003b72:	b662      	cpsie	i
 8003b74:	e7d8      	b.n	8003b28 <Vector80+0x88>

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8003b76:	4a3a      	ldr	r2, [pc, #232]	; (8003c60 <Vector80+0x1c0>)
 8003b78:	619a      	str	r2, [r3, #24]
 8003b7a:	e7e8      	b.n	8003b4e <Vector80+0xae>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003b7c:	1c1e      	adds	r6, r3, #0

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003b7e:	231c      	movs	r3, #28
 8003b80:	4698      	mov	r8, r3
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 8003b82:	2700      	movs	r7, #0
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8003b84:	3201      	adds	r2, #1
 8003b86:	6362      	str	r2, [r4, #52]	; 0x34
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8003b88:	69e2      	ldr	r2, [r4, #28]

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003b8a:	44a0      	add	r8, r4
 8003b8c:	6a71      	ldr	r1, [r6, #36]	; 0x24
  vtp = ch.vtlist.next;
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8003b8e:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8003b90:	b289      	uxth	r1, r1
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8003b92:	1ac8      	subs	r0, r1, r3
 8003b94:	b280      	uxth	r0, r0
 8003b96:	4681      	mov	r9, r0

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 8003b98:	6890      	ldr	r0, [r2, #8]
 8003b9a:	4682      	mov	sl, r0
 8003b9c:	4581      	cmp	r9, r0
 8003b9e:	d321      	bcc.n	8003be4 <Vector80+0x144>

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003ba0:	4641      	mov	r1, r8
    /* Consuming all timers between "vtp->lasttime" and now.*/
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
 8003ba2:	4453      	add	r3, sl
 8003ba4:	8523      	strh	r3, [r4, #40]	; 0x28
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003ba6:	6813      	ldr	r3, [r2, #0]
 8003ba8:	6059      	str	r1, [r3, #4]
      ch.vtlist.next = vtp->next;
 8003baa:	61e3      	str	r3, [r4, #28]
      fn = vtp->func;
 8003bac:	68d1      	ldr	r1, [r2, #12]
      vtp->func = NULL;
 8003bae:	60d7      	str	r7, [r2, #12]

      /* If the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8003bb0:	4543      	cmp	r3, r8
 8003bb2:	d03d      	beq.n	8003c30 <Vector80+0x190>
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8003bb4:	6367      	str	r7, [r4, #52]	; 0x34
 8003bb6:	b662      	cpsie	i
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 8003bb8:	6910      	ldr	r0, [r2, #16]
 8003bba:	4788      	blx	r1
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003bbc:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003bbe:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003bc0:	2b00      	cmp	r3, #0
 8003bc2:	dda8      	ble.n	8003b16 <Vector80+0x76>
 8003bc4:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003bc6:	2b00      	cmp	r3, #0
 8003bc8:	d1a5      	bne.n	8003b16 <Vector80+0x76>
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;
 8003bca:	4652      	mov	r2, sl
 8003bcc:	464b      	mov	r3, r9
 8003bce:	1a9b      	subs	r3, r3, r2
 8003bd0:	4699      	mov	r9, r3
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8003bd2:	2301      	movs	r3, #1
      chSysUnlockFromISR();
      fn(vtp->par);
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 8003bd4:	69e2      	ldr	r2, [r4, #28]
 8003bd6:	6363      	str	r3, [r4, #52]	; 0x34
    }
    while (vtp->delta <= nowdelta);
 8003bd8:	6893      	ldr	r3, [r2, #8]
 8003bda:	469a      	mov	sl, r3
 8003bdc:	4599      	cmp	r9, r3
 8003bde:	d3d5      	bcc.n	8003b8c <Vector80+0xec>
 8003be0:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8003be2:	e7dd      	b.n	8003ba0 <Vector80+0x100>
  }

  /* If the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8003be4:	1c20      	adds	r0, r4, #0
 8003be6:	301c      	adds	r0, #28
 8003be8:	4282      	cmp	r2, r0
 8003bea:	d01d      	beq.n	8003c28 <Vector80+0x188>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 8003bec:	464e      	mov	r6, r9
 8003bee:	6890      	ldr	r0, [r2, #8]
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 8003bf0:	444b      	add	r3, r9
 8003bf2:	b29b      	uxth	r3, r3
  ch.vtlist.next->delta -= nowdelta;
 8003bf4:	1b80      	subs	r0, r0, r6
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 8003bf6:	8523      	strh	r3, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8003bf8:	6090      	str	r0, [r2, #8]
 8003bfa:	1aca      	subs	r2, r1, r3
 8003bfc:	b292      	uxth	r2, r2

  /* Recalculating the next alarm time.*/
  delta = vtp->delta - chTimeDiffX(ch.vtlist.lasttime, now);
 8003bfe:	1a82      	subs	r2, r0, r2
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8003c00:	2a01      	cmp	r2, #1
 8003c02:	d91a      	bls.n	8003c3a <Vector80+0x19a>
 8003c04:	4817      	ldr	r0, [pc, #92]	; (8003c64 <Vector80+0x1c4>)
 8003c06:	4282      	cmp	r2, r0
 8003c08:	d900      	bls.n	8003c0c <Vector80+0x16c>
 8003c0a:	1c02      	adds	r2, r0, #0
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8003c0c:	4810      	ldr	r0, [pc, #64]	; (8003c50 <Vector80+0x1b0>)
 8003c0e:	68c6      	ldr	r6, [r0, #12]
 8003c10:	07b6      	lsls	r6, r6, #30
 8003c12:	d50f      	bpl.n	8003c34 <Vector80+0x194>

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8003c14:	188a      	adds	r2, r1, r2
 8003c16:	b292      	uxth	r2, r2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003c18:	6342      	str	r2, [r0, #52]	; 0x34
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003c1a:	6a41      	ldr	r1, [r0, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8003c1c:	1ac9      	subs	r1, r1, r3
 8003c1e:	1ad3      	subs	r3, r2, r3
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 8003c20:	b29b      	uxth	r3, r3
 8003c22:	b28a      	uxth	r2, r1
 8003c24:	429a      	cmp	r2, r3
 8003c26:	d80a      	bhi.n	8003c3e <Vector80+0x19e>
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8003c28:	2300      	movs	r3, #0
 8003c2a:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003c2c:	b662      	cpsie	i
 8003c2e:	e760      	b.n	8003af2 <Vector80+0x52>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003c30:	60f7      	str	r7, [r6, #12]
 8003c32:	e7bf      	b.n	8003bb4 <Vector80+0x114>
 8003c34:	480c      	ldr	r0, [pc, #48]	; (8003c68 <Vector80+0x1c8>)
 8003c36:	f7fe fe9b 	bl	8002970 <chSysHalt>
  ch.vtlist.next->delta -= nowdelta;

  /* Recalculating the next alarm time.*/
  delta = vtp->delta - chTimeDiffX(ch.vtlist.lasttime, now);
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003c3a:	2202      	movs	r2, #2
 8003c3c:	e7e6      	b.n	8003c0c <Vector80+0x16c>
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 8003c3e:	480b      	ldr	r0, [pc, #44]	; (8003c6c <Vector80+0x1cc>)
 8003c40:	f7fe fe96 	bl	8002970 <chSysHalt>
 8003c44:	20000700 	.word	0x20000700
 8003c48:	080059b0 	.word	0x080059b0
 8003c4c:	080059c8 	.word	0x080059c8
 8003c50:	40000400 	.word	0x40000400
 8003c54:	080059d0 	.word	0x080059d0
 8003c58:	080058fc 	.word	0x080058fc
 8003c5c:	080001d4 	.word	0x080001d4
 8003c60:	080001c9 	.word	0x080001c9
 8003c64:	0000ffff 	.word	0x0000ffff
 8003c68:	0800595c 	.word	0x0800595c
 8003c6c:	080059a4 	.word	0x080059a4

08003c70 <Vector9C>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_GLOBAL_HANDLER) {
 8003c70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003c72:	464f      	mov	r7, r9
 8003c74:	4646      	mov	r6, r8
 8003c76:	b4c0      	push	{r6, r7}
  uint32_t isr = I2CD1.i2c->ISR;
 8003c78:	4dba      	ldr	r5, [pc, #744]	; (8003f64 <Vector9C+0x2f4>)
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003c7a:	4cbb      	ldr	r4, [pc, #748]	; (8003f68 <Vector9C+0x2f8>)
 8003c7c:	6b2b      	ldr	r3, [r5, #48]	; 0x30

  OSAL_IRQ_PROLOGUE();
 8003c7e:	4677      	mov	r7, lr
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_GLOBAL_HANDLER) {
  uint32_t isr = I2CD1.i2c->ISR;
 8003c80:	699e      	ldr	r6, [r3, #24]
 8003c82:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8003c84:	079b      	lsls	r3, r3, #30
 8003c86:	d40d      	bmi.n	8003ca4 <Vector9C+0x34>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003c88:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8003c8a:	2007      	movs	r0, #7
 8003c8c:	2202      	movs	r2, #2
 8003c8e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8003c90:	780b      	ldrb	r3, [r1, #0]
 8003c92:	4383      	bics	r3, r0
 8003c94:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8003c96:	4003      	ands	r3, r0
 8003c98:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8003c9a:	4bb4      	ldr	r3, [pc, #720]	; (8003f6c <Vector9C+0x2fc>)
 8003c9c:	608b      	str	r3, [r1, #8]
    trace_next();
 8003c9e:	f7fe fe4f 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003ca2:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ca4:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003ca6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003ca8:	2b00      	cmp	r3, #0
 8003caa:	db02      	blt.n	8003cb2 <Vector9C+0x42>
 8003cac:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003cae:	2a00      	cmp	r2, #0
 8003cb0:	d002      	beq.n	8003cb8 <Vector9C+0x48>
    chSysHalt("SV#8");
 8003cb2:	48af      	ldr	r0, [pc, #700]	; (8003f70 <Vector9C+0x300>)
 8003cb4:	f7fe fe5c 	bl	8002970 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8003cb8:	3301      	adds	r3, #1
 8003cba:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003cbc:	b662      	cpsie	i
  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;

  if (isr & I2C_ERROR_MASK)
 8003cbe:	22fc      	movs	r2, #252	; 0xfc
  uint32_t isr = I2CD1.i2c->ISR;

  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;
 8003cc0:	6b2b      	ldr	r3, [r5, #48]	; 0x30

  if (isr & I2C_ERROR_MASK)
 8003cc2:	0192      	lsls	r2, r2, #6
  uint32_t isr = I2CD1.i2c->ISR;

  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;
 8003cc4:	61de      	str	r6, [r3, #28]

  if (isr & I2C_ERROR_MASK)
 8003cc6:	4216      	tst	r6, r2
 8003cc8:	d163      	bne.n	8003d92 <Vector9C+0x122>
    i2c_lld_serve_error_interrupt(&I2CD1, isr);
  else if (isr & I2C_INT_MASK)
 8003cca:	22fe      	movs	r2, #254	; 0xfe
 8003ccc:	4232      	tst	r2, r6
 8003cce:	d109      	bne.n	8003ce4 <Vector9C+0x74>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003cd0:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003cd2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003cd4:	2b00      	cmp	r3, #0
 8003cd6:	dd02      	ble.n	8003cde <Vector9C+0x6e>
 8003cd8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8003cda:	2a00      	cmp	r2, #0
 8003cdc:	d02d      	beq.n	8003d3a <Vector9C+0xca>
    chSysHalt("SV#9");
 8003cde:	48a5      	ldr	r0, [pc, #660]	; (8003f74 <Vector9C+0x304>)
 8003ce0:	f7fe fe46 	bl	8002970 <chSysHalt>
 */
static void i2c_lld_serve_interrupt(I2CDriver *i2cp, uint32_t isr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
 8003ce4:	06f2      	lsls	r2, r6, #27
 8003ce6:	d500      	bpl.n	8003cea <Vector9C+0x7a>
 8003ce8:	e0cb      	b.n	8003e82 <Vector9C+0x212>
    }
  }
#endif

  /* Partial transfer handling, restarting the transfer and returning.*/
  if ((isr & I2C_ISR_TCR) != 0U) {
 8003cea:	0632      	lsls	r2, r6, #24
 8003cec:	d500      	bpl.n	8003cf0 <Vector9C+0x80>
 8003cee:	e09e      	b.n	8003e2e <Vector9C+0x1be>
    }
    return;
  }

  /* The following condition is true if a transfer phase has been completed.*/
  if ((isr & I2C_ISR_TC) != 0U) {
 8003cf0:	0672      	lsls	r2, r6, #25
 8003cf2:	d5ed      	bpl.n	8003cd0 <Vector9C+0x60>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8003cf4:	782a      	ldrb	r2, [r5, #0]
 8003cf6:	2a03      	cmp	r2, #3
 8003cf8:	d100      	bne.n	8003cfc <Vector9C+0x8c>
 8003cfa:	e147      	b.n	8003f8c <Vector9C+0x31c>
    }
    else {
      /* End of the receive phase.*/
#if STM32_I2C_USE_DMA == TRUE
      /* Disabling RX DMA channel.*/
      dmaStreamDisable(i2cp->dmarx);
 8003cfc:	260f      	movs	r6, #15
 8003cfe:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8003d00:	6850      	ldr	r0, [r2, #4]
 8003d02:	6801      	ldr	r1, [r0, #0]
 8003d04:	43b1      	bics	r1, r6
 8003d06:	6001      	str	r1, [r0, #0]
 8003d08:	7b50      	ldrb	r0, [r2, #13]
 8003d0a:	6811      	ldr	r1, [r2, #0]
 8003d0c:	220e      	movs	r2, #14
 8003d0e:	4082      	lsls	r2, r0
 8003d10:	604a      	str	r2, [r1, #4]
#endif
    }

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8003d12:	2180      	movs	r1, #128	; 0x80
 8003d14:	685a      	ldr	r2, [r3, #4]
 8003d16:	01c9      	lsls	r1, r1, #7
 8003d18:	430a      	orrs	r2, r1

    /* Make sure no more 'Transfer Complete' interrupts.*/
    dp->CR1 &= ~I2C_CR1_TCIE;
 8003d1a:	2140      	movs	r1, #64	; 0x40
      dmaStreamDisable(i2cp->dmarx);
#endif
    }

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8003d1c:	605a      	str	r2, [r3, #4]

    /* Make sure no more 'Transfer Complete' interrupts.*/
    dp->CR1 &= ~I2C_CR1_TCIE;
 8003d1e:	681a      	ldr	r2, [r3, #0]
 8003d20:	438a      	bics	r2, r1
 8003d22:	601a      	str	r2, [r3, #0]
 8003d24:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003d26:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003d28:	2b00      	cmp	r3, #0
 8003d2a:	dd03      	ble.n	8003d34 <Vector9C+0xc4>
 8003d2c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003d2e:	2b00      	cmp	r3, #0
 8003d30:	d100      	bne.n	8003d34 <Vector9C+0xc4>
 8003d32:	e103      	b.n	8003f3c <Vector9C+0x2cc>
    chSysHalt("SV#6");
 8003d34:	4890      	ldr	r0, [pc, #576]	; (8003f78 <Vector9C+0x308>)
 8003d36:	f7fe fe1b 	bl	8002970 <chSysHalt>

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 8003d3a:	3b01      	subs	r3, #1
 8003d3c:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003d3e:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8003d40:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8003d42:	079b      	lsls	r3, r3, #30
 8003d44:	d40d      	bmi.n	8003d62 <Vector9C+0xf2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003d46:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8003d48:	2007      	movs	r0, #7
 8003d4a:	2203      	movs	r2, #3
 8003d4c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8003d4e:	780b      	ldrb	r3, [r1, #0]
 8003d50:	4383      	bics	r3, r0
 8003d52:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8003d54:	4003      	ands	r3, r0
 8003d56:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8003d58:	4b84      	ldr	r3, [pc, #528]	; (8003f6c <Vector9C+0x2fc>)
 8003d5a:	608b      	str	r3, [r1, #8]
    trace_next();
 8003d5c:	f7fe fdf0 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003d60:	b662      	cpsie	i
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8003d62:	370f      	adds	r7, #15
 8003d64:	d011      	beq.n	8003d8a <Vector9C+0x11a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003d66:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003d68:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8003d6c:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8003d6e:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8003d72:	2280      	movs	r2, #128	; 0x80
 8003d74:	0452      	lsls	r2, r2, #17
 8003d76:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8003d78:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8003d7a:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8003d7c:	6889      	ldr	r1, [r1, #8]
 8003d7e:	6892      	ldr	r2, [r2, #8]
 8003d80:	4291      	cmp	r1, r2
 8003d82:	d900      	bls.n	8003d86 <Vector9C+0x116>
 8003d84:	e070      	b.n	8003e68 <Vector9C+0x1f8>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8003d86:	4a7d      	ldr	r2, [pc, #500]	; (8003f7c <Vector9C+0x30c>)
 8003d88:	619a      	str	r2, [r3, #24]
    i2c_lld_serve_error_interrupt(&I2CD1, isr);
  else if (isr & I2C_INT_MASK)
    i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8003d8a:	bc0c      	pop	{r2, r3}
 8003d8c:	4690      	mov	r8, r2
 8003d8e:	4699      	mov	r9, r3
 8003d90:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

#if STM32_I2C_USE_DMA == TRUE
  /* Clears DMA interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8003d92:	200f      	movs	r0, #15
 8003d94:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8003d96:	6859      	ldr	r1, [r3, #4]
 8003d98:	680a      	ldr	r2, [r1, #0]
 8003d9a:	4382      	bics	r2, r0
 8003d9c:	600a      	str	r2, [r1, #0]
 8003d9e:	681a      	ldr	r2, [r3, #0]
 8003da0:	4694      	mov	ip, r2
 8003da2:	7b5a      	ldrb	r2, [r3, #13]
 8003da4:	230e      	movs	r3, #14
 8003da6:	1c19      	adds	r1, r3, #0
 8003da8:	4091      	lsls	r1, r2
 8003daa:	1c0a      	adds	r2, r1, #0
 8003dac:	4661      	mov	r1, ip
 8003dae:	604a      	str	r2, [r1, #4]
  dmaStreamDisable(i2cp->dmarx);
 8003db0:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8003db2:	6851      	ldr	r1, [r2, #4]
 8003db4:	468c      	mov	ip, r1
 8003db6:	6809      	ldr	r1, [r1, #0]
 8003db8:	4381      	bics	r1, r0
 8003dba:	4660      	mov	r0, ip
 8003dbc:	6001      	str	r1, [r0, #0]
 8003dbe:	6811      	ldr	r1, [r2, #0]
 8003dc0:	7b52      	ldrb	r2, [r2, #13]
 8003dc2:	4093      	lsls	r3, r2
 8003dc4:	604b      	str	r3, [r1, #4]
#else
  /* Disabling RX and TX interrupts.*/
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
#endif

  if (isr & I2C_ISR_BERR)
 8003dc6:	05f3      	lsls	r3, r6, #23
 8003dc8:	d449      	bmi.n	8003e5e <Vector9C+0x1ee>
 8003dca:	68ab      	ldr	r3, [r5, #8]
    i2cp->errors |= I2C_BUS_ERROR;

  if (isr & I2C_ISR_ARLO)
 8003dcc:	05b2      	lsls	r2, r6, #22
 8003dce:	d502      	bpl.n	8003dd6 <Vector9C+0x166>
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8003dd0:	2202      	movs	r2, #2
 8003dd2:	4313      	orrs	r3, r2
 8003dd4:	60ab      	str	r3, [r5, #8]

  if (isr & I2C_ISR_OVR)
 8003dd6:	0572      	lsls	r2, r6, #21
 8003dd8:	d549      	bpl.n	8003e6e <Vector9C+0x1fe>
    i2cp->errors |= I2C_OVERRUN;
 8003dda:	2208      	movs	r2, #8
 8003ddc:	4313      	orrs	r3, r2
 8003dde:	60ab      	str	r3, [r5, #8]

  if (isr & I2C_ISR_TIMEOUT)
 8003de0:	04f2      	lsls	r2, r6, #19
 8003de2:	d446      	bmi.n	8003e72 <Vector9C+0x202>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003de4:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003de6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003de8:	2b00      	cmp	r3, #0
 8003dea:	dda3      	ble.n	8003d34 <Vector9C+0xc4>
 8003dec:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003dee:	2b00      	cmp	r3, #0
 8003df0:	d1a0      	bne.n	8003d34 <Vector9C+0xc4>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8003df2:	2201      	movs	r2, #1
 8003df4:	6362      	str	r2, [r4, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8003df6:	69ea      	ldr	r2, [r5, #28]
 8003df8:	2a00      	cmp	r2, #0
 8003dfa:	d014      	beq.n	8003e26 <Vector9C+0x1b6>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8003dfc:	2120      	movs	r1, #32
 8003dfe:	5c50      	ldrb	r0, [r2, r1]
 8003e00:	2803      	cmp	r0, #3
 8003e02:	d000      	beq.n	8003e06 <Vector9C+0x196>
 8003e04:	e097      	b.n	8003f36 <Vector9C+0x2c6>

    *trp = NULL;
    tp->u.rdymsg = msg;
 8003e06:	2002      	movs	r0, #2
 8003e08:	4240      	negs	r0, r0
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8003e0a:	61eb      	str	r3, [r5, #28]
    tp->u.rdymsg = msg;
 8003e0c:	6250      	str	r0, [r2, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8003e0e:	5453      	strb	r3, [r2, r1]
  cp = (thread_t *)&ch.rlist.queue;
 8003e10:	1c23      	adds	r3, r4, #0
 8003e12:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8003e14:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8003e16:	6898      	ldr	r0, [r3, #8]
 8003e18:	4288      	cmp	r0, r1
 8003e1a:	d2fb      	bcs.n	8003e14 <Vector9C+0x1a4>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8003e1c:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8003e1e:	6859      	ldr	r1, [r3, #4]
 8003e20:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8003e22:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8003e24:	605a      	str	r2, [r3, #4]
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8003e26:	2300      	movs	r3, #0
 8003e28:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003e2a:	b662      	cpsie	i
 8003e2c:	e750      	b.n	8003cd0 <Vector9C+0x60>
  }
#endif

  /* Partial transfer handling, restarting the transfer and returning.*/
  if ((isr & I2C_ISR_TCR) != 0U) {
    if (i2cp->state == I2C_ACTIVE_TX) {
 8003e2e:	782a      	ldrb	r2, [r5, #0]
 8003e30:	2a03      	cmp	r2, #3
 8003e32:	d06f      	beq.n	8003f14 <Vector9C+0x2a4>
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 8003e34:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8003e36:	6852      	ldr	r2, [r2, #4]
 8003e38:	6852      	ldr	r2, [r2, #4]
  if (n > 255U) {
 8003e3a:	2aff      	cmp	r2, #255	; 0xff
 8003e3c:	d865      	bhi.n	8003f0a <Vector9C+0x29a>
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 8003e3e:	2000      	movs	r0, #0
 8003e40:	0416      	lsls	r6, r2, #16
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003e42:	6869      	ldr	r1, [r5, #4]
 8003e44:	685a      	ldr	r2, [r3, #4]
 8003e46:	688d      	ldr	r5, [r1, #8]
 8003e48:	2180      	movs	r1, #128	; 0x80
 8003e4a:	00c9      	lsls	r1, r1, #3
 8003e4c:	430d      	orrs	r5, r1
 8003e4e:	494c      	ldr	r1, [pc, #304]	; (8003f80 <Vector9C+0x310>)
 8003e50:	4011      	ands	r1, r2
 8003e52:	1c2a      	adds	r2, r5, #0
 8003e54:	430a      	orrs	r2, r1
 8003e56:	4302      	orrs	r2, r0
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8003e58:	4332      	orrs	r2, r6
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003e5a:	605a      	str	r2, [r3, #4]
 8003e5c:	e738      	b.n	8003cd0 <Vector9C+0x60>
  /* Disabling RX and TX interrupts.*/
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
#endif

  if (isr & I2C_ISR_BERR)
    i2cp->errors |= I2C_BUS_ERROR;
 8003e5e:	2301      	movs	r3, #1
 8003e60:	68aa      	ldr	r2, [r5, #8]
 8003e62:	4313      	orrs	r3, r2
 8003e64:	60ab      	str	r3, [r5, #8]
 8003e66:	e7b1      	b.n	8003dcc <Vector9C+0x15c>

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8003e68:	4a46      	ldr	r2, [pc, #280]	; (8003f84 <Vector9C+0x314>)
 8003e6a:	619a      	str	r2, [r3, #24]
 8003e6c:	e78d      	b.n	8003d8a <Vector9C+0x11a>
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (isr & I2C_ISR_OVR)
    i2cp->errors |= I2C_OVERRUN;

  if (isr & I2C_ISR_TIMEOUT)
 8003e6e:	04f2      	lsls	r2, r6, #19
 8003e70:	d503      	bpl.n	8003e7a <Vector9C+0x20a>
    i2cp->errors |= I2C_TIMEOUT;
 8003e72:	2220      	movs	r2, #32
 8003e74:	4313      	orrs	r3, r2
 8003e76:	60ab      	str	r3, [r5, #8]
 8003e78:	e7b4      	b.n	8003de4 <Vector9C+0x174>

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8003e7a:	2b00      	cmp	r3, #0
 8003e7c:	d100      	bne.n	8003e80 <Vector9C+0x210>
 8003e7e:	e727      	b.n	8003cd0 <Vector9C+0x60>
 8003e80:	e7b0      	b.n	8003de4 <Vector9C+0x174>

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
#if STM32_I2C_USE_DMA == TRUE
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
 8003e82:	260f      	movs	r6, #15
 8003e84:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8003e86:	6850      	ldr	r0, [r2, #4]
 8003e88:	6801      	ldr	r1, [r0, #0]
 8003e8a:	43b1      	bics	r1, r6
 8003e8c:	6001      	str	r1, [r0, #0]
 8003e8e:	6811      	ldr	r1, [r2, #0]
 8003e90:	468c      	mov	ip, r1
 8003e92:	7b51      	ldrb	r1, [r2, #13]
 8003e94:	220e      	movs	r2, #14
 8003e96:	1c10      	adds	r0, r2, #0
 8003e98:	4088      	lsls	r0, r1
 8003e9a:	1c01      	adds	r1, r0, #0
 8003e9c:	4660      	mov	r0, ip
 8003e9e:	6041      	str	r1, [r0, #4]
    dmaStreamDisable(i2cp->dmarx);
 8003ea0:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8003ea2:	6848      	ldr	r0, [r1, #4]
 8003ea4:	4684      	mov	ip, r0
 8003ea6:	6800      	ldr	r0, [r0, #0]
 8003ea8:	43b0      	bics	r0, r6
 8003eaa:	4666      	mov	r6, ip
 8003eac:	6030      	str	r0, [r6, #0]
 8003eae:	6808      	ldr	r0, [r1, #0]
 8003eb0:	7b49      	ldrb	r1, [r1, #13]
 8003eb2:	408a      	lsls	r2, r1
 8003eb4:	6042      	str	r2, [r0, #4]
#endif

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;
 8003eb6:	2204      	movs	r2, #4
 8003eb8:	68a9      	ldr	r1, [r5, #8]
 8003eba:	430a      	orrs	r2, r1

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8003ebc:	2180      	movs	r1, #128	; 0x80
    dmaStreamDisable(i2cp->dmatx);
    dmaStreamDisable(i2cp->dmarx);
#endif

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;
 8003ebe:	60aa      	str	r2, [r5, #8]

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8003ec0:	685a      	ldr	r2, [r3, #4]
 8003ec2:	01c9      	lsls	r1, r1, #7
 8003ec4:	430a      	orrs	r2, r1

    /* Make sure no more interrupts.*/
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
 8003ec6:	2146      	movs	r1, #70	; 0x46

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8003ec8:	605a      	str	r2, [r3, #4]

    /* Make sure no more interrupts.*/
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
 8003eca:	681a      	ldr	r2, [r3, #0]
 8003ecc:	438a      	bics	r2, r1
 8003ece:	601a      	str	r2, [r3, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003ed0:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003ed2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8003ed4:	2b00      	cmp	r3, #0
 8003ed6:	dc00      	bgt.n	8003eda <Vector9C+0x26a>
 8003ed8:	e72c      	b.n	8003d34 <Vector9C+0xc4>
 8003eda:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8003edc:	2b00      	cmp	r3, #0
 8003ede:	d000      	beq.n	8003ee2 <Vector9C+0x272>
 8003ee0:	e728      	b.n	8003d34 <Vector9C+0xc4>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8003ee2:	2201      	movs	r2, #1
 8003ee4:	6362      	str	r2, [r4, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8003ee6:	69ea      	ldr	r2, [r5, #28]
 8003ee8:	2a00      	cmp	r2, #0
 8003eea:	d09c      	beq.n	8003e26 <Vector9C+0x1b6>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8003eec:	3926      	subs	r1, #38	; 0x26
 8003eee:	5c50      	ldrb	r0, [r2, r1]
 8003ef0:	2803      	cmp	r0, #3
 8003ef2:	d120      	bne.n	8003f36 <Vector9C+0x2c6>

    *trp = NULL;
    tp->u.rdymsg = msg;
 8003ef4:	3805      	subs	r0, #5
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8003ef6:	61eb      	str	r3, [r5, #28]
    tp->u.rdymsg = msg;
 8003ef8:	6250      	str	r0, [r2, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8003efa:	5453      	strb	r3, [r2, r1]
  cp = (thread_t *)&ch.rlist.queue;
 8003efc:	1c23      	adds	r3, r4, #0
 8003efe:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8003f00:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8003f02:	6898      	ldr	r0, [r3, #8]
 8003f04:	4288      	cmp	r0, r1
 8003f06:	d2fb      	bcs.n	8003f00 <Vector9C+0x290>
 8003f08:	e788      	b.n	8003e1c <Vector9C+0x1ac>
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
 8003f0a:	26ff      	movs	r6, #255	; 0xff
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8003f0c:	2080      	movs	r0, #128	; 0x80
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
 8003f0e:	0436      	lsls	r6, r6, #16
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8003f10:	0440      	lsls	r0, r0, #17
 8003f12:	e796      	b.n	8003e42 <Vector9C+0x1d2>
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 8003f14:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8003f16:	6852      	ldr	r2, [r2, #4]
 8003f18:	6852      	ldr	r2, [r2, #4]
  if (n > 255U) {
 8003f1a:	2aff      	cmp	r2, #255	; 0xff
 8003f1c:	d86a      	bhi.n	8003ff4 <Vector9C+0x384>
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 8003f1e:	2000      	movs	r0, #0
 8003f20:	0411      	lsls	r1, r2, #16
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003f22:	686d      	ldr	r5, [r5, #4]
 8003f24:	685e      	ldr	r6, [r3, #4]
 8003f26:	4a16      	ldr	r2, [pc, #88]	; (8003f80 <Vector9C+0x310>)
 8003f28:	68ad      	ldr	r5, [r5, #8]
 8003f2a:	4032      	ands	r2, r6
 8003f2c:	432a      	orrs	r2, r5
 8003f2e:	4302      	orrs	r2, r0
            (n << 16U) | reload;
 8003f30:	430a      	orrs	r2, r1
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003f32:	605a      	str	r2, [r3, #4]
 8003f34:	e6cc      	b.n	8003cd0 <Vector9C+0x60>
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8003f36:	4814      	ldr	r0, [pc, #80]	; (8003f88 <Vector9C+0x318>)
 8003f38:	f7fe fd1a 	bl	8002970 <chSysHalt>
 8003f3c:	2201      	movs	r2, #1
 8003f3e:	6362      	str	r2, [r4, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8003f40:	69ea      	ldr	r2, [r5, #28]
 8003f42:	2a00      	cmp	r2, #0
 8003f44:	d100      	bne.n	8003f48 <Vector9C+0x2d8>
 8003f46:	e76e      	b.n	8003e26 <Vector9C+0x1b6>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8003f48:	3920      	subs	r1, #32
 8003f4a:	5c50      	ldrb	r0, [r2, r1]
 8003f4c:	2803      	cmp	r0, #3
 8003f4e:	d1f2      	bne.n	8003f36 <Vector9C+0x2c6>

    *trp = NULL;
    tp->u.rdymsg = msg;
 8003f50:	6253      	str	r3, [r2, #36]	; 0x24
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8003f52:	61eb      	str	r3, [r5, #28]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8003f54:	5453      	strb	r3, [r2, r1]
  cp = (thread_t *)&ch.rlist.queue;
 8003f56:	1c23      	adds	r3, r4, #0
 8003f58:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8003f5a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8003f5c:	6898      	ldr	r0, [r3, #8]
 8003f5e:	4288      	cmp	r0, r1
 8003f60:	d2fb      	bcs.n	8003f5a <Vector9C+0x2ea>
 8003f62:	e75b      	b.n	8003e1c <Vector9C+0x1ac>
 8003f64:	20000f84 	.word	0x20000f84
 8003f68:	20000700 	.word	0x20000700
 8003f6c:	080059e8 	.word	0x080059e8
 8003f70:	080059c8 	.word	0x080059c8
 8003f74:	080059d0 	.word	0x080059d0
 8003f78:	080058fc 	.word	0x080058fc
 8003f7c:	080001d4 	.word	0x080001d4
 8003f80:	fe00ffff 	.word	0xfe00ffff
 8003f84:	080001c9 	.word	0x080001c9
 8003f88:	080059f4 	.word	0x080059f4
    if (i2cp->state == I2C_ACTIVE_TX) {
      /* End of the transmit phase.*/

#if STM32_I2C_USE_DMA == TRUE
      /* Disabling TX DMA channel.*/
      dmaStreamDisable(i2cp->dmatx);
 8003f8c:	260f      	movs	r6, #15
 8003f8e:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8003f90:	6850      	ldr	r0, [r2, #4]
 8003f92:	6801      	ldr	r1, [r0, #0]
 8003f94:	43b1      	bics	r1, r6
 8003f96:	6001      	str	r1, [r0, #0]
 8003f98:	7b50      	ldrb	r0, [r2, #13]
 8003f9a:	6811      	ldr	r1, [r2, #0]
 8003f9c:	220e      	movs	r2, #14
 8003f9e:	4082      	lsls	r2, r0
 8003fa0:	604a      	str	r2, [r1, #4]
#endif

      /* Starting receive phase if necessary.*/
      if (i2c_lld_get_rxbytes(i2cp) > 0U) {
 8003fa2:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8003fa4:	6852      	ldr	r2, [r2, #4]
 8003fa6:	6851      	ldr	r1, [r2, #4]
 8003fa8:	2900      	cmp	r1, #0
 8003faa:	d100      	bne.n	8003fae <Vector9C+0x33e>
 8003fac:	e6b1      	b.n	8003d12 <Vector9C+0xa2>
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 8003fae:	6851      	ldr	r1, [r2, #4]
  if (n > 255U) {
 8003fb0:	29ff      	cmp	r1, #255	; 0xff
 8003fb2:	d824      	bhi.n	8003ffe <Vector9C+0x38e>
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 8003fb4:	2000      	movs	r0, #0
 8003fb6:	4684      	mov	ip, r0
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003fb8:	6858      	ldr	r0, [r3, #4]
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8003fba:	0409      	lsls	r1, r1, #16
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003fbc:	4680      	mov	r8, r0
 8003fbe:	6868      	ldr	r0, [r5, #4]
 8003fc0:	6886      	ldr	r6, [r0, #8]
 8003fc2:	2080      	movs	r0, #128	; 0x80
 8003fc4:	00c0      	lsls	r0, r0, #3
 8003fc6:	4330      	orrs	r0, r6
 8003fc8:	4681      	mov	r9, r0
 8003fca:	4640      	mov	r0, r8
 8003fcc:	4e0e      	ldr	r6, [pc, #56]	; (8004008 <Vector9C+0x398>)
 8003fce:	4006      	ands	r6, r0
 8003fd0:	4648      	mov	r0, r9
 8003fd2:	4330      	orrs	r0, r6
 8003fd4:	4666      	mov	r6, ip
 8003fd6:	4330      	orrs	r0, r6
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8003fd8:	4301      	orrs	r1, r0
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003fda:	6059      	str	r1, [r3, #4]
        /* Setting up the peripheral.*/
        i2c_lld_setup_rx_transfer(i2cp);

#if STM32_I2C_USE_DMA == TRUE
        /* Enabling RX DMA.*/
        dmaStreamEnable(i2cp->dmarx);
 8003fdc:	2101      	movs	r1, #1
 8003fde:	6810      	ldr	r0, [r2, #0]
 8003fe0:	4301      	orrs	r1, r0
 8003fe2:	6011      	str	r1, [r2, #0]
        /* RX interrupt enabled.*/
        dp->CR1 |= I2C_CR1_RXIE;
#endif

        /* Starts the read operation.*/
        dp->CR2 |= I2C_CR2_START;
 8003fe4:	2180      	movs	r1, #128	; 0x80
 8003fe6:	685a      	ldr	r2, [r3, #4]
 8003fe8:	0189      	lsls	r1, r1, #6
 8003fea:	430a      	orrs	r2, r1
 8003fec:	605a      	str	r2, [r3, #4]

        /* State change.*/
        i2cp->state = I2C_ACTIVE_RX;
 8003fee:	2304      	movs	r3, #4
 8003ff0:	702b      	strb	r3, [r5, #0]
 8003ff2:	e66d      	b.n	8003cd0 <Vector9C+0x60>
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
 8003ff4:	21ff      	movs	r1, #255	; 0xff
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8003ff6:	2080      	movs	r0, #128	; 0x80
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
 8003ff8:	0409      	lsls	r1, r1, #16
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8003ffa:	0440      	lsls	r0, r0, #17
 8003ffc:	e791      	b.n	8003f22 <Vector9C+0x2b2>

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8003ffe:	2080      	movs	r0, #128	; 0x80
 8004000:	0440      	lsls	r0, r0, #17
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
    n = 255U;
 8004002:	21ff      	movs	r1, #255	; 0xff
    reload = I2C_CR2_RELOAD;
 8004004:	4684      	mov	ip, r0
 8004006:	e7d7      	b.n	8003fb8 <Vector9C+0x348>
 8004008:	fe00ffff 	.word	0xfe00ffff
 800400c:	00000000 	.word	0x00000000

08004010 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8004010:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004012:	4644      	mov	r4, r8
 8004014:	4656      	mov	r6, sl
 8004016:	464d      	mov	r5, r9
 8004018:	465f      	mov	r7, fp
 800401a:	b4f0      	push	{r4, r5, r6, r7}
 800401c:	b083      	sub	sp, #12
 800401e:	1c04      	adds	r4, r0, #0
 8004020:	1c0e      	adds	r6, r1, #0
 8004022:	4690      	mov	r8, r2
 8004024:	4699      	mov	r9, r3
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 8004026:	f7fe fcd3 	bl	80029d0 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 800402a:	2c04      	cmp	r4, #4
 800402c:	d80e      	bhi.n	800404c <dmaStreamAllocI+0x3c>
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
 800402e:	2201      	movs	r2, #1
 8004030:	1c17      	adds	r7, r2, #0
 8004032:	40a7      	lsls	r7, r4
    if ((dma.allocated_mask & mask) == 0U) {
 8004034:	4d23      	ldr	r5, [pc, #140]	; (80040c4 <dmaStreamAllocI+0xb4>)
 8004036:	682b      	ldr	r3, [r5, #0]
 8004038:	423b      	tst	r3, r7
 800403a:	d00a      	beq.n	8004052 <dmaStreamAllocI+0x42>

      return dmastp;
    }
  }

  return NULL;
 800403c:	2000      	movs	r0, #0
}
 800403e:	b003      	add	sp, #12
 8004040:	bc3c      	pop	{r2, r3, r4, r5}
 8004042:	4690      	mov	r8, r2
 8004044:	4699      	mov	r9, r3
 8004046:	46a2      	mov	sl, r4
 8004048:	46ab      	mov	fp, r5
 800404a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    endid   = STM32_DMA_STREAMS - 1U;
  }
#endif
#endif
  else {
    osalDbgCheck(false);
 800404c:	481e      	ldr	r0, [pc, #120]	; (80040c8 <dmaStreamAllocI+0xb8>)
 800404e:	f7fe fc8f 	bl	8002970 <chSysHalt>
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
    if ((dma.allocated_mask & mask) == 0U) {
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8004052:	481e      	ldr	r0, [pc, #120]	; (80040cc <dmaStreamAllocI+0xbc>)
 8004054:	0121      	lsls	r1, r4, #4
 8004056:	4683      	mov	fp, r0
 8004058:	9101      	str	r1, [sp, #4]
 800405a:	4459      	add	r1, fp
 800405c:	468a      	mov	sl, r1

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 800405e:	4641      	mov	r1, r8
 8004060:	3401      	adds	r4, #1
 8004062:	00e4      	lsls	r4, r4, #3
 8004064:	5161      	str	r1, [r4, r5]
      dma.streams[i].param = param;
 8004066:	4649      	mov	r1, r9
      dma.allocated_mask  |= mask;
 8004068:	433b      	orrs	r3, r7
 800406a:	602b      	str	r3, [r5, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
        rccEnableDMA1(true);
 800406c:	4b18      	ldr	r3, [pc, #96]	; (80040d0 <dmaStreamAllocI+0xc0>)
    if ((dma.allocated_mask & mask) == 0U) {
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
      dma.streams[i].param = param;
 800406e:	192c      	adds	r4, r5, r4
 8004070:	6061      	str	r1, [r4, #4]
      dma.allocated_mask  |= mask;

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
        rccEnableDMA1(true);
 8004072:	6959      	ldr	r1, [r3, #20]
 8004074:	430a      	orrs	r2, r1
 8004076:	615a      	str	r2, [r3, #20]
 8004078:	695b      	ldr	r3, [r3, #20]
      }
#endif

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
 800407a:	4643      	mov	r3, r8
 800407c:	2b00      	cmp	r3, #0
 800407e:	d009      	beq.n	8004094 <dmaStreamAllocI+0x84>
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 8004080:	4652      	mov	r2, sl
 8004082:	4653      	mov	r3, sl
 8004084:	6869      	ldr	r1, [r5, #4]
 8004086:	6892      	ldr	r2, [r2, #8]
 8004088:	3308      	adds	r3, #8
 800408a:	4211      	tst	r1, r2
 800408c:	d015      	beq.n	80040ba <dmaStreamAllocI+0xaa>
          nvicEnableVector(dmastp->vector, priority);
        }
        dma.isr_mask |= mask;
 800408e:	686b      	ldr	r3, [r5, #4]
 8004090:	431f      	orrs	r7, r3
 8004092:	606f      	str	r7, [r5, #4]
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
 8004094:	9c01      	ldr	r4, [sp, #4]
 8004096:	200f      	movs	r0, #15
 8004098:	1c23      	adds	r3, r4, #0
 800409a:	445b      	add	r3, fp
 800409c:	1c19      	adds	r1, r3, #0
 800409e:	685b      	ldr	r3, [r3, #4]
 80040a0:	7b49      	ldrb	r1, [r1, #13]
 80040a2:	681a      	ldr	r2, [r3, #0]
 80040a4:	4382      	bics	r2, r0
 80040a6:	601a      	str	r2, [r3, #0]
 80040a8:	220e      	movs	r2, #14
 80040aa:	4658      	mov	r0, fp
 80040ac:	408a      	lsls	r2, r1
 80040ae:	5900      	ldr	r0, [r0, r4]
 80040b0:	6042      	str	r2, [r0, #4]
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80040b2:	2200      	movs	r2, #0

      return dmastp;
 80040b4:	4650      	mov	r0, sl
        dma.isr_mask |= mask;
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80040b6:	601a      	str	r2, [r3, #0]
 80040b8:	e7c1      	b.n	800403e <dmaStreamAllocI+0x2e>

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
          nvicEnableVector(dmastp->vector, priority);
 80040ba:	79d8      	ldrb	r0, [r3, #7]
 80040bc:	1c31      	adds	r1, r6, #0
 80040be:	f000 fbb7 	bl	8004830 <nvicEnableVector>
 80040c2:	e7e4      	b.n	800408e <dmaStreamAllocI+0x7e>
 80040c4:	20000424 	.word	0x20000424
 80040c8:	080059d8 	.word	0x080059d8
 80040cc:	08005780 	.word	0x08005780
 80040d0:	40021000 	.word	0x40021000
	...

080040e0 <Vector64>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80040e0:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80040e2:	4c32      	ldr	r4, [pc, #200]	; (80041ac <Vector64+0xcc>)

  OSAL_IRQ_PROLOGUE();
 80040e4:	4675      	mov	r5, lr
 80040e6:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 80040e8:	079b      	lsls	r3, r3, #30
 80040ea:	d40d      	bmi.n	8004108 <Vector64+0x28>
 80040ec:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80040ee:	2007      	movs	r0, #7
 80040f0:	2202      	movs	r2, #2
 80040f2:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80040f4:	780b      	ldrb	r3, [r1, #0]
 80040f6:	4383      	bics	r3, r0
 80040f8:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 80040fa:	4003      	ands	r3, r0
 80040fc:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80040fe:	4b2c      	ldr	r3, [pc, #176]	; (80041b0 <Vector64+0xd0>)
 8004100:	608b      	str	r3, [r1, #8]
    trace_next();
 8004102:	f7fe fc1d 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004106:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004108:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800410a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800410c:	2b00      	cmp	r3, #0
 800410e:	db02      	blt.n	8004116 <Vector64+0x36>
 8004110:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8004112:	2a00      	cmp	r2, #0
 8004114:	d002      	beq.n	800411c <Vector64+0x3c>
    chSysHalt("SV#8");
 8004116:	4827      	ldr	r0, [pc, #156]	; (80041b4 <Vector64+0xd4>)
 8004118:	f7fe fc2a 	bl	8002970 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800411c:	3301      	adds	r3, #1
 800411e:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004120:	b662      	cpsie	i
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t idx = (dmastp)->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8004122:	210e      	movs	r1, #14
 8004124:	4a24      	ldr	r2, [pc, #144]	; (80041b8 <Vector64+0xd8>)
 8004126:	6813      	ldr	r3, [r2, #0]
 8004128:	4019      	ands	r1, r3
  if (flags & dmastp->channel->CCR) {
 800412a:	4b24      	ldr	r3, [pc, #144]	; (80041bc <Vector64+0xdc>)
 800412c:	681b      	ldr	r3, [r3, #0]
 800412e:	420b      	tst	r3, r1
 8004130:	d006      	beq.n	8004140 <Vector64+0x60>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8004132:	6051      	str	r1, [r2, #4]
    if (dma.streams[idx].func) {
 8004134:	4a22      	ldr	r2, [pc, #136]	; (80041c0 <Vector64+0xe0>)
 8004136:	6893      	ldr	r3, [r2, #8]
 8004138:	2b00      	cmp	r3, #0
 800413a:	d001      	beq.n	8004140 <Vector64+0x60>
      dma.streams[idx].func(dma.streams[idx].param, flags);
 800413c:	68d0      	ldr	r0, [r2, #12]
 800413e:	4798      	blx	r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004140:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004142:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004144:	2b00      	cmp	r3, #0
 8004146:	dd02      	ble.n	800414e <Vector64+0x6e>
 8004148:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800414a:	2a00      	cmp	r2, #0
 800414c:	d002      	beq.n	8004154 <Vector64+0x74>
    chSysHalt("SV#9");
 800414e:	481d      	ldr	r0, [pc, #116]	; (80041c4 <Vector64+0xe4>)
 8004150:	f7fe fc0e 	bl	8002970 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 8004154:	3b01      	subs	r3, #1
 8004156:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004158:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800415a:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800415c:	079b      	lsls	r3, r3, #30
 800415e:	d40d      	bmi.n	800417c <Vector64+0x9c>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004160:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004162:	2007      	movs	r0, #7
 8004164:	2203      	movs	r2, #3
 8004166:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8004168:	780b      	ldrb	r3, [r1, #0]
 800416a:	4383      	bics	r3, r0
 800416c:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800416e:	4003      	ands	r3, r0
 8004170:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8004172:	4b0f      	ldr	r3, [pc, #60]	; (80041b0 <Vector64+0xd0>)
 8004174:	608b      	str	r3, [r1, #8]
    trace_next();
 8004176:	f7fe fbe3 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800417a:	b662      	cpsie	i
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 800417c:	350f      	adds	r5, #15
 800417e:	d010      	beq.n	80041a2 <Vector64+0xc2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004180:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004182:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8004186:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004188:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800418c:	2280      	movs	r2, #128	; 0x80
 800418e:	0452      	lsls	r2, r2, #17
 8004190:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8004192:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8004194:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004196:	6889      	ldr	r1, [r1, #8]
 8004198:	6892      	ldr	r2, [r2, #8]
 800419a:	4291      	cmp	r1, r2
 800419c:	d802      	bhi.n	80041a4 <Vector64+0xc4>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800419e:	4a0a      	ldr	r2, [pc, #40]	; (80041c8 <Vector64+0xe8>)
 80041a0:	619a      	str	r2, [r3, #24]
  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);

  OSAL_IRQ_EPILOGUE();
}
 80041a2:	bd38      	pop	{r3, r4, r5, pc}

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80041a4:	4a09      	ldr	r2, [pc, #36]	; (80041cc <Vector64+0xec>)
 80041a6:	619a      	str	r2, [r3, #24]
 80041a8:	e7fb      	b.n	80041a2 <Vector64+0xc2>
 80041aa:	46c0      	nop			; (mov r8, r8)
 80041ac:	20000700 	.word	0x20000700
 80041b0:	080059bc 	.word	0x080059bc
 80041b4:	080059c8 	.word	0x080059c8
 80041b8:	40020000 	.word	0x40020000
 80041bc:	40020008 	.word	0x40020008
 80041c0:	20000424 	.word	0x20000424
 80041c4:	080059d0 	.word	0x080059d0
 80041c8:	080001d4 	.word	0x080001d4
 80041cc:	080001c9 	.word	0x080001c9

080041d0 <adc_lld_serve_rx_interrupt.lto_priv.60>:
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 80041d0:	b538      	push	{r3, r4, r5, lr}
 80041d2:	1c04      	adds	r4, r0, #0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80041d4:	070b      	lsls	r3, r1, #28
 80041d6:	d419      	bmi.n	800420c <adc_lld_serve_rx_interrupt.lto_priv.60+0x3c>
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 80041d8:	6903      	ldr	r3, [r0, #16]
 80041da:	2b00      	cmp	r3, #0
 80041dc:	d00e      	beq.n	80041fc <adc_lld_serve_rx_interrupt.lto_priv.60+0x2c>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 80041de:	078a      	lsls	r2, r1, #30
 80041e0:	d50d      	bpl.n	80041fe <adc_lld_serve_rx_interrupt.lto_priv.60+0x2e>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 80041e2:	781a      	ldrb	r2, [r3, #0]
 80041e4:	2a00      	cmp	r2, #0
 80041e6:	d051      	beq.n	800428c <adc_lld_serve_rx_interrupt.lto_priv.60+0xbc>
 80041e8:	685b      	ldr	r3, [r3, #4]
 80041ea:	2b00      	cmp	r3, #0
 80041ec:	d006      	beq.n	80041fc <adc_lld_serve_rx_interrupt.lto_priv.60+0x2c>
 80041ee:	2204      	movs	r2, #4
 80041f0:	7002      	strb	r2, [r0, #0]
 80041f2:	4798      	blx	r3
 80041f4:	7823      	ldrb	r3, [r4, #0]
 80041f6:	2b04      	cmp	r3, #4
 80041f8:	d100      	bne.n	80041fc <adc_lld_serve_rx_interrupt.lto_priv.60+0x2c>
 80041fa:	e091      	b.n	8004320 <adc_lld_serve_rx_interrupt.lto_priv.60+0x150>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 80041fc:	bd38      	pop	{r3, r4, r5, pc}
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 80041fe:	074a      	lsls	r2, r1, #29
 8004200:	d5fc      	bpl.n	80041fc <adc_lld_serve_rx_interrupt.lto_priv.60+0x2c>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 8004202:	685b      	ldr	r3, [r3, #4]
 8004204:	2b00      	cmp	r3, #0
 8004206:	d0f9      	beq.n	80041fc <adc_lld_serve_rx_interrupt.lto_priv.60+0x2c>
 8004208:	4798      	blx	r3
 800420a:	e7f7      	b.n	80041fc <adc_lld_serve_rx_interrupt.lto_priv.60+0x2c>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800420c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800420e:	200f      	movs	r0, #15
 8004210:	6859      	ldr	r1, [r3, #4]
 8004212:	680a      	ldr	r2, [r1, #0]
 8004214:	4382      	bics	r2, r0
 8004216:	600a      	str	r2, [r1, #0]
 8004218:	7b59      	ldrb	r1, [r3, #13]
 800421a:	681a      	ldr	r2, [r3, #0]
 800421c:	230e      	movs	r3, #14
 800421e:	408b      	lsls	r3, r1
 8004220:	6053      	str	r3, [r2, #4]
  adc_lld_stop_adc(adcp->adc);
 8004222:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
 8004224:	6893      	ldr	r3, [r2, #8]
 8004226:	075b      	lsls	r3, r3, #29
 8004228:	d418      	bmi.n	800425c <adc_lld_serve_rx_interrupt.lto_priv.60+0x8c>

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 800422a:	6923      	ldr	r3, [r4, #16]
 800422c:	689b      	ldr	r3, [r3, #8]
 800422e:	2b00      	cmp	r3, #0
 8004230:	d072      	beq.n	8004318 <adc_lld_serve_rx_interrupt.lto_priv.60+0x148>
 8004232:	2205      	movs	r2, #5
 8004234:	1c20      	adds	r0, r4, #0
 8004236:	7022      	strb	r2, [r4, #0]
 8004238:	2100      	movs	r1, #0
 800423a:	4798      	blx	r3
 800423c:	7823      	ldrb	r3, [r4, #0]
 800423e:	2b05      	cmp	r3, #5
 8004240:	d021      	beq.n	8004286 <adc_lld_serve_rx_interrupt.lto_priv.60+0xb6>
 8004242:	2300      	movs	r3, #0
 8004244:	6123      	str	r3, [r4, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004246:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004248:	4b45      	ldr	r3, [pc, #276]	; (8004360 <adc_lld_serve_rx_interrupt.lto_priv.60+0x190>)
 800424a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 800424c:	2a00      	cmp	r2, #0
 800424e:	dd02      	ble.n	8004256 <adc_lld_serve_rx_interrupt.lto_priv.60+0x86>
 8004250:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004252:	2a00      	cmp	r2, #0
 8004254:	d00b      	beq.n	800426e <adc_lld_serve_rx_interrupt.lto_priv.60+0x9e>
    chSysHalt("SV#6");
 8004256:	4843      	ldr	r0, [pc, #268]	; (8004364 <adc_lld_serve_rx_interrupt.lto_priv.60+0x194>)
 8004258:	f7fe fb8a 	bl	8002970 <chSysHalt>
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 800425c:	2310      	movs	r3, #16
 800425e:	6891      	ldr	r1, [r2, #8]
 8004260:	430b      	orrs	r3, r1
    while (adc->CR & ADC_CR_ADSTP)
 8004262:	2110      	movs	r1, #16
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8004264:	6093      	str	r3, [r2, #8]
    while (adc->CR & ADC_CR_ADSTP)
 8004266:	6893      	ldr	r3, [r2, #8]
 8004268:	4219      	tst	r1, r3
 800426a:	d1fc      	bne.n	8004266 <adc_lld_serve_rx_interrupt.lto_priv.60+0x96>
 800426c:	e7dd      	b.n	800422a <adc_lld_serve_rx_interrupt.lto_priv.60+0x5a>
  }
  _dbg_enter_lock();
 800426e:	2101      	movs	r1, #1
 8004270:	6359      	str	r1, [r3, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8004272:	6961      	ldr	r1, [r4, #20]
 8004274:	2900      	cmp	r1, #0
 8004276:	d046      	beq.n	8004306 <adc_lld_serve_rx_interrupt.lto_priv.60+0x136>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004278:	2020      	movs	r0, #32
 800427a:	5c0d      	ldrb	r5, [r1, r0]
 800427c:	2d03      	cmp	r5, #3
 800427e:	d052      	beq.n	8004326 <adc_lld_serve_rx_interrupt.lto_priv.60+0x156>
 8004280:	4839      	ldr	r0, [pc, #228]	; (8004368 <adc_lld_serve_rx_interrupt.lto_priv.60+0x198>)
 8004282:	f7fe fb75 	bl	8002970 <chSysHalt>

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8004286:	3b03      	subs	r3, #3
 8004288:	7023      	strb	r3, [r4, #0]
 800428a:	e7da      	b.n	8004242 <adc_lld_serve_rx_interrupt.lto_priv.60+0x72>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800428c:	250f      	movs	r5, #15
 800428e:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8004290:	6850      	ldr	r0, [r2, #4]
 8004292:	6801      	ldr	r1, [r0, #0]
 8004294:	43a9      	bics	r1, r5
 8004296:	6001      	str	r1, [r0, #0]
 8004298:	7b50      	ldrb	r0, [r2, #13]
 800429a:	6811      	ldr	r1, [r2, #0]
 800429c:	220e      	movs	r2, #14
 800429e:	4082      	lsls	r2, r0
 80042a0:	604a      	str	r2, [r1, #4]
  adc_lld_stop_adc(adcp->adc);
 80042a2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
 80042a4:	688a      	ldr	r2, [r1, #8]
 80042a6:	0752      	lsls	r2, r2, #29
 80042a8:	d44e      	bmi.n	8004348 <adc_lld_serve_rx_interrupt.lto_priv.60+0x178>
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 80042aa:	685b      	ldr	r3, [r3, #4]
 80042ac:	2b00      	cmp	r3, #0
 80042ae:	d02e      	beq.n	800430e <adc_lld_serve_rx_interrupt.lto_priv.60+0x13e>
 80042b0:	2204      	movs	r2, #4
 80042b2:	1c20      	adds	r0, r4, #0
 80042b4:	7022      	strb	r2, [r4, #0]
 80042b6:	4798      	blx	r3
 80042b8:	7823      	ldrb	r3, [r4, #0]
 80042ba:	2b04      	cmp	r3, #4
 80042bc:	d027      	beq.n	800430e <adc_lld_serve_rx_interrupt.lto_priv.60+0x13e>
 80042be:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80042c0:	4b27      	ldr	r3, [pc, #156]	; (8004360 <adc_lld_serve_rx_interrupt.lto_priv.60+0x190>)
 80042c2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80042c4:	2a00      	cmp	r2, #0
 80042c6:	ddc6      	ble.n	8004256 <adc_lld_serve_rx_interrupt.lto_priv.60+0x86>
 80042c8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80042ca:	2a00      	cmp	r2, #0
 80042cc:	d1c3      	bne.n	8004256 <adc_lld_serve_rx_interrupt.lto_priv.60+0x86>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 80042ce:	2101      	movs	r1, #1
 80042d0:	6359      	str	r1, [r3, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 80042d2:	6961      	ldr	r1, [r4, #20]
 80042d4:	2900      	cmp	r1, #0
 80042d6:	d016      	beq.n	8004306 <adc_lld_serve_rx_interrupt.lto_priv.60+0x136>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 80042d8:	2020      	movs	r0, #32
 80042da:	5c0d      	ldrb	r5, [r1, r0]
 80042dc:	2d03      	cmp	r5, #3
 80042de:	d1cf      	bne.n	8004280 <adc_lld_serve_rx_interrupt.lto_priv.60+0xb0>

    *trp = NULL;
 80042e0:	6162      	str	r2, [r4, #20]
    tp->u.rdymsg = msg;
 80042e2:	624a      	str	r2, [r1, #36]	; 0x24
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80042e4:	5c0c      	ldrb	r4, [r1, r0]
 80042e6:	2c00      	cmp	r4, #0
 80042e8:	d037      	beq.n	800435a <adc_lld_serve_rx_interrupt.lto_priv.60+0x18a>
 80042ea:	2c0f      	cmp	r4, #15
 80042ec:	d035      	beq.n	800435a <adc_lld_serve_rx_interrupt.lto_priv.60+0x18a>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80042ee:	540a      	strb	r2, [r1, r0]
  cp = (thread_t *)&ch.rlist.queue;
 80042f0:	1c1a      	adds	r2, r3, #0
 80042f2:	6888      	ldr	r0, [r1, #8]
  do {
    cp = cp->queue.next;
 80042f4:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 80042f6:	6894      	ldr	r4, [r2, #8]
 80042f8:	4284      	cmp	r4, r0
 80042fa:	d2fb      	bcs.n	80042f4 <adc_lld_serve_rx_interrupt.lto_priv.60+0x124>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80042fc:	600a      	str	r2, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 80042fe:	6850      	ldr	r0, [r2, #4]
 8004300:	6048      	str	r0, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8004302:	6001      	str	r1, [r0, #0]
  cp->queue.prev             = tp;
 8004304:	6051      	str	r1, [r2, #4]
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8004306:	2200      	movs	r2, #0
 8004308:	635a      	str	r2, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800430a:	b662      	cpsie	i
 800430c:	e776      	b.n	80041fc <adc_lld_serve_rx_interrupt.lto_priv.60+0x2c>
 800430e:	2302      	movs	r3, #2
 8004310:	7023      	strb	r3, [r4, #0]
 8004312:	2300      	movs	r3, #0
 8004314:	6123      	str	r3, [r4, #16]
 8004316:	e7d2      	b.n	80042be <adc_lld_serve_rx_interrupt.lto_priv.60+0xee>

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8004318:	2202      	movs	r2, #2
 800431a:	6123      	str	r3, [r4, #16]
 800431c:	7022      	strb	r2, [r4, #0]
 800431e:	e792      	b.n	8004246 <adc_lld_serve_rx_interrupt.lto_priv.60+0x76>
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8004320:	3b01      	subs	r3, #1
 8004322:	7023      	strb	r3, [r4, #0]
 8004324:	e76a      	b.n	80041fc <adc_lld_serve_rx_interrupt.lto_priv.60+0x2c>
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8004326:	6162      	str	r2, [r4, #20]
    tp->u.rdymsg = msg;
 8004328:	2401      	movs	r4, #1
 800432a:	4264      	negs	r4, r4
 800432c:	624c      	str	r4, [r1, #36]	; 0x24
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800432e:	5c0c      	ldrb	r4, [r1, r0]
 8004330:	2c00      	cmp	r4, #0
 8004332:	d012      	beq.n	800435a <adc_lld_serve_rx_interrupt.lto_priv.60+0x18a>
 8004334:	2c0f      	cmp	r4, #15
 8004336:	d010      	beq.n	800435a <adc_lld_serve_rx_interrupt.lto_priv.60+0x18a>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8004338:	540a      	strb	r2, [r1, r0]
  cp = (thread_t *)&ch.rlist.queue;
 800433a:	1c1a      	adds	r2, r3, #0
 800433c:	6888      	ldr	r0, [r1, #8]
  do {
    cp = cp->queue.next;
 800433e:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8004340:	6894      	ldr	r4, [r2, #8]
 8004342:	4284      	cmp	r4, r0
 8004344:	d2fb      	bcs.n	800433e <adc_lld_serve_rx_interrupt.lto_priv.60+0x16e>
 8004346:	e7d9      	b.n	80042fc <adc_lld_serve_rx_interrupt.lto_priv.60+0x12c>
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8004348:	2210      	movs	r2, #16
 800434a:	6888      	ldr	r0, [r1, #8]
 800434c:	4302      	orrs	r2, r0
    while (adc->CR & ADC_CR_ADSTP)
 800434e:	2010      	movs	r0, #16
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8004350:	608a      	str	r2, [r1, #8]
    while (adc->CR & ADC_CR_ADSTP)
 8004352:	688a      	ldr	r2, [r1, #8]
 8004354:	4210      	tst	r0, r2
 8004356:	d1fc      	bne.n	8004352 <adc_lld_serve_rx_interrupt.lto_priv.60+0x182>
 8004358:	e7a7      	b.n	80042aa <adc_lld_serve_rx_interrupt.lto_priv.60+0xda>
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800435a:	4804      	ldr	r0, [pc, #16]	; (800436c <adc_lld_serve_rx_interrupt.lto_priv.60+0x19c>)
 800435c:	f7fe fb08 	bl	8002970 <chSysHalt>
 8004360:	20000700 	.word	0x20000700
 8004364:	080058fc 	.word	0x080058fc
 8004368:	080059f4 	.word	0x080059f4
 800436c:	08005abc 	.word	0x08005abc

08004370 <Vector70>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8004370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004372:	4656      	mov	r6, sl
 8004374:	4644      	mov	r4, r8
 8004376:	465f      	mov	r7, fp
 8004378:	464d      	mov	r5, r9
 800437a:	b4f0      	push	{r4, r5, r6, r7}
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800437c:	4c90      	ldr	r4, [pc, #576]	; (80045c0 <Vector70+0x250>)

  OSAL_IRQ_PROLOGUE();
 800437e:	4676      	mov	r6, lr
 8004380:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8004382:	079b      	lsls	r3, r3, #30
 8004384:	d40d      	bmi.n	80043a2 <Vector70+0x32>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004386:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8004388:	2007      	movs	r0, #7
 800438a:	2202      	movs	r2, #2
 800438c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800438e:	780b      	ldrb	r3, [r1, #0]
 8004390:	4383      	bics	r3, r0
 8004392:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8004394:	4003      	ands	r3, r0
 8004396:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8004398:	4b8a      	ldr	r3, [pc, #552]	; (80045c4 <Vector70+0x254>)
 800439a:	608b      	str	r3, [r1, #8]
    trace_next();
 800439c:	f7fe fad0 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80043a0:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80043a2:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80043a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80043a6:	2b00      	cmp	r3, #0
 80043a8:	db02      	blt.n	80043b0 <Vector70+0x40>
 80043aa:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80043ac:	2a00      	cmp	r2, #0
 80043ae:	d002      	beq.n	80043b6 <Vector70+0x46>
    chSysHalt("SV#8");
 80043b0:	4885      	ldr	r0, [pc, #532]	; (80045c8 <Vector70+0x258>)
 80043b2:	f7fe fadd 	bl	8002970 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 80043b6:	3301      	adds	r3, #1
 80043b8:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80043ba:	b662      	cpsie	i
 * @notapi
 */
void adc_lld_serve_interrupt(ADCDriver *adcp) {
  uint32_t isr;

  isr = adcp->adc->ISR;
 80043bc:	4d83      	ldr	r5, [pc, #524]	; (80045cc <Vector70+0x25c>)
 80043be:	6aab      	ldr	r3, [r5, #40]	; 0x28
  adcp->adc->ISR = isr;

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 80043c0:	692a      	ldr	r2, [r5, #16]
 * @notapi
 */
void adc_lld_serve_interrupt(ADCDriver *adcp) {
  uint32_t isr;

  isr = adcp->adc->ISR;
 80043c2:	681f      	ldr	r7, [r3, #0]
  adcp->adc->ISR = isr;
 80043c4:	601f      	str	r7, [r3, #0]

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 80043c6:	2a00      	cmp	r2, #0
 80043c8:	d00c      	beq.n	80043e4 <Vector70+0x74>
    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
 80043ca:	2110      	movs	r1, #16
 80043cc:	468a      	mov	sl, r1
 80043ce:	4239      	tst	r1, r7
 80043d0:	d006      	beq.n	80043e0 <Vector70+0x70>
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
 80043d2:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 80043d4:	468b      	mov	fp, r1
 80043d6:	6849      	ldr	r1, [r1, #4]
 80043d8:	468c      	mov	ip, r1
 80043da:	6849      	ldr	r1, [r1, #4]
  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
 80043dc:	2900      	cmp	r1, #0
 80043de:	d155      	bne.n	800448c <Vector70+0x11c>
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
    }
    if (isr & ADC_ISR_AWD) {
 80043e0:	063b      	lsls	r3, r7, #24
 80043e2:	d409      	bmi.n	80043f8 <Vector70+0x88>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80043e4:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80043e6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80043e8:	2b00      	cmp	r3, #0
 80043ea:	dd02      	ble.n	80043f2 <Vector70+0x82>
 80043ec:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80043ee:	2a00      	cmp	r2, #0
 80043f0:	d02d      	beq.n	800444e <Vector70+0xde>
    chSysHalt("SV#9");
 80043f2:	4877      	ldr	r0, [pc, #476]	; (80045d0 <Vector70+0x260>)
 80043f4:	f7fe fabc 	bl	8002970 <chSysHalt>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80043f8:	200f      	movs	r0, #15
 80043fa:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80043fc:	6859      	ldr	r1, [r3, #4]
 80043fe:	680a      	ldr	r2, [r1, #0]
 8004400:	4382      	bics	r2, r0
 8004402:	600a      	str	r2, [r1, #0]
 8004404:	7b59      	ldrb	r1, [r3, #13]
 8004406:	681a      	ldr	r2, [r3, #0]
 8004408:	230e      	movs	r3, #14
 800440a:	408b      	lsls	r3, r1
 800440c:	6053      	str	r3, [r2, #4]
  adc_lld_stop_adc(adcp->adc);
 800440e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
 8004410:	6893      	ldr	r3, [r2, #8]
 8004412:	075b      	lsls	r3, r3, #29
 8004414:	d500      	bpl.n	8004418 <Vector70+0xa8>
 8004416:	e094      	b.n	8004542 <Vector70+0x1d2>
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
    }
    if (isr & ADC_ISR_AWD) {
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD);
 8004418:	692b      	ldr	r3, [r5, #16]
 800441a:	689b      	ldr	r3, [r3, #8]
 800441c:	2b00      	cmp	r3, #0
 800441e:	d100      	bne.n	8004422 <Vector70+0xb2>
 8004420:	e0b4      	b.n	800458c <Vector70+0x21c>
 8004422:	2205      	movs	r2, #5
 8004424:	1c28      	adds	r0, r5, #0
 8004426:	702a      	strb	r2, [r5, #0]
 8004428:	2102      	movs	r1, #2
 800442a:	4798      	blx	r3
 800442c:	782b      	ldrb	r3, [r5, #0]
 800442e:	2b05      	cmp	r3, #5
 8004430:	d100      	bne.n	8004434 <Vector70+0xc4>
 8004432:	e0b2      	b.n	800459a <Vector70+0x22a>
 8004434:	2300      	movs	r3, #0
 8004436:	612b      	str	r3, [r5, #16]
 8004438:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800443a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800443c:	2b00      	cmp	r3, #0
 800443e:	dd03      	ble.n	8004448 <Vector70+0xd8>
 8004440:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8004442:	2b00      	cmp	r3, #0
 8004444:	d100      	bne.n	8004448 <Vector70+0xd8>
 8004446:	e085      	b.n	8004554 <Vector70+0x1e4>
    chSysHalt("SV#6");
 8004448:	4862      	ldr	r0, [pc, #392]	; (80045d4 <Vector70+0x264>)
 800444a:	f7fe fa91 	bl	8002970 <chSysHalt>

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 800444e:	3b01      	subs	r3, #1
 8004450:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004452:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004454:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8004456:	079b      	lsls	r3, r3, #30
 8004458:	d561      	bpl.n	800451e <Vector70+0x1ae>
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 800445a:	360f      	adds	r6, #15
 800445c:	d010      	beq.n	8004480 <Vector70+0x110>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800445e:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004460:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8004464:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004466:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800446a:	2280      	movs	r2, #128	; 0x80
 800446c:	0452      	lsls	r2, r2, #17
 800446e:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8004470:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8004472:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004474:	6889      	ldr	r1, [r1, #8]
 8004476:	6892      	ldr	r2, [r2, #8]
 8004478:	4291      	cmp	r1, r2
 800447a:	d85f      	bhi.n	800453c <Vector70+0x1cc>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800447c:	4a56      	ldr	r2, [pc, #344]	; (80045d8 <Vector70+0x268>)
 800447e:	619a      	str	r2, [r3, #24]
#if defined(STM32_ADC_ADC1_IRQ_HOOK)
  STM32_ADC_ADC1_IRQ_HOOK
#endif

  OSAL_IRQ_EPILOGUE();
}
 8004480:	bc3c      	pop	{r2, r3, r4, r5}
 8004482:	4690      	mov	r8, r2
 8004484:	4699      	mov	r9, r3
 8004486:	46a2      	mov	sl, r4
 8004488:	46ab      	mov	fp, r5
 800448a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800448c:	4661      	mov	r1, ip
 800448e:	6809      	ldr	r1, [r1, #0]
 8004490:	4688      	mov	r8, r1
 8004492:	210f      	movs	r1, #15
 8004494:	4689      	mov	r9, r1
 8004496:	4641      	mov	r1, r8
 8004498:	4648      	mov	r0, r9
 800449a:	4381      	bics	r1, r0
 800449c:	4688      	mov	r8, r1
 800449e:	4661      	mov	r1, ip
 80044a0:	4640      	mov	r0, r8
 80044a2:	6008      	str	r0, [r1, #0]
 80044a4:	4659      	mov	r1, fp
 80044a6:	6809      	ldr	r1, [r1, #0]
 80044a8:	200e      	movs	r0, #14
 80044aa:	468c      	mov	ip, r1
 80044ac:	4659      	mov	r1, fp
 80044ae:	7b49      	ldrb	r1, [r1, #13]
 80044b0:	4088      	lsls	r0, r1
 80044b2:	4661      	mov	r1, ip
 80044b4:	6048      	str	r0, [r1, #4]
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
 80044b6:	6898      	ldr	r0, [r3, #8]
 80044b8:	0741      	lsls	r1, r0, #29
 80044ba:	d471      	bmi.n	80045a0 <Vector70+0x230>
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
 80044bc:	6893      	ldr	r3, [r2, #8]
 80044be:	2b00      	cmp	r3, #0
 80044c0:	d077      	beq.n	80045b2 <Vector70+0x242>
 80044c2:	2205      	movs	r2, #5
 80044c4:	1c28      	adds	r0, r5, #0
 80044c6:	702a      	strb	r2, [r5, #0]
 80044c8:	2101      	movs	r1, #1
 80044ca:	4798      	blx	r3
 80044cc:	782b      	ldrb	r3, [r5, #0]
 80044ce:	2b05      	cmp	r3, #5
 80044d0:	d073      	beq.n	80045ba <Vector70+0x24a>
 80044d2:	2300      	movs	r3, #0
 80044d4:	612b      	str	r3, [r5, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80044d6:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80044d8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80044da:	2b00      	cmp	r3, #0
 80044dc:	ddb4      	ble.n	8004448 <Vector70+0xd8>
 80044de:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80044e0:	2b00      	cmp	r3, #0
 80044e2:	d1b1      	bne.n	8004448 <Vector70+0xd8>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 80044e4:	2201      	movs	r2, #1
 80044e6:	6362      	str	r2, [r4, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 80044e8:	696a      	ldr	r2, [r5, #20]
 80044ea:	2a00      	cmp	r2, #0
 80044ec:	d013      	beq.n	8004516 <Vector70+0x1a6>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 80044ee:	2120      	movs	r1, #32
 80044f0:	5c50      	ldrb	r0, [r2, r1]
 80044f2:	2803      	cmp	r0, #3
 80044f4:	d14e      	bne.n	8004594 <Vector70+0x224>

    *trp = NULL;
    tp->u.rdymsg = msg;
 80044f6:	2001      	movs	r0, #1
 80044f8:	4240      	negs	r0, r0
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 80044fa:	616b      	str	r3, [r5, #20]
    tp->u.rdymsg = msg;
 80044fc:	6250      	str	r0, [r2, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80044fe:	5453      	strb	r3, [r2, r1]
  cp = (thread_t *)&ch.rlist.queue;
 8004500:	1c23      	adds	r3, r4, #0
 8004502:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8004504:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8004506:	6898      	ldr	r0, [r3, #8]
 8004508:	4288      	cmp	r0, r1
 800450a:	d2fb      	bcs.n	8004504 <Vector70+0x194>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800450c:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800450e:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8004510:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8004512:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8004514:	605a      	str	r2, [r3, #4]
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8004516:	2300      	movs	r3, #0
 8004518:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800451a:	b662      	cpsie	i
 800451c:	e760      	b.n	80043e0 <Vector70+0x70>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800451e:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004520:	2007      	movs	r0, #7
 8004522:	2203      	movs	r2, #3
 8004524:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8004526:	780b      	ldrb	r3, [r1, #0]
 8004528:	4383      	bics	r3, r0
 800452a:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800452c:	4003      	ands	r3, r0
 800452e:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8004530:	4b24      	ldr	r3, [pc, #144]	; (80045c4 <Vector70+0x254>)
 8004532:	608b      	str	r3, [r1, #8]
    trace_next();
 8004534:	f7fe fa04 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004538:	b662      	cpsie	i
 800453a:	e78e      	b.n	800445a <Vector70+0xea>

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800453c:	4a27      	ldr	r2, [pc, #156]	; (80045dc <Vector70+0x26c>)
 800453e:	619a      	str	r2, [r3, #24]
 8004540:	e79e      	b.n	8004480 <Vector70+0x110>
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8004542:	2310      	movs	r3, #16
 8004544:	6891      	ldr	r1, [r2, #8]
 8004546:	430b      	orrs	r3, r1
    while (adc->CR & ADC_CR_ADSTP)
 8004548:	2110      	movs	r1, #16
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 800454a:	6093      	str	r3, [r2, #8]
    while (adc->CR & ADC_CR_ADSTP)
 800454c:	6893      	ldr	r3, [r2, #8]
 800454e:	4219      	tst	r1, r3
 8004550:	d1fc      	bne.n	800454c <Vector70+0x1dc>
 8004552:	e761      	b.n	8004418 <Vector70+0xa8>
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8004554:	2201      	movs	r2, #1
 8004556:	6362      	str	r2, [r4, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8004558:	696a      	ldr	r2, [r5, #20]
 800455a:	2a00      	cmp	r2, #0
 800455c:	d012      	beq.n	8004584 <Vector70+0x214>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800455e:	2120      	movs	r1, #32
 8004560:	5c50      	ldrb	r0, [r2, r1]
 8004562:	2803      	cmp	r0, #3
 8004564:	d116      	bne.n	8004594 <Vector70+0x224>

    *trp = NULL;
    tp->u.rdymsg = msg;
 8004566:	3804      	subs	r0, #4
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8004568:	616b      	str	r3, [r5, #20]
    tp->u.rdymsg = msg;
 800456a:	6250      	str	r0, [r2, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800456c:	5453      	strb	r3, [r2, r1]
  cp = (thread_t *)&ch.rlist.queue;
 800456e:	1c23      	adds	r3, r4, #0
 8004570:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8004572:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8004574:	6898      	ldr	r0, [r3, #8]
 8004576:	4288      	cmp	r0, r1
 8004578:	d2fb      	bcs.n	8004572 <Vector70+0x202>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800457a:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800457c:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 800457e:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8004580:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8004582:	605a      	str	r2, [r3, #4]
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8004584:	2300      	movs	r3, #0
 8004586:	6363      	str	r3, [r4, #52]	; 0x34
 8004588:	b662      	cpsie	i
 800458a:	e72b      	b.n	80043e4 <Vector70+0x74>
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
    }
    if (isr & ADC_ISR_AWD) {
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD);
 800458c:	2202      	movs	r2, #2
 800458e:	612b      	str	r3, [r5, #16]
 8004590:	702a      	strb	r2, [r5, #0]
 8004592:	e751      	b.n	8004438 <Vector70+0xc8>
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004594:	4812      	ldr	r0, [pc, #72]	; (80045e0 <Vector70+0x270>)
 8004596:	f7fe f9eb 	bl	8002970 <chSysHalt>
 800459a:	3b03      	subs	r3, #3
 800459c:	702b      	strb	r3, [r5, #0]
 800459e:	e749      	b.n	8004434 <Vector70+0xc4>
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 80045a0:	4651      	mov	r1, sl
 80045a2:	6898      	ldr	r0, [r3, #8]
 80045a4:	4301      	orrs	r1, r0
    while (adc->CR & ADC_CR_ADSTP)
 80045a6:	2010      	movs	r0, #16
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 80045a8:	6099      	str	r1, [r3, #8]
    while (adc->CR & ADC_CR_ADSTP)
 80045aa:	6899      	ldr	r1, [r3, #8]
 80045ac:	4208      	tst	r0, r1
 80045ae:	d1fc      	bne.n	80045aa <Vector70+0x23a>
 80045b0:	e784      	b.n	80044bc <Vector70+0x14c>
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
 80045b2:	2202      	movs	r2, #2
 80045b4:	612b      	str	r3, [r5, #16]
 80045b6:	702a      	strb	r2, [r5, #0]
 80045b8:	e78d      	b.n	80044d6 <Vector70+0x166>
 80045ba:	3b03      	subs	r3, #3
 80045bc:	702b      	strb	r3, [r5, #0]
 80045be:	e788      	b.n	80044d2 <Vector70+0x162>
 80045c0:	20000700 	.word	0x20000700
 80045c4:	08005a10 	.word	0x08005a10
 80045c8:	080059c8 	.word	0x080059c8
 80045cc:	2000045c 	.word	0x2000045c
 80045d0:	080059d0 	.word	0x080059d0
 80045d4:	080058fc 	.word	0x080058fc
 80045d8:	080001d4 	.word	0x080001d4
 80045dc:	080001c9 	.word	0x080001c9
 80045e0:	080059f4 	.word	0x080059f4
	...

080045f0 <Vector6C>:
/**
 * @brief   DMA1 streams 4, 5, 6 and 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4567_HANDLER) {
 80045f0:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80045f2:	4c3b      	ldr	r4, [pc, #236]	; (80046e0 <Vector6C+0xf0>)

  OSAL_IRQ_PROLOGUE();
 80045f4:	4675      	mov	r5, lr
 80045f6:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 80045f8:	079b      	lsls	r3, r3, #30
 80045fa:	d40d      	bmi.n	8004618 <Vector6C+0x28>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80045fc:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 80045fe:	2007      	movs	r0, #7
 8004600:	2202      	movs	r2, #2
 8004602:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8004604:	780b      	ldrb	r3, [r1, #0]
 8004606:	4383      	bics	r3, r0
 8004608:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800460a:	4003      	ands	r3, r0
 800460c:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800460e:	4b35      	ldr	r3, [pc, #212]	; (80046e4 <Vector6C+0xf4>)
 8004610:	608b      	str	r3, [r1, #8]
    trace_next();
 8004612:	f7fe f995 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004616:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004618:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800461a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800461c:	2b00      	cmp	r3, #0
 800461e:	db02      	blt.n	8004626 <Vector6C+0x36>
 8004620:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8004622:	2a00      	cmp	r2, #0
 8004624:	d002      	beq.n	800462c <Vector6C+0x3c>
    chSysHalt("SV#8");
 8004626:	4830      	ldr	r0, [pc, #192]	; (80046e8 <Vector6C+0xf8>)
 8004628:	f7fe f9a2 	bl	8002970 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800462c:	3301      	adds	r3, #1
 800462e:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004630:	b662      	cpsie	i
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t idx = (dmastp)->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8004632:	220e      	movs	r2, #14
 8004634:	4b2d      	ldr	r3, [pc, #180]	; (80046ec <Vector6C+0xfc>)
 8004636:	6819      	ldr	r1, [r3, #0]
 8004638:	0b09      	lsrs	r1, r1, #12
 800463a:	4011      	ands	r1, r2
  if (flags & dmastp->channel->CCR) {
 800463c:	4a2c      	ldr	r2, [pc, #176]	; (80046f0 <Vector6C+0x100>)
 800463e:	6812      	ldr	r2, [r2, #0]
 8004640:	420a      	tst	r2, r1
 8004642:	d007      	beq.n	8004654 <Vector6C+0x64>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8004644:	030a      	lsls	r2, r1, #12
 8004646:	605a      	str	r2, [r3, #4]
    if (dma.streams[idx].func) {
 8004648:	4a2a      	ldr	r2, [pc, #168]	; (80046f4 <Vector6C+0x104>)
 800464a:	6a13      	ldr	r3, [r2, #32]
 800464c:	2b00      	cmp	r3, #0
 800464e:	d001      	beq.n	8004654 <Vector6C+0x64>
      dma.streams[idx].func(dma.streams[idx].param, flags);
 8004650:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8004652:	4798      	blx	r3
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t idx = (dmastp)->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8004654:	220e      	movs	r2, #14
 8004656:	4b25      	ldr	r3, [pc, #148]	; (80046ec <Vector6C+0xfc>)
 8004658:	6819      	ldr	r1, [r3, #0]
 800465a:	0c09      	lsrs	r1, r1, #16
 800465c:	4011      	ands	r1, r2
  if (flags & dmastp->channel->CCR) {
 800465e:	4a26      	ldr	r2, [pc, #152]	; (80046f8 <Vector6C+0x108>)
 8004660:	6812      	ldr	r2, [r2, #0]
 8004662:	420a      	tst	r2, r1
 8004664:	d007      	beq.n	8004676 <Vector6C+0x86>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8004666:	040a      	lsls	r2, r1, #16
 8004668:	605a      	str	r2, [r3, #4]
    if (dma.streams[idx].func) {
 800466a:	4a22      	ldr	r2, [pc, #136]	; (80046f4 <Vector6C+0x104>)
 800466c:	6a93      	ldr	r3, [r2, #40]	; 0x28
 800466e:	2b00      	cmp	r3, #0
 8004670:	d001      	beq.n	8004676 <Vector6C+0x86>
      dma.streams[idx].func(dma.streams[idx].param, flags);
 8004672:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8004674:	4798      	blx	r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004676:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004678:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800467a:	2b00      	cmp	r3, #0
 800467c:	dd02      	ble.n	8004684 <Vector6C+0x94>
 800467e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8004680:	2a00      	cmp	r2, #0
 8004682:	d002      	beq.n	800468a <Vector6C+0x9a>
    chSysHalt("SV#9");
 8004684:	481d      	ldr	r0, [pc, #116]	; (80046fc <Vector6C+0x10c>)
 8004686:	f7fe f973 	bl	8002970 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 800468a:	3b01      	subs	r3, #1
 800468c:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800468e:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004690:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8004692:	079b      	lsls	r3, r3, #30
 8004694:	d40d      	bmi.n	80046b2 <Vector6C+0xc2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004696:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8004698:	2007      	movs	r0, #7
 800469a:	2203      	movs	r2, #3
 800469c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 800469e:	780b      	ldrb	r3, [r1, #0]
 80046a0:	4383      	bics	r3, r0
 80046a2:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 80046a4:	4003      	ands	r3, r0
 80046a6:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80046a8:	4b0e      	ldr	r3, [pc, #56]	; (80046e4 <Vector6C+0xf4>)
 80046aa:	608b      	str	r3, [r1, #8]
    trace_next();
 80046ac:	f7fe f948 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80046b0:	b662      	cpsie	i
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 80046b2:	350f      	adds	r5, #15
 80046b4:	d010      	beq.n	80046d8 <Vector6C+0xe8>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80046b6:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80046b8:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80046bc:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80046be:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80046c2:	2280      	movs	r2, #128	; 0x80
 80046c4:	0452      	lsls	r2, r2, #17
 80046c6:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80046c8:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80046ca:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80046cc:	6889      	ldr	r1, [r1, #8]
 80046ce:	6892      	ldr	r2, [r2, #8]
 80046d0:	4291      	cmp	r1, r2
 80046d2:	d802      	bhi.n	80046da <Vector6C+0xea>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80046d4:	4a0a      	ldr	r2, [pc, #40]	; (8004700 <Vector6C+0x110>)
 80046d6:	619a      	str	r2, [r3, #24]
  /* Check on channel 7.*/
  dmaServeInterrupt(STM32_DMA1_STREAM7);
#endif

  OSAL_IRQ_EPILOGUE();
}
 80046d8:	bd38      	pop	{r3, r4, r5, pc}

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80046da:	4a0a      	ldr	r2, [pc, #40]	; (8004704 <Vector6C+0x114>)
 80046dc:	619a      	str	r2, [r3, #24]
 80046de:	e7fb      	b.n	80046d8 <Vector6C+0xe8>
 80046e0:	20000700 	.word	0x20000700
 80046e4:	08005a04 	.word	0x08005a04
 80046e8:	080059c8 	.word	0x080059c8
 80046ec:	40020000 	.word	0x40020000
 80046f0:	40020044 	.word	0x40020044
 80046f4:	20000424 	.word	0x20000424
 80046f8:	40020058 	.word	0x40020058
 80046fc:	080059d0 	.word	0x080059d0
 8004700:	080001d4 	.word	0x080001d4
 8004704:	080001c9 	.word	0x080001c9
	...

08004710 <Vector68>:
 * @note    It is declared here because this device has a non-standard
 *          DMA shared IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH23_HANDLER) {
 8004710:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8004712:	4c3b      	ldr	r4, [pc, #236]	; (8004800 <Vector68+0xf0>)

  OSAL_IRQ_PROLOGUE();
 8004714:	4675      	mov	r5, lr
 8004716:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8004718:	079b      	lsls	r3, r3, #30
 800471a:	d40d      	bmi.n	8004738 <Vector68+0x28>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800471c:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800471e:	2007      	movs	r0, #7
 8004720:	2202      	movs	r2, #2
 8004722:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8004724:	780b      	ldrb	r3, [r1, #0]
 8004726:	4383      	bics	r3, r0
 8004728:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800472a:	4003      	ands	r3, r0
 800472c:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800472e:	4b35      	ldr	r3, [pc, #212]	; (8004804 <Vector68+0xf4>)
 8004730:	608b      	str	r3, [r1, #8]
    trace_next();
 8004732:	f7fe f905 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004736:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004738:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800473a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800473c:	2b00      	cmp	r3, #0
 800473e:	db02      	blt.n	8004746 <Vector68+0x36>
 8004740:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8004742:	2a00      	cmp	r2, #0
 8004744:	d002      	beq.n	800474c <Vector68+0x3c>
    chSysHalt("SV#8");
 8004746:	4830      	ldr	r0, [pc, #192]	; (8004808 <Vector68+0xf8>)
 8004748:	f7fe f912 	bl	8002970 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800474c:	3301      	adds	r3, #1
 800474e:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004750:	b662      	cpsie	i
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t idx = (dmastp)->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8004752:	220e      	movs	r2, #14
 8004754:	4b2d      	ldr	r3, [pc, #180]	; (800480c <Vector68+0xfc>)
 8004756:	6819      	ldr	r1, [r3, #0]
 8004758:	0909      	lsrs	r1, r1, #4
 800475a:	4011      	ands	r1, r2
  if (flags & dmastp->channel->CCR) {
 800475c:	4a2c      	ldr	r2, [pc, #176]	; (8004810 <Vector68+0x100>)
 800475e:	6812      	ldr	r2, [r2, #0]
 8004760:	420a      	tst	r2, r1
 8004762:	d007      	beq.n	8004774 <Vector68+0x64>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8004764:	010a      	lsls	r2, r1, #4
 8004766:	605a      	str	r2, [r3, #4]
    if (dma.streams[idx].func) {
 8004768:	4a2a      	ldr	r2, [pc, #168]	; (8004814 <Vector68+0x104>)
 800476a:	6913      	ldr	r3, [r2, #16]
 800476c:	2b00      	cmp	r3, #0
 800476e:	d001      	beq.n	8004774 <Vector68+0x64>
      dma.streams[idx].func(dma.streams[idx].param, flags);
 8004770:	6950      	ldr	r0, [r2, #20]
 8004772:	4798      	blx	r3
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t idx = (dmastp)->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8004774:	220e      	movs	r2, #14
 8004776:	4b25      	ldr	r3, [pc, #148]	; (800480c <Vector68+0xfc>)
 8004778:	6819      	ldr	r1, [r3, #0]
 800477a:	0a09      	lsrs	r1, r1, #8
 800477c:	4011      	ands	r1, r2
  if (flags & dmastp->channel->CCR) {
 800477e:	4a26      	ldr	r2, [pc, #152]	; (8004818 <Vector68+0x108>)
 8004780:	6812      	ldr	r2, [r2, #0]
 8004782:	420a      	tst	r2, r1
 8004784:	d007      	beq.n	8004796 <Vector68+0x86>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8004786:	020a      	lsls	r2, r1, #8
 8004788:	605a      	str	r2, [r3, #4]
    if (dma.streams[idx].func) {
 800478a:	4a22      	ldr	r2, [pc, #136]	; (8004814 <Vector68+0x104>)
 800478c:	6993      	ldr	r3, [r2, #24]
 800478e:	2b00      	cmp	r3, #0
 8004790:	d001      	beq.n	8004796 <Vector68+0x86>
      dma.streams[idx].func(dma.streams[idx].param, flags);
 8004792:	69d0      	ldr	r0, [r2, #28]
 8004794:	4798      	blx	r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004796:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004798:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800479a:	2b00      	cmp	r3, #0
 800479c:	dd02      	ble.n	80047a4 <Vector68+0x94>
 800479e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80047a0:	2a00      	cmp	r2, #0
 80047a2:	d002      	beq.n	80047aa <Vector68+0x9a>
    chSysHalt("SV#9");
 80047a4:	481d      	ldr	r0, [pc, #116]	; (800481c <Vector68+0x10c>)
 80047a6:	f7fe f8e3 	bl	8002970 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 80047aa:	3b01      	subs	r3, #1
 80047ac:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80047ae:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 80047b0:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 80047b2:	079b      	lsls	r3, r3, #30
 80047b4:	d40d      	bmi.n	80047d2 <Vector68+0xc2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80047b6:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80047b8:	2007      	movs	r0, #7
 80047ba:	2203      	movs	r2, #3
 80047bc:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80047be:	780b      	ldrb	r3, [r1, #0]
 80047c0:	4383      	bics	r3, r0
 80047c2:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 80047c4:	4003      	ands	r3, r0
 80047c6:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80047c8:	4b0e      	ldr	r3, [pc, #56]	; (8004804 <Vector68+0xf4>)
 80047ca:	608b      	str	r3, [r1, #8]
    trace_next();
 80047cc:	f7fe f8b8 	bl	8002940 <trace_next.lto_priv.49>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80047d0:	b662      	cpsie	i
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 80047d2:	350f      	adds	r5, #15
 80047d4:	d010      	beq.n	80047f8 <Vector68+0xe8>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80047d6:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80047d8:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80047dc:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80047de:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80047e2:	2280      	movs	r2, #128	; 0x80
 80047e4:	0452      	lsls	r2, r2, #17
 80047e6:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80047e8:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80047ea:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80047ec:	6889      	ldr	r1, [r1, #8]
 80047ee:	6892      	ldr	r2, [r2, #8]
 80047f0:	4291      	cmp	r1, r2
 80047f2:	d802      	bhi.n	80047fa <Vector68+0xea>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80047f4:	4a0a      	ldr	r2, [pc, #40]	; (8004820 <Vector68+0x110>)
 80047f6:	619a      	str	r2, [r3, #24]

  /* Check on channel 3.*/
  dmaServeInterrupt(STM32_DMA1_STREAM3);

  OSAL_IRQ_EPILOGUE();
}
 80047f8:	bd38      	pop	{r3, r4, r5, pc}

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80047fa:	4a0a      	ldr	r2, [pc, #40]	; (8004824 <Vector68+0x114>)
 80047fc:	619a      	str	r2, [r3, #24]
 80047fe:	e7fb      	b.n	80047f8 <Vector68+0xe8>
 8004800:	20000700 	.word	0x20000700
 8004804:	08005a9c 	.word	0x08005a9c
 8004808:	080059c8 	.word	0x080059c8
 800480c:	40020000 	.word	0x40020000
 8004810:	4002001c 	.word	0x4002001c
 8004814:	20000424 	.word	0x20000424
 8004818:	40020030 	.word	0x40020030
 800481c:	080059d0 	.word	0x080059d0
 8004820:	080001d4 	.word	0x080001d4
 8004824:	080001c9 	.word	0x080001c9
	...

08004830 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8004830:	b570      	push	{r4, r5, r6, lr}
 8004832:	4b10      	ldr	r3, [pc, #64]	; (8004874 <nvicEnableVector+0x44>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8004834:	2403      	movs	r4, #3
 8004836:	469c      	mov	ip, r3
 8004838:	23ff      	movs	r3, #255	; 0xff
 800483a:	26c0      	movs	r6, #192	; 0xc0
 800483c:	4004      	ands	r4, r0
 800483e:	00e4      	lsls	r4, r4, #3
 8004840:	40a3      	lsls	r3, r4
 8004842:	0882      	lsrs	r2, r0, #2
 8004844:	0092      	lsls	r2, r2, #2
 8004846:	4462      	add	r2, ip
 8004848:	00b6      	lsls	r6, r6, #2
 800484a:	5995      	ldr	r5, [r2, r6]
 800484c:	439d      	bics	r5, r3
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 800484e:	018b      	lsls	r3, r1, #6
 8004850:	40a3      	lsls	r3, r4
 8004852:	1c19      	adds	r1, r3, #0
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8004854:	231f      	movs	r3, #31
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8004856:	4329      	orrs	r1, r5
 8004858:	5191      	str	r1, [r2, r6]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800485a:	2201      	movs	r2, #1
 800485c:	4003      	ands	r3, r0
 800485e:	409a      	lsls	r2, r3
 8004860:	1c13      	adds	r3, r2, #0
 8004862:	22c0      	movs	r2, #192	; 0xc0
 8004864:	0940      	lsrs	r0, r0, #5
 8004866:	0080      	lsls	r0, r0, #2
 8004868:	4460      	add	r0, ip
 800486a:	0052      	lsls	r2, r2, #1
 800486c:	5083      	str	r3, [r0, r2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800486e:	6003      	str	r3, [r0, #0]
}
 8004870:	bd70      	pop	{r4, r5, r6, pc}
 8004872:	46c0      	nop			; (mov r8, r8)
 8004874:	e000e100 	.word	0xe000e100
	...

08004880 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8004880:	b570      	push	{r4, r5, r6, lr}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8004882:	4d11      	ldr	r5, [pc, #68]	; (80048c8 <__init_ram_areas+0x48>)
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8004884:	1c2e      	adds	r6, r5, #0
 8004886:	3680      	adds	r6, #128	; 0x80
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;
 8004888:	6868      	ldr	r0, [r5, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800488a:	68ac      	ldr	r4, [r5, #8]
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 800488c:	682a      	ldr	r2, [r5, #0]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800488e:	42a0      	cmp	r0, r4
 8004890:	d20a      	bcs.n	80048a8 <__init_ram_areas+0x28>
 8004892:	1c03      	adds	r3, r0, #0
      *p = *tp;
 8004894:	ca02      	ldmia	r2!, {r1}
 8004896:	c302      	stmia	r3!, {r1}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8004898:	42a3      	cmp	r3, r4
 800489a:	d3fb      	bcc.n	8004894 <__init_ram_areas+0x14>
 800489c:	43c3      	mvns	r3, r0
 800489e:	191c      	adds	r4, r3, r4
 80048a0:	08a4      	lsrs	r4, r4, #2
 80048a2:	3401      	adds	r4, #1
 80048a4:	00a4      	lsls	r4, r4, #2
 80048a6:	1900      	adds	r0, r0, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80048a8:	68eb      	ldr	r3, [r5, #12]
 80048aa:	4298      	cmp	r0, r3
 80048ac:	d207      	bcs.n	80048be <__init_ram_areas+0x3e>
      *p = 0;
 80048ae:	43c2      	mvns	r2, r0
 80048b0:	18d2      	adds	r2, r2, r3
 80048b2:	0892      	lsrs	r2, r2, #2
 80048b4:	3201      	adds	r2, #1
 80048b6:	0092      	lsls	r2, r2, #2
 80048b8:	2100      	movs	r1, #0
 80048ba:	f000 fe6d 	bl	8005598 <memset>
      p++;
    }
    rap++;
 80048be:	3510      	adds	r5, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80048c0:	42b5      	cmp	r5, r6
 80048c2:	d3e1      	bcc.n	8004888 <__init_ram_areas+0x8>
#endif
}
 80048c4:	bd70      	pop	{r4, r5, r6, pc}
 80048c6:	46c0      	nop			; (mov r8, r8)
 80048c8:	08005a1c 	.word	0x08005a1c
 80048cc:	00000000 	.word	0x00000000

080048d0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80048d0:	e7fe      	b.n	80048d0 <__default_exit>
 80048d2:	46c0      	nop			; (mov r8, r8)
	...

080048e0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80048e0:	4770      	bx	lr
 80048e2:	46c0      	nop			; (mov r8, r8)
	...

080048f0 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 80048f0:	4770      	bx	lr
 80048f2:	46c0      	nop			; (mov r8, r8)
	...

08004900 <i2cMasterTransmitTimeout.constprop.30>:
 *                      be retrieved using @p i2cGetErrors().
 * @retval MSG_TIMEOUT  if a timeout occurred before operation end.
 *
 * @api
 */
msg_t i2cMasterTransmitTimeout(I2CDriver *i2cp,
 8004900:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004902:	4657      	mov	r7, sl
 8004904:	464e      	mov	r6, r9
 8004906:	4645      	mov	r5, r8
 8004908:	b4e0      	push	{r5, r6, r7}
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               sysinterval_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) &&
 800490a:	2900      	cmp	r1, #0
 800490c:	d009      	beq.n	8004922 <i2cMasterTransmitTimeout.constprop.30+0x22>
 800490e:	2800      	cmp	r0, #0
 8004910:	d007      	beq.n	8004922 <i2cMasterTransmitTimeout.constprop.30+0x22>
 8004912:	2b00      	cmp	r3, #0
 8004914:	d001      	beq.n	800491a <i2cMasterTransmitTimeout.constprop.30+0x1a>
 8004916:	2a00      	cmp	r2, #0
 8004918:	d003      	beq.n	8004922 <i2cMasterTransmitTimeout.constprop.30+0x22>
               (txbytes > 0U) && (txbuf != NULL) &&
               ((rxbytes == 0U) || ((rxbytes > 0U) && (rxbuf != NULL))) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 800491a:	4c6b      	ldr	r4, [pc, #428]	; (8004ac8 <i2cMasterTransmitTimeout.constprop.30+0x1c8>)
 800491c:	7825      	ldrb	r5, [r4, #0]
 800491e:	2d02      	cmp	r5, #2
 8004920:	d002      	beq.n	8004928 <i2cMasterTransmitTimeout.constprop.30+0x28>
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               sysinterval_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) &&
 8004922:	486a      	ldr	r0, [pc, #424]	; (8004acc <i2cMasterTransmitTimeout.constprop.30+0x1cc>)
 8004924:	f7fe f824 	bl	8002970 <chSysHalt>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004928:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800492a:	4d69      	ldr	r5, [pc, #420]	; (8004ad0 <i2cMasterTransmitTimeout.constprop.30+0x1d0>)
 800492c:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 800492e:	2e00      	cmp	r6, #0
 8004930:	d102      	bne.n	8004938 <i2cMasterTransmitTimeout.constprop.30+0x38>
 8004932:	6b6f      	ldr	r7, [r5, #52]	; 0x34
 8004934:	2f00      	cmp	r7, #0
 8004936:	d002      	beq.n	800493e <i2cMasterTransmitTimeout.constprop.30+0x3e>
    chSysHalt("SV#4");
 8004938:	4866      	ldr	r0, [pc, #408]	; (8004ad4 <i2cMasterTransmitTimeout.constprop.30+0x1d4>)
 800493a:	f7fe f819 	bl	8002970 <chSysHalt>

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 800493e:	2603      	movs	r6, #3
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8004940:	60a7      	str	r7, [r4, #8]
  i2cp->state = I2C_ACTIVE_TX;
 8004942:	7026      	strb	r6, [r4, #0]
 8004944:	682f      	ldr	r7, [r5, #0]
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      sysinterval_t timeout) {
  msg_t msg;
  I2C_TypeDef *dp = i2cp->i2c;
 8004946:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8004948:	46b2      	mov	sl, r6
 800494a:	42af      	cmp	r7, r5
 800494c:	d004      	beq.n	8004958 <i2cMasterTransmitTimeout.constprop.30+0x58>
 800494e:	69ae      	ldr	r6, [r5, #24]
 8004950:	68bf      	ldr	r7, [r7, #8]
 8004952:	68b6      	ldr	r6, [r6, #8]
 8004954:	42be      	cmp	r6, r7
 8004956:	d35f      	bcc.n	8004a18 <i2cMasterTransmitTimeout.constprop.30+0x118>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004958:	b662      	cpsie	i
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

#if STM32_I2C_USE_DMA == TRUE
  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 800495a:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800495c:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800495e:	687f      	ldr	r7, [r7, #4]
 8004960:	603e      	str	r6, [r7, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 8004962:	60f8      	str	r0, [r7, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8004964:	6079      	str	r1, [r7, #4]

  /* RX DMA setup, note, rxbytes can be zero but we write the value anyway.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8004966:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8004968:	6a20      	ldr	r0, [r4, #32]
 800496a:	6849      	ldr	r1, [r1, #4]
 800496c:	6008      	str	r0, [r1, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 800496e:	60ca      	str	r2, [r1, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8004970:	604b      	str	r3, [r1, #4]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8004972:	4b59      	ldr	r3, [pc, #356]	; (8004ad8 <i2cMasterTransmitTimeout.constprop.30+0x1d8>)
 8004974:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004976:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004978:	6b29      	ldr	r1, [r5, #48]	; 0x30
 800497a:	2900      	cmp	r1, #0
 800497c:	d1dc      	bne.n	8004938 <i2cMasterTransmitTimeout.constprop.30+0x38>
 800497e:	6b69      	ldr	r1, [r5, #52]	; 0x34
 8004980:	2900      	cmp	r1, #0
 8004982:	d1d9      	bne.n	8004938 <i2cMasterTransmitTimeout.constprop.30+0x38>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8004984:	3101      	adds	r1, #1
 8004986:	6369      	str	r1, [r5, #52]	; 0x34
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 8004988:	4651      	mov	r1, sl
 800498a:	2780      	movs	r7, #128	; 0x80
 800498c:	6989      	ldr	r1, [r1, #24]
 800498e:	023f      	lsls	r7, r7, #8
 8004990:	4239      	tst	r1, r7
 8004992:	d044      	beq.n	8004a1e <i2cMasterTransmitTimeout.constprop.30+0x11e>
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end)) {
 8004994:	20f4      	movs	r0, #244	; 0xf4
 8004996:	b291      	uxth	r1, r2
 8004998:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800499a:	30ff      	adds	r0, #255	; 0xff
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 800499c:	1a52      	subs	r2, r2, r1
 800499e:	b292      	uxth	r2, r2
 80049a0:	4282      	cmp	r2, r0
 80049a2:	d820      	bhi.n	80049e6 <i2cMasterTransmitTimeout.constprop.30+0xe6>
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80049a4:	2200      	movs	r2, #0
 80049a6:	4694      	mov	ip, r2
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80049a8:	3201      	adds	r2, #1
 80049aa:	4690      	mov	r8, r2
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80049ac:	4662      	mov	r2, ip
 80049ae:	636a      	str	r2, [r5, #52]	; 0x34
 80049b0:	682a      	ldr	r2, [r5, #0]
 80049b2:	42aa      	cmp	r2, r5
 80049b4:	d004      	beq.n	80049c0 <i2cMasterTransmitTimeout.constprop.30+0xc0>
 80049b6:	69ae      	ldr	r6, [r5, #24]
 80049b8:	6892      	ldr	r2, [r2, #8]
 80049ba:	68b6      	ldr	r6, [r6, #8]
 80049bc:	4296      	cmp	r6, r2
 80049be:	d32b      	bcc.n	8004a18 <i2cMasterTransmitTimeout.constprop.30+0x118>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80049c0:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80049c2:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80049c4:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80049c6:	2a00      	cmp	r2, #0
 80049c8:	d1b6      	bne.n	8004938 <i2cMasterTransmitTimeout.constprop.30+0x38>
 80049ca:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80049cc:	2a00      	cmp	r2, #0
 80049ce:	d1b3      	bne.n	8004938 <i2cMasterTransmitTimeout.constprop.30+0x38>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80049d0:	4642      	mov	r2, r8
 80049d2:	636a      	str	r2, [r5, #52]	; 0x34
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 80049d4:	4652      	mov	r2, sl
 80049d6:	6992      	ldr	r2, [r2, #24]
 80049d8:	423a      	tst	r2, r7
 80049da:	d020      	beq.n	8004a1e <i2cMasterTransmitTimeout.constprop.30+0x11e>
 80049dc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80049de:	1a52      	subs	r2, r2, r1
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end)) {
 80049e0:	b292      	uxth	r2, r2
 80049e2:	4282      	cmp	r2, r0
 80049e4:	d9e2      	bls.n	80049ac <i2cMasterTransmitTimeout.constprop.30+0xac>
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 80049e6:	2305      	movs	r3, #5
 80049e8:	2001      	movs	r0, #1
 80049ea:	7023      	strb	r3, [r4, #0]
 80049ec:	4240      	negs	r0, r0
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80049ee:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80049f0:	2b00      	cmp	r3, #0
 80049f2:	d146      	bne.n	8004a82 <i2cMasterTransmitTimeout.constprop.30+0x182>
 80049f4:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80049f6:	2a00      	cmp	r2, #0
 80049f8:	dd43      	ble.n	8004a82 <i2cMasterTransmitTimeout.constprop.30+0x182>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80049fa:	636b      	str	r3, [r5, #52]	; 0x34
 80049fc:	682b      	ldr	r3, [r5, #0]
 80049fe:	42ab      	cmp	r3, r5
 8004a00:	d004      	beq.n	8004a0c <i2cMasterTransmitTimeout.constprop.30+0x10c>
 8004a02:	69aa      	ldr	r2, [r5, #24]
 8004a04:	689b      	ldr	r3, [r3, #8]
 8004a06:	6892      	ldr	r2, [r2, #8]
 8004a08:	429a      	cmp	r2, r3
 8004a0a:	d352      	bcc.n	8004ab2 <i2cMasterTransmitTimeout.constprop.30+0x1b2>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004a0c:	b662      	cpsie	i
  else {
    i2cp->state = I2C_READY;
  }
  osalSysUnlock();
  return rdymsg;
}
 8004a0e:	bc1c      	pop	{r2, r3, r4}
 8004a10:	4690      	mov	r8, r2
 8004a12:	4699      	mov	r9, r3
 8004a14:	46a2      	mov	sl, r4
 8004a16:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8004a18:	4830      	ldr	r0, [pc, #192]	; (8004adc <i2cMasterTransmitTimeout.constprop.30+0x1dc>)
 8004a1a:	f7fd ffa9 	bl	8002970 <chSysHalt>
 */
static void i2c_lld_set_address(I2CDriver *i2cp, i2caddr_t addr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 8004a1e:	6863      	ldr	r3, [r4, #4]
 8004a20:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8004a22:	6898      	ldr	r0, [r3, #8]
 8004a24:	0503      	lsls	r3, r0, #20
 8004a26:	d441      	bmi.n	8004aac <i2cMasterTransmitTimeout.constprop.30+0x1ac>
    dp->CR2 = (uint32_t)addr << 1U;
 8004a28:	2310      	movs	r3, #16
 8004a2a:	6053      	str	r3, [r2, #4]
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 8004a2c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8004a2e:	685f      	ldr	r7, [r3, #4]
 8004a30:	687b      	ldr	r3, [r7, #4]
  if (n > 255U) {
 8004a32:	2bff      	cmp	r3, #255	; 0xff
 8004a34:	d835      	bhi.n	8004aa2 <i2cMasterTransmitTimeout.constprop.30+0x1a2>
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 8004a36:	2100      	movs	r1, #0
 8004a38:	4689      	mov	r9, r1
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8004a3a:	6856      	ldr	r6, [r2, #4]
            (n << 16U) | reload;
 8004a3c:	041b      	lsls	r3, r3, #16
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8004a3e:	46b0      	mov	r8, r6
 8004a40:	4e27      	ldr	r6, [pc, #156]	; (8004ae0 <i2cMasterTransmitTimeout.constprop.30+0x1e0>)
 8004a42:	46b4      	mov	ip, r6
 8004a44:	4646      	mov	r6, r8
 8004a46:	4661      	mov	r1, ip
 8004a48:	400e      	ands	r6, r1
 8004a4a:	4649      	mov	r1, r9
 8004a4c:	4330      	orrs	r0, r6
 8004a4e:	4301      	orrs	r1, r0
            (n << 16U) | reload;
 8004a50:	430b      	orrs	r3, r1
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8004a52:	6053      	str	r3, [r2, #4]
  /* Preparing the transfer.*/
  i2c_lld_setup_tx_transfer(i2cp);

#if STM32_I2C_USE_DMA == TRUE
  /* Enabling TX DMA.*/
  dmaStreamEnable(i2cp->dmatx);
 8004a54:	2201      	movs	r2, #1
 8004a56:	683b      	ldr	r3, [r7, #0]
 8004a58:	4313      	orrs	r3, r2
 8004a5a:	603b      	str	r3, [r7, #0]

  /* Transfer complete interrupt enabled.*/
  dp->CR1 |= I2C_CR1_TCIE;
 8004a5c:	4653      	mov	r3, sl
 8004a5e:	681b      	ldr	r3, [r3, #0]
 8004a60:	323f      	adds	r2, #63	; 0x3f
 8004a62:	4313      	orrs	r3, r2
 8004a64:	4652      	mov	r2, sl
 8004a66:	6013      	str	r3, [r2, #0]
  /* Transfer complete and TX interrupts enabled.*/
  dp->CR1 |= I2C_CR1_TCIE | I2C_CR1_TXIE;
#endif

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_START;
 8004a68:	6853      	ldr	r3, [r2, #4]
 8004a6a:	2280      	movs	r2, #128	; 0x80
 8004a6c:	0192      	lsls	r2, r2, #6
 8004a6e:	4313      	orrs	r3, r2
 8004a70:	4652      	mov	r2, sl
 8004a72:	6053      	str	r3, [r2, #4]
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
 8004a74:	69e2      	ldr	r2, [r4, #28]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004a76:	69ab      	ldr	r3, [r5, #24]
 8004a78:	2a00      	cmp	r2, #0
 8004a7a:	d005      	beq.n	8004a88 <i2cMasterTransmitTimeout.constprop.30+0x188>
 8004a7c:	4819      	ldr	r0, [pc, #100]	; (8004ae4 <i2cMasterTransmitTimeout.constprop.30+0x1e4>)
 8004a7e:	f7fd ff77 	bl	8002970 <chSysHalt>
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 8004a82:	4819      	ldr	r0, [pc, #100]	; (8004ae8 <i2cMasterTransmitTimeout.constprop.30+0x1e8>)
 8004a84:	f7fd ff74 	bl	8002970 <chSysHalt>
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->u.wttrp = trp;
 8004a88:	1c22      	adds	r2, r4, #0
 8004a8a:	321c      	adds	r2, #28

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8004a8c:	61e3      	str	r3, [r4, #28]
  tp->u.wttrp = trp;
 8004a8e:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8004a90:	2003      	movs	r0, #3
 8004a92:	2128      	movs	r1, #40	; 0x28
 8004a94:	f7fe fa0c 	bl	8002eb0 <chSchGoSleepTimeoutS>
  /* Waits for the operation completion or a timeout.*/
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);

  /* In case of a software timeout a STOP is sent as an extreme attempt
     to release the bus.*/
  if (msg == MSG_TIMEOUT) {
 8004a98:	1c43      	adds	r3, r0, #1
 8004a9a:	d00d      	beq.n	8004ab8 <i2cMasterTransmitTimeout.constprop.30+0x1b8>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
  }
  else {
    i2cp->state = I2C_READY;
 8004a9c:	2302      	movs	r3, #2
 8004a9e:	7023      	strb	r3, [r4, #0]
 8004aa0:	e7a5      	b.n	80049ee <i2cMasterTransmitTimeout.constprop.30+0xee>

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8004aa2:	2180      	movs	r1, #128	; 0x80
 8004aa4:	0449      	lsls	r1, r1, #17
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
    n = 255U;
 8004aa6:	23ff      	movs	r3, #255	; 0xff
    reload = I2C_CR2_RELOAD;
 8004aa8:	4689      	mov	r9, r1
 8004aaa:	e7c6      	b.n	8004a3a <i2cMasterTransmitTimeout.constprop.30+0x13a>

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
    dp->CR2 = (uint32_t)addr << 1U;
  else
    dp->CR2 = (uint32_t)addr;
 8004aac:	2308      	movs	r3, #8
 8004aae:	6053      	str	r3, [r2, #4]
 8004ab0:	e7bc      	b.n	8004a2c <i2cMasterTransmitTimeout.constprop.30+0x12c>
 8004ab2:	480e      	ldr	r0, [pc, #56]	; (8004aec <i2cMasterTransmitTimeout.constprop.30+0x1ec>)
 8004ab4:	f7fd ff5c 	bl	8002970 <chSysHalt>
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);

  /* In case of a software timeout a STOP is sent as an extreme attempt
     to release the bus.*/
  if (msg == MSG_TIMEOUT) {
    dp->CR2 |= I2C_CR2_STOP;
 8004ab8:	4653      	mov	r3, sl
 8004aba:	2280      	movs	r2, #128	; 0x80
 8004abc:	685b      	ldr	r3, [r3, #4]
 8004abe:	01d2      	lsls	r2, r2, #7
 8004ac0:	4313      	orrs	r3, r2
 8004ac2:	4652      	mov	r2, sl
 8004ac4:	6053      	str	r3, [r2, #4]
 8004ac6:	e78e      	b.n	80049e6 <i2cMasterTransmitTimeout.constprop.30+0xe6>
 8004ac8:	20000f84 	.word	0x20000f84
 8004acc:	08005ae0 	.word	0x08005ae0
 8004ad0:	20000700 	.word	0x20000700
 8004ad4:	08005808 	.word	0x08005808
 8004ad8:	40000400 	.word	0x40000400
 8004adc:	08005b18 	.word	0x08005b18
 8004ae0:	fe00ffff 	.word	0xfe00ffff
 8004ae4:	08005ac8 	.word	0x08005ac8
 8004ae8:	08005810 	.word	0x08005810
 8004aec:	08005b0c 	.word	0x08005b0c

08004af0 <chSchWakeupS.constprop.22>:
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 8004af0:	4b35      	ldr	r3, [pc, #212]	; (8004bc8 <chSchWakeupS.constprop.22+0xd8>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8004af2:	b570      	push	{r4, r5, r6, lr}
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004af4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8004af6:	1c04      	adds	r4, r0, #0
  thread_t *otp = currp;
 8004af8:	699d      	ldr	r5, [r3, #24]
 8004afa:	2a00      	cmp	r2, #0
 8004afc:	d131      	bne.n	8004b62 <chSchWakeupS.constprop.22+0x72>
 8004afe:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004b00:	2a00      	cmp	r2, #0
 8004b02:	dd2e      	ble.n	8004b62 <chSchWakeupS.constprop.22+0x72>

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004b04:	681a      	ldr	r2, [r3, #0]
 8004b06:	68a9      	ldr	r1, [r5, #8]
 8004b08:	429a      	cmp	r2, r3
 8004b0a:	d002      	beq.n	8004b12 <chSchWakeupS.constprop.22+0x22>
 8004b0c:	6892      	ldr	r2, [r2, #8]
 8004b0e:	4291      	cmp	r1, r2
 8004b10:	d32d      	bcc.n	8004b6e <chSchWakeupS.constprop.22+0x7e>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8004b12:	2000      	movs	r0, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8004b14:	68a2      	ldr	r2, [r4, #8]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8004b16:	6260      	str	r0, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8004b18:	4291      	cmp	r1, r2
 8004b1a:	d22b      	bcs.n	8004b74 <chSchWakeupS.constprop.22+0x84>
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8004b1c:	2620      	movs	r6, #32
 8004b1e:	5daa      	ldrb	r2, [r5, r6]
 8004b20:	2a00      	cmp	r2, #0
 8004b22:	d021      	beq.n	8004b68 <chSchWakeupS.constprop.22+0x78>
 8004b24:	2a0f      	cmp	r2, #15
 8004b26:	d01f      	beq.n	8004b68 <chSchWakeupS.constprop.22+0x78>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.queue;
 8004b28:	1c1a      	adds	r2, r3, #0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8004b2a:	55a8      	strb	r0, [r5, r6]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8004b2c:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio > tp->prio);
 8004b2e:	6890      	ldr	r0, [r2, #8]
 8004b30:	4281      	cmp	r1, r0
 8004b32:	d3fb      	bcc.n	8004b2c <chSchWakeupS.constprop.22+0x3c>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8004b34:	6851      	ldr	r1, [r2, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8004b36:	602a      	str	r2, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8004b38:	6069      	str	r1, [r5, #4]
  tp->queue.prev->queue.next = tp;
 8004b3a:	600d      	str	r5, [r1, #0]
  cp->queue.prev             = tp;
 8004b3c:	6055      	str	r5, [r2, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 8004b3e:	2120      	movs	r1, #32
 8004b40:	2201      	movs	r2, #1
 8004b42:	5462      	strb	r2, [r4, r1]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8004b44:	8f18      	ldrh	r0, [r3, #56]	; 0x38
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 8004b46:	619c      	str	r4, [r3, #24]
 8004b48:	4210      	tst	r0, r2
 8004b4a:	d024      	beq.n	8004b96 <chSchWakeupS.constprop.22+0xa6>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004b4c:	f3ef 8309 	mrs	r3, PSP
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8004b50:	69ea      	ldr	r2, [r5, #28]
 8004b52:	3b24      	subs	r3, #36	; 0x24
 8004b54:	429a      	cmp	r2, r3
 8004b56:	d833      	bhi.n	8004bc0 <chSchWakeupS.constprop.22+0xd0>
 8004b58:	1c20      	adds	r0, r4, #0
 8004b5a:	1c29      	adds	r1, r5, #0
 8004b5c:	f7fb fb1c 	bl	8000198 <_port_switch>
  }
}
 8004b60:	bd70      	pop	{r4, r5, r6, pc}
    chSysHalt("SV#11");
 8004b62:	481a      	ldr	r0, [pc, #104]	; (8004bcc <chSchWakeupS.constprop.22+0xdc>)
 8004b64:	f7fd ff04 	bl	8002970 <chSysHalt>
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8004b68:	4819      	ldr	r0, [pc, #100]	; (8004bd0 <chSchWakeupS.constprop.22+0xe0>)
 8004b6a:	f7fd ff01 	bl	8002970 <chSysHalt>
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8004b6e:	4819      	ldr	r0, [pc, #100]	; (8004bd4 <chSchWakeupS.constprop.22+0xe4>)
 8004b70:	f7fd fefe 	bl	8002970 <chSysHalt>
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8004b74:	2520      	movs	r5, #32
 8004b76:	5d61      	ldrb	r1, [r4, r5]
 8004b78:	2900      	cmp	r1, #0
 8004b7a:	d01e      	beq.n	8004bba <chSchWakeupS.constprop.22+0xca>
 8004b7c:	290f      	cmp	r1, #15
 8004b7e:	d01c      	beq.n	8004bba <chSchWakeupS.constprop.22+0xca>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8004b80:	5560      	strb	r0, [r4, r5]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8004b82:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8004b84:	6899      	ldr	r1, [r3, #8]
 8004b86:	4291      	cmp	r1, r2
 8004b88:	d2fb      	bcs.n	8004b82 <chSchWakeupS.constprop.22+0x92>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8004b8a:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8004b8c:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8004b8e:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8004b90:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8004b92:	605c      	str	r4, [r3, #4]
 8004b94:	e7e4      	b.n	8004b60 <chSchWakeupS.constprop.22+0x70>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8004b96:	2607      	movs	r6, #7
 8004b98:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8004b9a:	7818      	ldrb	r0, [r3, #0]
 8004b9c:	43b0      	bics	r0, r6
 8004b9e:	4302      	orrs	r2, r0
 8004ba0:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8004ba2:	5c69      	ldrb	r1, [r5, r1]
 8004ba4:	b2d2      	uxtb	r2, r2
 8004ba6:	00c9      	lsls	r1, r1, #3
 8004ba8:	4032      	ands	r2, r6
 8004baa:	430a      	orrs	r2, r1
 8004bac:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8004bae:	609c      	str	r4, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8004bb0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8004bb2:	60da      	str	r2, [r3, #12]
    trace_next();
 8004bb4:	f7fd fec4 	bl	8002940 <trace_next.lto_priv.49>
 8004bb8:	e7c8      	b.n	8004b4c <chSchWakeupS.constprop.22+0x5c>
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8004bba:	4807      	ldr	r0, [pc, #28]	; (8004bd8 <chSchWakeupS.constprop.22+0xe8>)
 8004bbc:	f7fd fed8 	bl	8002970 <chSysHalt>
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8004bc0:	4806      	ldr	r0, [pc, #24]	; (8004bdc <chSchWakeupS.constprop.22+0xec>)
 8004bc2:	f7fd fed5 	bl	8002970 <chSysHalt>
 8004bc6:	46c0      	nop			; (mov r8, r8)
 8004bc8:	20000700 	.word	0x20000700
 8004bcc:	080058f4 	.word	0x080058f4
 8004bd0:	08005aa8 	.word	0x08005aa8
 8004bd4:	08005afc 	.word	0x08005afc
 8004bd8:	08005abc 	.word	0x08005abc
 8004bdc:	080058e4 	.word	0x080058e4

08004be0 <I2CReadRegisterWordWithCRC.constprop.8>:
  else
    *data = rx_buffer[0];
  return msg;
}

msg_t I2CReadRegisterWordWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint16_t *data) {
 8004be0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8004be2:	4645      	mov	r5, r8
 8004be4:	4657      	mov	r7, sl
 8004be6:	464e      	mov	r6, r9
 8004be8:	b4e0      	push	{r5, r6, r7}
 8004bea:	b086      	sub	sp, #24
  msg_t msg;
  i2cflags_t err;
  uint8_t tx_buffer[1] = {reg_address};
 8004bec:	ab02      	add	r3, sp, #8
  else
    *data = rx_buffer[0];
  return msg;
}

msg_t I2CReadRegisterWordWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint16_t *data) {
 8004bee:	1c0d      	adds	r5, r1, #0
  msg_t msg;
  i2cflags_t err;
  uint8_t tx_buffer[1] = {reg_address};
 8004bf0:	7018      	strb	r0, [r3, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8004bf2:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8004bf4:	4cd2      	ldr	r4, [pc, #840]	; (8004f40 <I2CReadRegisterWordWithCRC.constprop.8+0x360>)
 8004bf6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004bf8:	2b00      	cmp	r3, #0
 8004bfa:	d102      	bne.n	8004c02 <I2CReadRegisterWordWithCRC.constprop.8+0x22>
 8004bfc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8004bfe:	2b00      	cmp	r3, #0
 8004c00:	d002      	beq.n	8004c08 <I2CReadRegisterWordWithCRC.constprop.8+0x28>
    chSysHalt("SV#4");
 8004c02:	48d0      	ldr	r0, [pc, #832]	; (8004f44 <I2CReadRegisterWordWithCRC.constprop.8+0x364>)
 8004c04:	f7fd feb4 	bl	8002970 <chSysHalt>
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8004c08:	4fcf      	ldr	r7, [pc, #828]	; (8004f48 <I2CReadRegisterWordWithCRC.constprop.8+0x368>)
  }
  _dbg_enter_lock();
 8004c0a:	2301      	movs	r3, #1
 8004c0c:	1c38      	adds	r0, r7, #0
 8004c0e:	300c      	adds	r0, #12
 8004c10:	6363      	str	r3, [r4, #52]	; 0x34
 8004c12:	f7fe fdbd 	bl	8003790 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8004c16:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8004c18:	2b00      	cmp	r3, #0
 8004c1a:	d000      	beq.n	8004c1e <I2CReadRegisterWordWithCRC.constprop.8+0x3e>
 8004c1c:	e182      	b.n	8004f24 <I2CReadRegisterWordWithCRC.constprop.8+0x344>
 8004c1e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8004c20:	2a00      	cmp	r2, #0
 8004c22:	dc00      	bgt.n	8004c26 <I2CReadRegisterWordWithCRC.constprop.8+0x46>
 8004c24:	e17e      	b.n	8004f24 <I2CReadRegisterWordWithCRC.constprop.8+0x344>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8004c26:	6363      	str	r3, [r4, #52]	; 0x34
 8004c28:	6823      	ldr	r3, [r4, #0]
 8004c2a:	42a3      	cmp	r3, r4
 8004c2c:	d005      	beq.n	8004c3a <I2CReadRegisterWordWithCRC.constprop.8+0x5a>
 8004c2e:	69a2      	ldr	r2, [r4, #24]
 8004c30:	689b      	ldr	r3, [r3, #8]
 8004c32:	6892      	ldr	r2, [r2, #8]
 8004c34:	429a      	cmp	r2, r3
 8004c36:	d200      	bcs.n	8004c3a <I2CReadRegisterWordWithCRC.constprop.8+0x5a>
 8004c38:	e1b0      	b.n	8004f9c <I2CReadRegisterWordWithCRC.constprop.8+0x3bc>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8004c3a:	b662      	cpsie	i
  volatile uint8_t CRCInput[2];
  volatile uint8_t crc[2];

  //read data from i2c bus
  i2cAcquireBus(i2cp);
  msg = i2cMasterTransmitTimeout(&I2CD1, addr_bq76920, tx_buffer, 1,
 8004c3c:	ac05      	add	r4, sp, #20
 8004c3e:	1c22      	adds	r2, r4, #0
 8004c40:	2304      	movs	r3, #4
 8004c42:	2101      	movs	r1, #1
 8004c44:	a802      	add	r0, sp, #8
 8004c46:	f7ff fe5b 	bl	8004900 <i2cMasterTransmitTimeout.constprop.30>
 8004c4a:	4681      	mov	r9, r0
 8004c4c:	1c38      	adds	r0, r7, #0
 8004c4e:	300c      	adds	r0, #12
 8004c50:	f7fe fcde 	bl	8003610 <chMtxUnlock>
  i2cReleaseBus(i2cp);
  if (msg != MSG_OK)
    err = i2cGetErrors(i2cp);

  //CRC check for first byte
  CRCInput[0] = (addr_bq76920 << 1) + 1;
 8004c54:	2311      	movs	r3, #17
 8004c56:	a803      	add	r0, sp, #12
 8004c58:	7003      	strb	r3, [r0, #0]
 8004c5a:	7802      	ldrb	r2, [r0, #0]
  CRCInput[1] = rx_buffer[0];
 8004c5c:	7823      	ldrb	r3, [r4, #0]
 8004c5e:	09d7      	lsrs	r7, r2, #7
 8004c60:	469a      	mov	sl, r3
 8004c62:	7043      	strb	r3, [r0, #1]
 8004c64:	2300      	movs	r3, #0
 8004c66:	2f00      	cmp	r7, #0
 8004c68:	d000      	beq.n	8004c6c <I2CReadRegisterWordWithCRC.constprop.8+0x8c>
 8004c6a:	e195      	b.n	8004f98 <I2CReadRegisterWordWithCRC.constprop.8+0x3b8>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004c6c:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004c6e:	005b      	lsls	r3, r3, #1
 8004c70:	b2db      	uxtb	r3, r3
 8004c72:	b2de      	uxtb	r6, r3
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004c74:	4077      	eors	r7, r6
 8004c76:	0651      	lsls	r1, r2, #25
 8004c78:	d500      	bpl.n	8004c7c <I2CReadRegisterWordWithCRC.constprop.8+0x9c>
 8004c7a:	e18b      	b.n	8004f94 <I2CReadRegisterWordWithCRC.constprop.8+0x3b4>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004c7c:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004c7e:	005f      	lsls	r7, r3, #1
 8004c80:	b2ff      	uxtb	r7, r7
 8004c82:	b25b      	sxtb	r3, r3
				crc ^= key;
 8004c84:	407e      	eors	r6, r7
 8004c86:	2b00      	cmp	r3, #0
 8004c88:	da00      	bge.n	8004c8c <I2CReadRegisterWordWithCRC.constprop.8+0xac>
 8004c8a:	e18c      	b.n	8004fa6 <I2CReadRegisterWordWithCRC.constprop.8+0x3c6>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004c8c:	2307      	movs	r3, #7
 8004c8e:	b2fe      	uxtb	r6, r7
 8004c90:	4073      	eors	r3, r6
 8004c92:	0691      	lsls	r1, r2, #26
 8004c94:	d500      	bpl.n	8004c98 <I2CReadRegisterWordWithCRC.constprop.8+0xb8>
 8004c96:	e17b      	b.n	8004f90 <I2CReadRegisterWordWithCRC.constprop.8+0x3b0>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004c98:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004c9a:	007b      	lsls	r3, r7, #1
 8004c9c:	b2db      	uxtb	r3, r3
 8004c9e:	b27f      	sxtb	r7, r7
				crc ^= key;
 8004ca0:	405e      	eors	r6, r3
 8004ca2:	2f00      	cmp	r7, #0
 8004ca4:	da00      	bge.n	8004ca8 <I2CReadRegisterWordWithCRC.constprop.8+0xc8>
 8004ca6:	e17c      	b.n	8004fa2 <I2CReadRegisterWordWithCRC.constprop.8+0x3c2>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004ca8:	2707      	movs	r7, #7
 8004caa:	b2de      	uxtb	r6, r3
 8004cac:	4077      	eors	r7, r6
 8004cae:	06d1      	lsls	r1, r2, #27
 8004cb0:	d500      	bpl.n	8004cb4 <I2CReadRegisterWordWithCRC.constprop.8+0xd4>
 8004cb2:	e16b      	b.n	8004f8c <I2CReadRegisterWordWithCRC.constprop.8+0x3ac>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004cb4:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004cb6:	005f      	lsls	r7, r3, #1
 8004cb8:	b2ff      	uxtb	r7, r7
 8004cba:	b25b      	sxtb	r3, r3
				crc ^= key;
 8004cbc:	407e      	eors	r6, r7
 8004cbe:	2b00      	cmp	r3, #0
 8004cc0:	da00      	bge.n	8004cc4 <I2CReadRegisterWordWithCRC.constprop.8+0xe4>
 8004cc2:	e174      	b.n	8004fae <I2CReadRegisterWordWithCRC.constprop.8+0x3ce>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004cc4:	2307      	movs	r3, #7
 8004cc6:	b2fe      	uxtb	r6, r7
 8004cc8:	4073      	eors	r3, r6
 8004cca:	0711      	lsls	r1, r2, #28
 8004ccc:	d500      	bpl.n	8004cd0 <I2CReadRegisterWordWithCRC.constprop.8+0xf0>
 8004cce:	e15b      	b.n	8004f88 <I2CReadRegisterWordWithCRC.constprop.8+0x3a8>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004cd0:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004cd2:	007b      	lsls	r3, r7, #1
 8004cd4:	b2db      	uxtb	r3, r3
 8004cd6:	b27f      	sxtb	r7, r7
				crc ^= key;
 8004cd8:	405e      	eors	r6, r3
 8004cda:	2f00      	cmp	r7, #0
 8004cdc:	da00      	bge.n	8004ce0 <I2CReadRegisterWordWithCRC.constprop.8+0x100>
 8004cde:	e164      	b.n	8004faa <I2CReadRegisterWordWithCRC.constprop.8+0x3ca>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004ce0:	2707      	movs	r7, #7
 8004ce2:	b2de      	uxtb	r6, r3
 8004ce4:	4077      	eors	r7, r6
 8004ce6:	0751      	lsls	r1, r2, #29
 8004ce8:	d500      	bpl.n	8004cec <I2CReadRegisterWordWithCRC.constprop.8+0x10c>
 8004cea:	e14b      	b.n	8004f84 <I2CReadRegisterWordWithCRC.constprop.8+0x3a4>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004cec:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004cee:	005f      	lsls	r7, r3, #1
 8004cf0:	b2ff      	uxtb	r7, r7
 8004cf2:	b25b      	sxtb	r3, r3
				crc ^= key;
 8004cf4:	407e      	eors	r6, r7
 8004cf6:	2b00      	cmp	r3, #0
 8004cf8:	da00      	bge.n	8004cfc <I2CReadRegisterWordWithCRC.constprop.8+0x11c>
 8004cfa:	e174      	b.n	8004fe6 <I2CReadRegisterWordWithCRC.constprop.8+0x406>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004cfc:	2307      	movs	r3, #7
 8004cfe:	b2fe      	uxtb	r6, r7
 8004d00:	4073      	eors	r3, r6
 8004d02:	0791      	lsls	r1, r2, #30
 8004d04:	d500      	bpl.n	8004d08 <I2CReadRegisterWordWithCRC.constprop.8+0x128>
 8004d06:	e13b      	b.n	8004f80 <I2CReadRegisterWordWithCRC.constprop.8+0x3a0>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004d08:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004d0a:	007b      	lsls	r3, r7, #1
 8004d0c:	b2db      	uxtb	r3, r3
 8004d0e:	b27f      	sxtb	r7, r7
				crc ^= key;
 8004d10:	405e      	eors	r6, r3
 8004d12:	2f00      	cmp	r7, #0
 8004d14:	da00      	bge.n	8004d18 <I2CReadRegisterWordWithCRC.constprop.8+0x138>
 8004d16:	e164      	b.n	8004fe2 <I2CReadRegisterWordWithCRC.constprop.8+0x402>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004d18:	2707      	movs	r7, #7
 8004d1a:	b2de      	uxtb	r6, r3
 8004d1c:	4077      	eors	r7, r6
 8004d1e:	07d2      	lsls	r2, r2, #31
 8004d20:	d500      	bpl.n	8004d24 <I2CReadRegisterWordWithCRC.constprop.8+0x144>
 8004d22:	e12b      	b.n	8004f7c <I2CReadRegisterWordWithCRC.constprop.8+0x39c>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004d24:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004d26:	005f      	lsls	r7, r3, #1
 8004d28:	b2ff      	uxtb	r7, r7
 8004d2a:	b25b      	sxtb	r3, r3
 8004d2c:	7842      	ldrb	r2, [r0, #1]
				crc ^= key;
 8004d2e:	407e      	eors	r6, r7
 8004d30:	2b00      	cmp	r3, #0
 8004d32:	da00      	bge.n	8004d36 <I2CReadRegisterWordWithCRC.constprop.8+0x156>
 8004d34:	e15b      	b.n	8004fee <I2CReadRegisterWordWithCRC.constprop.8+0x40e>
 8004d36:	1c3b      	adds	r3, r7, #0
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004d38:	2707      	movs	r7, #7
 8004d3a:	b2de      	uxtb	r6, r3
 8004d3c:	407e      	eors	r6, r7
 8004d3e:	09d7      	lsrs	r7, r2, #7
 8004d40:	d000      	beq.n	8004d44 <I2CReadRegisterWordWithCRC.constprop.8+0x164>
 8004d42:	e119      	b.n	8004f78 <I2CReadRegisterWordWithCRC.constprop.8+0x398>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004d44:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004d46:	005f      	lsls	r7, r3, #1
 8004d48:	b2ff      	uxtb	r7, r7
 8004d4a:	b25b      	sxtb	r3, r3
				crc ^= key;
 8004d4c:	407e      	eors	r6, r7
 8004d4e:	2b00      	cmp	r3, #0
 8004d50:	da00      	bge.n	8004d54 <I2CReadRegisterWordWithCRC.constprop.8+0x174>
 8004d52:	e14a      	b.n	8004fea <I2CReadRegisterWordWithCRC.constprop.8+0x40a>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004d54:	2307      	movs	r3, #7
 8004d56:	b2fe      	uxtb	r6, r7
 8004d58:	4073      	eors	r3, r6
 8004d5a:	0651      	lsls	r1, r2, #25
 8004d5c:	d500      	bpl.n	8004d60 <I2CReadRegisterWordWithCRC.constprop.8+0x180>
 8004d5e:	e109      	b.n	8004f74 <I2CReadRegisterWordWithCRC.constprop.8+0x394>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004d60:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004d62:	007b      	lsls	r3, r7, #1
 8004d64:	b2db      	uxtb	r3, r3
 8004d66:	b27f      	sxtb	r7, r7
				crc ^= key;
 8004d68:	405e      	eors	r6, r3
 8004d6a:	2f00      	cmp	r7, #0
 8004d6c:	da00      	bge.n	8004d70 <I2CReadRegisterWordWithCRC.constprop.8+0x190>
 8004d6e:	e132      	b.n	8004fd6 <I2CReadRegisterWordWithCRC.constprop.8+0x3f6>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004d70:	2707      	movs	r7, #7
 8004d72:	b2de      	uxtb	r6, r3
 8004d74:	4077      	eors	r7, r6
 8004d76:	0691      	lsls	r1, r2, #26
 8004d78:	d500      	bpl.n	8004d7c <I2CReadRegisterWordWithCRC.constprop.8+0x19c>
 8004d7a:	e0f9      	b.n	8004f70 <I2CReadRegisterWordWithCRC.constprop.8+0x390>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004d7c:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004d7e:	005f      	lsls	r7, r3, #1
 8004d80:	b2ff      	uxtb	r7, r7
 8004d82:	b25b      	sxtb	r3, r3
				crc ^= key;
 8004d84:	407e      	eors	r6, r7
 8004d86:	2b00      	cmp	r3, #0
 8004d88:	da00      	bge.n	8004d8c <I2CReadRegisterWordWithCRC.constprop.8+0x1ac>
 8004d8a:	e122      	b.n	8004fd2 <I2CReadRegisterWordWithCRC.constprop.8+0x3f2>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004d8c:	2307      	movs	r3, #7
 8004d8e:	b2fe      	uxtb	r6, r7
 8004d90:	4073      	eors	r3, r6
 8004d92:	06d1      	lsls	r1, r2, #27
 8004d94:	d500      	bpl.n	8004d98 <I2CReadRegisterWordWithCRC.constprop.8+0x1b8>
 8004d96:	e0e9      	b.n	8004f6c <I2CReadRegisterWordWithCRC.constprop.8+0x38c>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004d98:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004d9a:	007b      	lsls	r3, r7, #1
 8004d9c:	b2db      	uxtb	r3, r3
 8004d9e:	b27f      	sxtb	r7, r7
				crc ^= key;
 8004da0:	405e      	eors	r6, r3
 8004da2:	2f00      	cmp	r7, #0
 8004da4:	da00      	bge.n	8004da8 <I2CReadRegisterWordWithCRC.constprop.8+0x1c8>
 8004da6:	e11a      	b.n	8004fde <I2CReadRegisterWordWithCRC.constprop.8+0x3fe>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004da8:	2707      	movs	r7, #7
 8004daa:	b2de      	uxtb	r6, r3
 8004dac:	4077      	eors	r7, r6
 8004dae:	0711      	lsls	r1, r2, #28
 8004db0:	d500      	bpl.n	8004db4 <I2CReadRegisterWordWithCRC.constprop.8+0x1d4>
 8004db2:	e0d9      	b.n	8004f68 <I2CReadRegisterWordWithCRC.constprop.8+0x388>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004db4:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004db6:	005f      	lsls	r7, r3, #1
 8004db8:	b2ff      	uxtb	r7, r7
 8004dba:	b25b      	sxtb	r3, r3
				crc ^= key;
 8004dbc:	407e      	eors	r6, r7
 8004dbe:	2b00      	cmp	r3, #0
 8004dc0:	da00      	bge.n	8004dc4 <I2CReadRegisterWordWithCRC.constprop.8+0x1e4>
 8004dc2:	e10a      	b.n	8004fda <I2CReadRegisterWordWithCRC.constprop.8+0x3fa>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004dc4:	2307      	movs	r3, #7
 8004dc6:	b2fe      	uxtb	r6, r7
 8004dc8:	4073      	eors	r3, r6
 8004dca:	0751      	lsls	r1, r2, #29
 8004dcc:	d500      	bpl.n	8004dd0 <I2CReadRegisterWordWithCRC.constprop.8+0x1f0>
 8004dce:	e0c9      	b.n	8004f64 <I2CReadRegisterWordWithCRC.constprop.8+0x384>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004dd0:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004dd2:	007b      	lsls	r3, r7, #1
 8004dd4:	b2db      	uxtb	r3, r3
 8004dd6:	b27f      	sxtb	r7, r7
				crc ^= key;
 8004dd8:	405e      	eors	r6, r3
 8004dda:	2f00      	cmp	r7, #0
 8004ddc:	da00      	bge.n	8004de0 <I2CReadRegisterWordWithCRC.constprop.8+0x200>
 8004dde:	e0f2      	b.n	8004fc6 <I2CReadRegisterWordWithCRC.constprop.8+0x3e6>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004de0:	2707      	movs	r7, #7
 8004de2:	b2de      	uxtb	r6, r3
 8004de4:	4077      	eors	r7, r6
 8004de6:	0791      	lsls	r1, r2, #30
 8004de8:	d500      	bpl.n	8004dec <I2CReadRegisterWordWithCRC.constprop.8+0x20c>
 8004dea:	e0b9      	b.n	8004f60 <I2CReadRegisterWordWithCRC.constprop.8+0x380>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004dec:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004dee:	005f      	lsls	r7, r3, #1
 8004df0:	b2ff      	uxtb	r7, r7
 8004df2:	b25b      	sxtb	r3, r3
				crc ^= key;
 8004df4:	407e      	eors	r6, r7
 8004df6:	2b00      	cmp	r3, #0
 8004df8:	da00      	bge.n	8004dfc <I2CReadRegisterWordWithCRC.constprop.8+0x21c>
 8004dfa:	e0e2      	b.n	8004fc2 <I2CReadRegisterWordWithCRC.constprop.8+0x3e2>
 8004dfc:	1c3b      	adds	r3, r7, #0
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004dfe:	2707      	movs	r7, #7
 8004e00:	b2de      	uxtb	r6, r3
 8004e02:	4077      	eors	r7, r6
 8004e04:	07d2      	lsls	r2, r2, #31
 8004e06:	d500      	bpl.n	8004e0a <I2CReadRegisterWordWithCRC.constprop.8+0x22a>
 8004e08:	e0a8      	b.n	8004f5c <I2CReadRegisterWordWithCRC.constprop.8+0x37c>
    err = i2cGetErrors(i2cp);

  //CRC check for first byte
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
  crc[0] = CRC8(CRCInput, 2, 7) ;
 8004e0a:	aa04      	add	r2, sp, #16
 8004e0c:	7013      	strb	r3, [r2, #0]
  //CRC check for second byte
  CRCInput[0] = rx_buffer[2];
 8004e0e:	78a7      	ldrb	r7, [r4, #2]
 8004e10:	2300      	movs	r3, #0
 8004e12:	7007      	strb	r7, [r0, #0]
 8004e14:	7800      	ldrb	r0, [r0, #0]
 8004e16:	09c6      	lsrs	r6, r0, #7
 8004e18:	d000      	beq.n	8004e1c <I2CReadRegisterWordWithCRC.constprop.8+0x23c>
 8004e1a:	e09d      	b.n	8004f58 <I2CReadRegisterWordWithCRC.constprop.8+0x378>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004e1c:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004e1e:	005b      	lsls	r3, r3, #1
 8004e20:	b2db      	uxtb	r3, r3
 8004e22:	b2d9      	uxtb	r1, r3
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004e24:	404e      	eors	r6, r1
 8004e26:	0641      	lsls	r1, r0, #25
 8004e28:	d500      	bpl.n	8004e2c <I2CReadRegisterWordWithCRC.constprop.8+0x24c>
 8004e2a:	e093      	b.n	8004f54 <I2CReadRegisterWordWithCRC.constprop.8+0x374>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004e2c:	2107      	movs	r1, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004e2e:	005e      	lsls	r6, r3, #1
 8004e30:	b2f6      	uxtb	r6, r6
 8004e32:	b25b      	sxtb	r3, r3
				crc ^= key;
 8004e34:	4071      	eors	r1, r6
 8004e36:	2b00      	cmp	r3, #0
 8004e38:	da00      	bge.n	8004e3c <I2CReadRegisterWordWithCRC.constprop.8+0x25c>
 8004e3a:	e0c8      	b.n	8004fce <I2CReadRegisterWordWithCRC.constprop.8+0x3ee>
 8004e3c:	1c33      	adds	r3, r6, #0
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004e3e:	2607      	movs	r6, #7
 8004e40:	b2d9      	uxtb	r1, r3
 8004e42:	4071      	eors	r1, r6
 8004e44:	1c1e      	adds	r6, r3, #0
 8004e46:	0683      	lsls	r3, r0, #26
 8004e48:	d500      	bpl.n	8004e4c <I2CReadRegisterWordWithCRC.constprop.8+0x26c>
 8004e4a:	e081      	b.n	8004f50 <I2CReadRegisterWordWithCRC.constprop.8+0x370>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004e4c:	2107      	movs	r1, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004e4e:	0073      	lsls	r3, r6, #1
 8004e50:	b2db      	uxtb	r3, r3
				crc ^= key;
 8004e52:	4059      	eors	r1, r3
 8004e54:	468c      	mov	ip, r1
 8004e56:	b271      	sxtb	r1, r6
 8004e58:	2900      	cmp	r1, #0
 8004e5a:	da00      	bge.n	8004e5e <I2CReadRegisterWordWithCRC.constprop.8+0x27e>
 8004e5c:	e0b5      	b.n	8004fca <I2CReadRegisterWordWithCRC.constprop.8+0x3ea>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004e5e:	2607      	movs	r6, #7
 8004e60:	b2d9      	uxtb	r1, r3
 8004e62:	4071      	eors	r1, r6
 8004e64:	1c1e      	adds	r6, r3, #0
 8004e66:	06c3      	lsls	r3, r0, #27
 8004e68:	d467      	bmi.n	8004f3a <I2CReadRegisterWordWithCRC.constprop.8+0x35a>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004e6a:	2107      	movs	r1, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004e6c:	0073      	lsls	r3, r6, #1
 8004e6e:	b2db      	uxtb	r3, r3
				crc ^= key;
 8004e70:	4059      	eors	r1, r3
 8004e72:	4688      	mov	r8, r1
 8004e74:	b271      	sxtb	r1, r6
 8004e76:	2900      	cmp	r1, #0
 8004e78:	da00      	bge.n	8004e7c <I2CReadRegisterWordWithCRC.constprop.8+0x29c>
 8004e7a:	e0a0      	b.n	8004fbe <I2CReadRegisterWordWithCRC.constprop.8+0x3de>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004e7c:	2607      	movs	r6, #7
 8004e7e:	b2d9      	uxtb	r1, r3
 8004e80:	4071      	eors	r1, r6
 8004e82:	1c1e      	adds	r6, r3, #0
 8004e84:	0703      	lsls	r3, r0, #28
 8004e86:	d456      	bmi.n	8004f36 <I2CReadRegisterWordWithCRC.constprop.8+0x356>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004e88:	2107      	movs	r1, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004e8a:	0073      	lsls	r3, r6, #1
 8004e8c:	b2db      	uxtb	r3, r3
				crc ^= key;
 8004e8e:	4059      	eors	r1, r3
 8004e90:	468c      	mov	ip, r1
 8004e92:	b271      	sxtb	r1, r6
 8004e94:	2900      	cmp	r1, #0
 8004e96:	da00      	bge.n	8004e9a <I2CReadRegisterWordWithCRC.constprop.8+0x2ba>
 8004e98:	e08f      	b.n	8004fba <I2CReadRegisterWordWithCRC.constprop.8+0x3da>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004e9a:	2607      	movs	r6, #7
 8004e9c:	b2d9      	uxtb	r1, r3
 8004e9e:	4071      	eors	r1, r6
 8004ea0:	1c1e      	adds	r6, r3, #0
 8004ea2:	0743      	lsls	r3, r0, #29
 8004ea4:	d445      	bmi.n	8004f32 <I2CReadRegisterWordWithCRC.constprop.8+0x352>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8004ea6:	2107      	movs	r1, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004ea8:	0073      	lsls	r3, r6, #1
 8004eaa:	b2db      	uxtb	r3, r3
				crc ^= key;
 8004eac:	4059      	eors	r1, r3
 8004eae:	4688      	mov	r8, r1
 8004eb0:	b271      	sxtb	r1, r6
 8004eb2:	2900      	cmp	r1, #0
 8004eb4:	da00      	bge.n	8004eb8 <I2CReadRegisterWordWithCRC.constprop.8+0x2d8>
 8004eb6:	e07e      	b.n	8004fb6 <I2CReadRegisterWordWithCRC.constprop.8+0x3d6>
 8004eb8:	b2d9      	uxtb	r1, r3
 8004eba:	4688      	mov	r8, r1
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004ebc:	2107      	movs	r1, #7
 8004ebe:	468c      	mov	ip, r1
 8004ec0:	4641      	mov	r1, r8
 8004ec2:	4666      	mov	r6, ip
 8004ec4:	4071      	eors	r1, r6
 8004ec6:	468c      	mov	ip, r1
 8004ec8:	0781      	lsls	r1, r0, #30
 8004eca:	d430      	bmi.n	8004f2e <I2CReadRegisterWordWithCRC.constprop.8+0x34e>
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8004ecc:	466e      	mov	r6, sp
 8004ece:	0059      	lsls	r1, r3, #1
 8004ed0:	71f1      	strb	r1, [r6, #7]
 8004ed2:	79f1      	ldrb	r1, [r6, #7]
 8004ed4:	b25b      	sxtb	r3, r3
 8004ed6:	468c      	mov	ip, r1
				crc ^= key;
 8004ed8:	2107      	movs	r1, #7
 8004eda:	4666      	mov	r6, ip
 8004edc:	4071      	eors	r1, r6
 8004ede:	2b00      	cmp	r3, #0
 8004ee0:	db67      	blt.n	8004fb2 <I2CReadRegisterWordWithCRC.constprop.8+0x3d2>
 8004ee2:	4663      	mov	r3, ip
 8004ee4:	b2d9      	uxtb	r1, r3
 8004ee6:	4688      	mov	r8, r1
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8004ee8:	2107      	movs	r1, #7
 8004eea:	468c      	mov	ip, r1
 8004eec:	4641      	mov	r1, r8
 8004eee:	4666      	mov	r6, ip
 8004ef0:	4071      	eors	r1, r6
 8004ef2:	468c      	mov	ip, r1
 8004ef4:	07c1      	lsls	r1, r0, #31
 8004ef6:	d418      	bmi.n	8004f2a <I2CReadRegisterWordWithCRC.constprop.8+0x34a>
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
  crc[0] = CRC8(CRCInput, 2, 7) ;
  //CRC check for second byte
  CRCInput[0] = rx_buffer[2];
  crc[1] = CRC8(CRCInput, 1, 7);
 8004ef8:	7053      	strb	r3, [r2, #1]
  if (crc[0] != rx_buffer[1] || crc[1]!= rx_buffer[3] )
 8004efa:	7813      	ldrb	r3, [r2, #0]
 8004efc:	7860      	ldrb	r0, [r4, #1]
 8004efe:	4298      	cmp	r0, r3
 8004f00:	d000      	beq.n	8004f04 <I2CReadRegisterWordWithCRC.constprop.8+0x324>
 8004f02:	e076      	b.n	8004ff2 <I2CReadRegisterWordWithCRC.constprop.8+0x412>
 8004f04:	7853      	ldrb	r3, [r2, #1]
 8004f06:	78e2      	ldrb	r2, [r4, #3]
 8004f08:	429a      	cmp	r2, r3
 8004f0a:	d000      	beq.n	8004f0e <I2CReadRegisterWordWithCRC.constprop.8+0x32e>
 8004f0c:	e071      	b.n	8004ff2 <I2CReadRegisterWordWithCRC.constprop.8+0x412>
    return -1;
  else 
    *data = (rx_buffer[0]<<8) + rx_buffer[2];
 8004f0e:	4653      	mov	r3, sl
  return msg;
 8004f10:	4648      	mov	r0, r9
  CRCInput[0] = rx_buffer[2];
  crc[1] = CRC8(CRCInput, 1, 7);
  if (crc[0] != rx_buffer[1] || crc[1]!= rx_buffer[3] )
    return -1;
  else 
    *data = (rx_buffer[0]<<8) + rx_buffer[2];
 8004f12:	0219      	lsls	r1, r3, #8
 8004f14:	19cf      	adds	r7, r1, r7
 8004f16:	802f      	strh	r7, [r5, #0]
  return msg;
}
 8004f18:	b006      	add	sp, #24
 8004f1a:	bc1c      	pop	{r2, r3, r4}
 8004f1c:	4690      	mov	r8, r2
 8004f1e:	4699      	mov	r9, r3
 8004f20:	46a2      	mov	sl, r4
 8004f22:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 8004f24:	4809      	ldr	r0, [pc, #36]	; (8004f4c <I2CReadRegisterWordWithCRC.constprop.8+0x36c>)
 8004f26:	f7fd fd23 	bl	8002970 <chSysHalt>
 8004f2a:	4663      	mov	r3, ip
 8004f2c:	e7e4      	b.n	8004ef8 <I2CReadRegisterWordWithCRC.constprop.8+0x318>
 8004f2e:	4663      	mov	r3, ip
 8004f30:	e7cc      	b.n	8004ecc <I2CReadRegisterWordWithCRC.constprop.8+0x2ec>
 8004f32:	1c0e      	adds	r6, r1, #0
 8004f34:	e7b7      	b.n	8004ea6 <I2CReadRegisterWordWithCRC.constprop.8+0x2c6>
 8004f36:	1c0e      	adds	r6, r1, #0
 8004f38:	e7a6      	b.n	8004e88 <I2CReadRegisterWordWithCRC.constprop.8+0x2a8>
 8004f3a:	1c0e      	adds	r6, r1, #0
 8004f3c:	e795      	b.n	8004e6a <I2CReadRegisterWordWithCRC.constprop.8+0x28a>
 8004f3e:	46c0      	nop			; (mov r8, r8)
 8004f40:	20000700 	.word	0x20000700
 8004f44:	08005808 	.word	0x08005808
 8004f48:	20000f84 	.word	0x20000f84
 8004f4c:	08005810 	.word	0x08005810
 8004f50:	1c0e      	adds	r6, r1, #0
 8004f52:	e77b      	b.n	8004e4c <I2CReadRegisterWordWithCRC.constprop.8+0x26c>
 8004f54:	1c33      	adds	r3, r6, #0
 8004f56:	e769      	b.n	8004e2c <I2CReadRegisterWordWithCRC.constprop.8+0x24c>
 8004f58:	2307      	movs	r3, #7
 8004f5a:	e75f      	b.n	8004e1c <I2CReadRegisterWordWithCRC.constprop.8+0x23c>
 8004f5c:	1c3b      	adds	r3, r7, #0
 8004f5e:	e754      	b.n	8004e0a <I2CReadRegisterWordWithCRC.constprop.8+0x22a>
 8004f60:	1c3b      	adds	r3, r7, #0
 8004f62:	e743      	b.n	8004dec <I2CReadRegisterWordWithCRC.constprop.8+0x20c>
 8004f64:	1c1f      	adds	r7, r3, #0
 8004f66:	e733      	b.n	8004dd0 <I2CReadRegisterWordWithCRC.constprop.8+0x1f0>
 8004f68:	1c3b      	adds	r3, r7, #0
 8004f6a:	e723      	b.n	8004db4 <I2CReadRegisterWordWithCRC.constprop.8+0x1d4>
 8004f6c:	1c1f      	adds	r7, r3, #0
 8004f6e:	e713      	b.n	8004d98 <I2CReadRegisterWordWithCRC.constprop.8+0x1b8>
 8004f70:	1c3b      	adds	r3, r7, #0
 8004f72:	e703      	b.n	8004d7c <I2CReadRegisterWordWithCRC.constprop.8+0x19c>
 8004f74:	1c1f      	adds	r7, r3, #0
 8004f76:	e6f3      	b.n	8004d60 <I2CReadRegisterWordWithCRC.constprop.8+0x180>
 8004f78:	1c33      	adds	r3, r6, #0
 8004f7a:	e6e3      	b.n	8004d44 <I2CReadRegisterWordWithCRC.constprop.8+0x164>
 8004f7c:	1c3b      	adds	r3, r7, #0
 8004f7e:	e6d1      	b.n	8004d24 <I2CReadRegisterWordWithCRC.constprop.8+0x144>
 8004f80:	1c1f      	adds	r7, r3, #0
 8004f82:	e6c1      	b.n	8004d08 <I2CReadRegisterWordWithCRC.constprop.8+0x128>
 8004f84:	1c3b      	adds	r3, r7, #0
 8004f86:	e6b1      	b.n	8004cec <I2CReadRegisterWordWithCRC.constprop.8+0x10c>
 8004f88:	1c1f      	adds	r7, r3, #0
 8004f8a:	e6a1      	b.n	8004cd0 <I2CReadRegisterWordWithCRC.constprop.8+0xf0>
 8004f8c:	1c3b      	adds	r3, r7, #0
 8004f8e:	e691      	b.n	8004cb4 <I2CReadRegisterWordWithCRC.constprop.8+0xd4>
 8004f90:	1c1f      	adds	r7, r3, #0
 8004f92:	e681      	b.n	8004c98 <I2CReadRegisterWordWithCRC.constprop.8+0xb8>
 8004f94:	1c3b      	adds	r3, r7, #0
 8004f96:	e671      	b.n	8004c7c <I2CReadRegisterWordWithCRC.constprop.8+0x9c>
 8004f98:	2307      	movs	r3, #7
 8004f9a:	e667      	b.n	8004c6c <I2CReadRegisterWordWithCRC.constprop.8+0x8c>
 8004f9c:	4816      	ldr	r0, [pc, #88]	; (8004ff8 <I2CReadRegisterWordWithCRC.constprop.8+0x418>)
 8004f9e:	f7fd fce7 	bl	8002970 <chSysHalt>
 8004fa2:	1c33      	adds	r3, r6, #0
 8004fa4:	e680      	b.n	8004ca8 <I2CReadRegisterWordWithCRC.constprop.8+0xc8>
 8004fa6:	1c37      	adds	r7, r6, #0
 8004fa8:	e670      	b.n	8004c8c <I2CReadRegisterWordWithCRC.constprop.8+0xac>
 8004faa:	1c33      	adds	r3, r6, #0
 8004fac:	e698      	b.n	8004ce0 <I2CReadRegisterWordWithCRC.constprop.8+0x100>
 8004fae:	1c37      	adds	r7, r6, #0
 8004fb0:	e688      	b.n	8004cc4 <I2CReadRegisterWordWithCRC.constprop.8+0xe4>
 8004fb2:	1c0b      	adds	r3, r1, #0
 8004fb4:	e796      	b.n	8004ee4 <I2CReadRegisterWordWithCRC.constprop.8+0x304>
 8004fb6:	4643      	mov	r3, r8
 8004fb8:	e77e      	b.n	8004eb8 <I2CReadRegisterWordWithCRC.constprop.8+0x2d8>
 8004fba:	4663      	mov	r3, ip
 8004fbc:	e76d      	b.n	8004e9a <I2CReadRegisterWordWithCRC.constprop.8+0x2ba>
 8004fbe:	4643      	mov	r3, r8
 8004fc0:	e75c      	b.n	8004e7c <I2CReadRegisterWordWithCRC.constprop.8+0x29c>
 8004fc2:	1c33      	adds	r3, r6, #0
 8004fc4:	e71b      	b.n	8004dfe <I2CReadRegisterWordWithCRC.constprop.8+0x21e>
 8004fc6:	1c33      	adds	r3, r6, #0
 8004fc8:	e70a      	b.n	8004de0 <I2CReadRegisterWordWithCRC.constprop.8+0x200>
 8004fca:	4663      	mov	r3, ip
 8004fcc:	e747      	b.n	8004e5e <I2CReadRegisterWordWithCRC.constprop.8+0x27e>
 8004fce:	1c0b      	adds	r3, r1, #0
 8004fd0:	e735      	b.n	8004e3e <I2CReadRegisterWordWithCRC.constprop.8+0x25e>
 8004fd2:	1c37      	adds	r7, r6, #0
 8004fd4:	e6da      	b.n	8004d8c <I2CReadRegisterWordWithCRC.constprop.8+0x1ac>
 8004fd6:	1c33      	adds	r3, r6, #0
 8004fd8:	e6ca      	b.n	8004d70 <I2CReadRegisterWordWithCRC.constprop.8+0x190>
 8004fda:	1c37      	adds	r7, r6, #0
 8004fdc:	e6f2      	b.n	8004dc4 <I2CReadRegisterWordWithCRC.constprop.8+0x1e4>
 8004fde:	1c33      	adds	r3, r6, #0
 8004fe0:	e6e2      	b.n	8004da8 <I2CReadRegisterWordWithCRC.constprop.8+0x1c8>
 8004fe2:	1c33      	adds	r3, r6, #0
 8004fe4:	e698      	b.n	8004d18 <I2CReadRegisterWordWithCRC.constprop.8+0x138>
 8004fe6:	1c37      	adds	r7, r6, #0
 8004fe8:	e688      	b.n	8004cfc <I2CReadRegisterWordWithCRC.constprop.8+0x11c>
 8004fea:	1c37      	adds	r7, r6, #0
 8004fec:	e6b2      	b.n	8004d54 <I2CReadRegisterWordWithCRC.constprop.8+0x174>
 8004fee:	1c33      	adds	r3, r6, #0
 8004ff0:	e6a2      	b.n	8004d38 <I2CReadRegisterWordWithCRC.constprop.8+0x158>
  crc[0] = CRC8(CRCInput, 2, 7) ;
  //CRC check for second byte
  CRCInput[0] = rx_buffer[2];
  crc[1] = CRC8(CRCInput, 1, 7);
  if (crc[0] != rx_buffer[1] || crc[1]!= rx_buffer[3] )
    return -1;
 8004ff2:	2001      	movs	r0, #1
 8004ff4:	4240      	negs	r0, r0
 8004ff6:	e78f      	b.n	8004f18 <I2CReadRegisterWordWithCRC.constprop.8+0x338>
 8004ff8:	08005b24 	.word	0x08005b24
 8004ffc:	00000000 	.word	0x00000000

08005000 <I2CReadRegisterWordWithCRC.constprop.7>:
  else
    *data = rx_buffer[0];
  return msg;
}

msg_t I2CReadRegisterWordWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint16_t *data) {
 8005000:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005002:	4645      	mov	r5, r8
 8005004:	4657      	mov	r7, sl
 8005006:	464e      	mov	r6, r9
  msg_t msg;
  i2cflags_t err;
  uint8_t tx_buffer[1] = {reg_address};
 8005008:	2332      	movs	r3, #50	; 0x32
  else
    *data = rx_buffer[0];
  return msg;
}

msg_t I2CReadRegisterWordWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint16_t *data) {
 800500a:	b4e0      	push	{r5, r6, r7}
 800500c:	b086      	sub	sp, #24
  msg_t msg;
  i2cflags_t err;
  uint8_t tx_buffer[1] = {reg_address};
 800500e:	aa02      	add	r2, sp, #8
  else
    *data = rx_buffer[0];
  return msg;
}

msg_t I2CReadRegisterWordWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint16_t *data) {
 8005010:	1c05      	adds	r5, r0, #0
  msg_t msg;
  i2cflags_t err;
  uint8_t tx_buffer[1] = {reg_address};
 8005012:	7013      	strb	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8005014:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8005016:	4cd2      	ldr	r4, [pc, #840]	; (8005360 <I2CReadRegisterWordWithCRC.constprop.7+0x360>)
 8005018:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800501a:	2b00      	cmp	r3, #0
 800501c:	d102      	bne.n	8005024 <I2CReadRegisterWordWithCRC.constprop.7+0x24>
 800501e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005020:	2b00      	cmp	r3, #0
 8005022:	d002      	beq.n	800502a <I2CReadRegisterWordWithCRC.constprop.7+0x2a>
    chSysHalt("SV#4");
 8005024:	48cf      	ldr	r0, [pc, #828]	; (8005364 <I2CReadRegisterWordWithCRC.constprop.7+0x364>)
 8005026:	f7fd fca3 	bl	8002970 <chSysHalt>
 800502a:	4fcf      	ldr	r7, [pc, #828]	; (8005368 <I2CReadRegisterWordWithCRC.constprop.7+0x368>)
  }
  _dbg_enter_lock();
 800502c:	2301      	movs	r3, #1
 800502e:	1c38      	adds	r0, r7, #0
 8005030:	300c      	adds	r0, #12
 8005032:	6363      	str	r3, [r4, #52]	; 0x34
 8005034:	f7fe fbac 	bl	8003790 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8005038:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800503a:	2b00      	cmp	r3, #0
 800503c:	d000      	beq.n	8005040 <I2CReadRegisterWordWithCRC.constprop.7+0x40>
 800503e:	e182      	b.n	8005346 <I2CReadRegisterWordWithCRC.constprop.7+0x346>
 8005040:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005042:	2a00      	cmp	r2, #0
 8005044:	dc00      	bgt.n	8005048 <I2CReadRegisterWordWithCRC.constprop.7+0x48>
 8005046:	e17e      	b.n	8005346 <I2CReadRegisterWordWithCRC.constprop.7+0x346>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8005048:	6363      	str	r3, [r4, #52]	; 0x34
 800504a:	6823      	ldr	r3, [r4, #0]
 800504c:	42a3      	cmp	r3, r4
 800504e:	d005      	beq.n	800505c <I2CReadRegisterWordWithCRC.constprop.7+0x5c>
 8005050:	69a2      	ldr	r2, [r4, #24]
 8005052:	689b      	ldr	r3, [r3, #8]
 8005054:	6892      	ldr	r2, [r2, #8]
 8005056:	429a      	cmp	r2, r3
 8005058:	d200      	bcs.n	800505c <I2CReadRegisterWordWithCRC.constprop.7+0x5c>
 800505a:	e1af      	b.n	80053bc <I2CReadRegisterWordWithCRC.constprop.7+0x3bc>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800505c:	b662      	cpsie	i
  volatile uint8_t CRCInput[2];
  volatile uint8_t crc[2];

  //read data from i2c bus
  i2cAcquireBus(i2cp);
  msg = i2cMasterTransmitTimeout(&I2CD1, addr_bq76920, tx_buffer, 1,
 800505e:	ac05      	add	r4, sp, #20
 8005060:	1c22      	adds	r2, r4, #0
 8005062:	2304      	movs	r3, #4
 8005064:	2101      	movs	r1, #1
 8005066:	a802      	add	r0, sp, #8
 8005068:	f7ff fc4a 	bl	8004900 <i2cMasterTransmitTimeout.constprop.30>
 800506c:	4681      	mov	r9, r0
 800506e:	1c38      	adds	r0, r7, #0
 8005070:	300c      	adds	r0, #12
 8005072:	f7fe facd 	bl	8003610 <chMtxUnlock>
  i2cReleaseBus(i2cp);
  if (msg != MSG_OK)
    err = i2cGetErrors(i2cp);

  //CRC check for first byte
  CRCInput[0] = (addr_bq76920 << 1) + 1;
 8005076:	2311      	movs	r3, #17
 8005078:	a803      	add	r0, sp, #12
 800507a:	7003      	strb	r3, [r0, #0]
 800507c:	7802      	ldrb	r2, [r0, #0]
  CRCInput[1] = rx_buffer[0];
 800507e:	7823      	ldrb	r3, [r4, #0]
 8005080:	09d7      	lsrs	r7, r2, #7
 8005082:	469a      	mov	sl, r3
 8005084:	7043      	strb	r3, [r0, #1]
 8005086:	2300      	movs	r3, #0
 8005088:	2f00      	cmp	r7, #0
 800508a:	d000      	beq.n	800508e <I2CReadRegisterWordWithCRC.constprop.7+0x8e>
 800508c:	e194      	b.n	80053b8 <I2CReadRegisterWordWithCRC.constprop.7+0x3b8>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800508e:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005090:	005b      	lsls	r3, r3, #1
 8005092:	b2db      	uxtb	r3, r3
 8005094:	b2de      	uxtb	r6, r3
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005096:	4077      	eors	r7, r6
 8005098:	0651      	lsls	r1, r2, #25
 800509a:	d500      	bpl.n	800509e <I2CReadRegisterWordWithCRC.constprop.7+0x9e>
 800509c:	e18a      	b.n	80053b4 <I2CReadRegisterWordWithCRC.constprop.7+0x3b4>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800509e:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80050a0:	005f      	lsls	r7, r3, #1
 80050a2:	b2ff      	uxtb	r7, r7
 80050a4:	b25b      	sxtb	r3, r3
				crc ^= key;
 80050a6:	407e      	eors	r6, r7
 80050a8:	2b00      	cmp	r3, #0
 80050aa:	da00      	bge.n	80050ae <I2CReadRegisterWordWithCRC.constprop.7+0xae>
 80050ac:	e18b      	b.n	80053c6 <I2CReadRegisterWordWithCRC.constprop.7+0x3c6>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80050ae:	2307      	movs	r3, #7
 80050b0:	b2fe      	uxtb	r6, r7
 80050b2:	4073      	eors	r3, r6
 80050b4:	0691      	lsls	r1, r2, #26
 80050b6:	d500      	bpl.n	80050ba <I2CReadRegisterWordWithCRC.constprop.7+0xba>
 80050b8:	e17a      	b.n	80053b0 <I2CReadRegisterWordWithCRC.constprop.7+0x3b0>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80050ba:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80050bc:	007b      	lsls	r3, r7, #1
 80050be:	b2db      	uxtb	r3, r3
 80050c0:	b27f      	sxtb	r7, r7
				crc ^= key;
 80050c2:	405e      	eors	r6, r3
 80050c4:	2f00      	cmp	r7, #0
 80050c6:	da00      	bge.n	80050ca <I2CReadRegisterWordWithCRC.constprop.7+0xca>
 80050c8:	e17b      	b.n	80053c2 <I2CReadRegisterWordWithCRC.constprop.7+0x3c2>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80050ca:	2707      	movs	r7, #7
 80050cc:	b2de      	uxtb	r6, r3
 80050ce:	4077      	eors	r7, r6
 80050d0:	06d1      	lsls	r1, r2, #27
 80050d2:	d500      	bpl.n	80050d6 <I2CReadRegisterWordWithCRC.constprop.7+0xd6>
 80050d4:	e16a      	b.n	80053ac <I2CReadRegisterWordWithCRC.constprop.7+0x3ac>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80050d6:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80050d8:	005f      	lsls	r7, r3, #1
 80050da:	b2ff      	uxtb	r7, r7
 80050dc:	b25b      	sxtb	r3, r3
				crc ^= key;
 80050de:	407e      	eors	r6, r7
 80050e0:	2b00      	cmp	r3, #0
 80050e2:	da00      	bge.n	80050e6 <I2CReadRegisterWordWithCRC.constprop.7+0xe6>
 80050e4:	e173      	b.n	80053ce <I2CReadRegisterWordWithCRC.constprop.7+0x3ce>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80050e6:	2307      	movs	r3, #7
 80050e8:	b2fe      	uxtb	r6, r7
 80050ea:	4073      	eors	r3, r6
 80050ec:	0711      	lsls	r1, r2, #28
 80050ee:	d500      	bpl.n	80050f2 <I2CReadRegisterWordWithCRC.constprop.7+0xf2>
 80050f0:	e15a      	b.n	80053a8 <I2CReadRegisterWordWithCRC.constprop.7+0x3a8>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80050f2:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80050f4:	007b      	lsls	r3, r7, #1
 80050f6:	b2db      	uxtb	r3, r3
 80050f8:	b27f      	sxtb	r7, r7
				crc ^= key;
 80050fa:	405e      	eors	r6, r3
 80050fc:	2f00      	cmp	r7, #0
 80050fe:	da00      	bge.n	8005102 <I2CReadRegisterWordWithCRC.constprop.7+0x102>
 8005100:	e163      	b.n	80053ca <I2CReadRegisterWordWithCRC.constprop.7+0x3ca>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005102:	2707      	movs	r7, #7
 8005104:	b2de      	uxtb	r6, r3
 8005106:	4077      	eors	r7, r6
 8005108:	0751      	lsls	r1, r2, #29
 800510a:	d500      	bpl.n	800510e <I2CReadRegisterWordWithCRC.constprop.7+0x10e>
 800510c:	e14a      	b.n	80053a4 <I2CReadRegisterWordWithCRC.constprop.7+0x3a4>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800510e:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005110:	005f      	lsls	r7, r3, #1
 8005112:	b2ff      	uxtb	r7, r7
 8005114:	b25b      	sxtb	r3, r3
				crc ^= key;
 8005116:	407e      	eors	r6, r7
 8005118:	2b00      	cmp	r3, #0
 800511a:	da00      	bge.n	800511e <I2CReadRegisterWordWithCRC.constprop.7+0x11e>
 800511c:	e173      	b.n	8005406 <I2CReadRegisterWordWithCRC.constprop.7+0x406>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800511e:	2307      	movs	r3, #7
 8005120:	b2fe      	uxtb	r6, r7
 8005122:	4073      	eors	r3, r6
 8005124:	0791      	lsls	r1, r2, #30
 8005126:	d500      	bpl.n	800512a <I2CReadRegisterWordWithCRC.constprop.7+0x12a>
 8005128:	e13a      	b.n	80053a0 <I2CReadRegisterWordWithCRC.constprop.7+0x3a0>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800512a:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800512c:	007b      	lsls	r3, r7, #1
 800512e:	b2db      	uxtb	r3, r3
 8005130:	b27f      	sxtb	r7, r7
				crc ^= key;
 8005132:	405e      	eors	r6, r3
 8005134:	2f00      	cmp	r7, #0
 8005136:	da00      	bge.n	800513a <I2CReadRegisterWordWithCRC.constprop.7+0x13a>
 8005138:	e163      	b.n	8005402 <I2CReadRegisterWordWithCRC.constprop.7+0x402>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800513a:	2707      	movs	r7, #7
 800513c:	b2de      	uxtb	r6, r3
 800513e:	4077      	eors	r7, r6
 8005140:	07d2      	lsls	r2, r2, #31
 8005142:	d500      	bpl.n	8005146 <I2CReadRegisterWordWithCRC.constprop.7+0x146>
 8005144:	e12a      	b.n	800539c <I2CReadRegisterWordWithCRC.constprop.7+0x39c>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8005146:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005148:	005f      	lsls	r7, r3, #1
 800514a:	b2ff      	uxtb	r7, r7
 800514c:	b25b      	sxtb	r3, r3
 800514e:	7842      	ldrb	r2, [r0, #1]
				crc ^= key;
 8005150:	407e      	eors	r6, r7
 8005152:	2b00      	cmp	r3, #0
 8005154:	da00      	bge.n	8005158 <I2CReadRegisterWordWithCRC.constprop.7+0x158>
 8005156:	e15a      	b.n	800540e <I2CReadRegisterWordWithCRC.constprop.7+0x40e>
 8005158:	1c3b      	adds	r3, r7, #0
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800515a:	2707      	movs	r7, #7
 800515c:	b2de      	uxtb	r6, r3
 800515e:	407e      	eors	r6, r7
 8005160:	09d7      	lsrs	r7, r2, #7
 8005162:	d000      	beq.n	8005166 <I2CReadRegisterWordWithCRC.constprop.7+0x166>
 8005164:	e118      	b.n	8005398 <I2CReadRegisterWordWithCRC.constprop.7+0x398>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8005166:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005168:	005f      	lsls	r7, r3, #1
 800516a:	b2ff      	uxtb	r7, r7
 800516c:	b25b      	sxtb	r3, r3
				crc ^= key;
 800516e:	407e      	eors	r6, r7
 8005170:	2b00      	cmp	r3, #0
 8005172:	da00      	bge.n	8005176 <I2CReadRegisterWordWithCRC.constprop.7+0x176>
 8005174:	e149      	b.n	800540a <I2CReadRegisterWordWithCRC.constprop.7+0x40a>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005176:	2307      	movs	r3, #7
 8005178:	b2fe      	uxtb	r6, r7
 800517a:	4073      	eors	r3, r6
 800517c:	0651      	lsls	r1, r2, #25
 800517e:	d500      	bpl.n	8005182 <I2CReadRegisterWordWithCRC.constprop.7+0x182>
 8005180:	e108      	b.n	8005394 <I2CReadRegisterWordWithCRC.constprop.7+0x394>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8005182:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005184:	007b      	lsls	r3, r7, #1
 8005186:	b2db      	uxtb	r3, r3
 8005188:	b27f      	sxtb	r7, r7
				crc ^= key;
 800518a:	405e      	eors	r6, r3
 800518c:	2f00      	cmp	r7, #0
 800518e:	da00      	bge.n	8005192 <I2CReadRegisterWordWithCRC.constprop.7+0x192>
 8005190:	e131      	b.n	80053f6 <I2CReadRegisterWordWithCRC.constprop.7+0x3f6>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005192:	2707      	movs	r7, #7
 8005194:	b2de      	uxtb	r6, r3
 8005196:	4077      	eors	r7, r6
 8005198:	0691      	lsls	r1, r2, #26
 800519a:	d500      	bpl.n	800519e <I2CReadRegisterWordWithCRC.constprop.7+0x19e>
 800519c:	e0f8      	b.n	8005390 <I2CReadRegisterWordWithCRC.constprop.7+0x390>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800519e:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80051a0:	005f      	lsls	r7, r3, #1
 80051a2:	b2ff      	uxtb	r7, r7
 80051a4:	b25b      	sxtb	r3, r3
				crc ^= key;
 80051a6:	407e      	eors	r6, r7
 80051a8:	2b00      	cmp	r3, #0
 80051aa:	da00      	bge.n	80051ae <I2CReadRegisterWordWithCRC.constprop.7+0x1ae>
 80051ac:	e121      	b.n	80053f2 <I2CReadRegisterWordWithCRC.constprop.7+0x3f2>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80051ae:	2307      	movs	r3, #7
 80051b0:	b2fe      	uxtb	r6, r7
 80051b2:	4073      	eors	r3, r6
 80051b4:	06d1      	lsls	r1, r2, #27
 80051b6:	d500      	bpl.n	80051ba <I2CReadRegisterWordWithCRC.constprop.7+0x1ba>
 80051b8:	e0e8      	b.n	800538c <I2CReadRegisterWordWithCRC.constprop.7+0x38c>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80051ba:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80051bc:	007b      	lsls	r3, r7, #1
 80051be:	b2db      	uxtb	r3, r3
 80051c0:	b27f      	sxtb	r7, r7
				crc ^= key;
 80051c2:	405e      	eors	r6, r3
 80051c4:	2f00      	cmp	r7, #0
 80051c6:	da00      	bge.n	80051ca <I2CReadRegisterWordWithCRC.constprop.7+0x1ca>
 80051c8:	e119      	b.n	80053fe <I2CReadRegisterWordWithCRC.constprop.7+0x3fe>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80051ca:	2707      	movs	r7, #7
 80051cc:	b2de      	uxtb	r6, r3
 80051ce:	4077      	eors	r7, r6
 80051d0:	0711      	lsls	r1, r2, #28
 80051d2:	d500      	bpl.n	80051d6 <I2CReadRegisterWordWithCRC.constprop.7+0x1d6>
 80051d4:	e0d8      	b.n	8005388 <I2CReadRegisterWordWithCRC.constprop.7+0x388>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80051d6:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80051d8:	005f      	lsls	r7, r3, #1
 80051da:	b2ff      	uxtb	r7, r7
 80051dc:	b25b      	sxtb	r3, r3
				crc ^= key;
 80051de:	407e      	eors	r6, r7
 80051e0:	2b00      	cmp	r3, #0
 80051e2:	da00      	bge.n	80051e6 <I2CReadRegisterWordWithCRC.constprop.7+0x1e6>
 80051e4:	e109      	b.n	80053fa <I2CReadRegisterWordWithCRC.constprop.7+0x3fa>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80051e6:	2307      	movs	r3, #7
 80051e8:	b2fe      	uxtb	r6, r7
 80051ea:	4073      	eors	r3, r6
 80051ec:	0751      	lsls	r1, r2, #29
 80051ee:	d500      	bpl.n	80051f2 <I2CReadRegisterWordWithCRC.constprop.7+0x1f2>
 80051f0:	e0c8      	b.n	8005384 <I2CReadRegisterWordWithCRC.constprop.7+0x384>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80051f2:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80051f4:	007b      	lsls	r3, r7, #1
 80051f6:	b2db      	uxtb	r3, r3
 80051f8:	b27f      	sxtb	r7, r7
				crc ^= key;
 80051fa:	405e      	eors	r6, r3
 80051fc:	2f00      	cmp	r7, #0
 80051fe:	da00      	bge.n	8005202 <I2CReadRegisterWordWithCRC.constprop.7+0x202>
 8005200:	e0f1      	b.n	80053e6 <I2CReadRegisterWordWithCRC.constprop.7+0x3e6>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005202:	2707      	movs	r7, #7
 8005204:	b2de      	uxtb	r6, r3
 8005206:	4077      	eors	r7, r6
 8005208:	0791      	lsls	r1, r2, #30
 800520a:	d500      	bpl.n	800520e <I2CReadRegisterWordWithCRC.constprop.7+0x20e>
 800520c:	e0b8      	b.n	8005380 <I2CReadRegisterWordWithCRC.constprop.7+0x380>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800520e:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005210:	005f      	lsls	r7, r3, #1
 8005212:	b2ff      	uxtb	r7, r7
 8005214:	b25b      	sxtb	r3, r3
				crc ^= key;
 8005216:	407e      	eors	r6, r7
 8005218:	2b00      	cmp	r3, #0
 800521a:	da00      	bge.n	800521e <I2CReadRegisterWordWithCRC.constprop.7+0x21e>
 800521c:	e0e1      	b.n	80053e2 <I2CReadRegisterWordWithCRC.constprop.7+0x3e2>
 800521e:	1c3b      	adds	r3, r7, #0
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005220:	2707      	movs	r7, #7
 8005222:	b2de      	uxtb	r6, r3
 8005224:	4077      	eors	r7, r6
 8005226:	07d2      	lsls	r2, r2, #31
 8005228:	d500      	bpl.n	800522c <I2CReadRegisterWordWithCRC.constprop.7+0x22c>
 800522a:	e0a7      	b.n	800537c <I2CReadRegisterWordWithCRC.constprop.7+0x37c>
    err = i2cGetErrors(i2cp);

  //CRC check for first byte
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
  crc[0] = CRC8(CRCInput, 2, 7) ;
 800522c:	aa04      	add	r2, sp, #16
 800522e:	7013      	strb	r3, [r2, #0]
  //CRC check for second byte
  CRCInput[0] = rx_buffer[2];
 8005230:	78a7      	ldrb	r7, [r4, #2]
 8005232:	2300      	movs	r3, #0
 8005234:	7007      	strb	r7, [r0, #0]
 8005236:	7800      	ldrb	r0, [r0, #0]
 8005238:	09c6      	lsrs	r6, r0, #7
 800523a:	d000      	beq.n	800523e <I2CReadRegisterWordWithCRC.constprop.7+0x23e>
 800523c:	e09c      	b.n	8005378 <I2CReadRegisterWordWithCRC.constprop.7+0x378>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800523e:	2607      	movs	r6, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005240:	005b      	lsls	r3, r3, #1
 8005242:	b2db      	uxtb	r3, r3
 8005244:	b2d9      	uxtb	r1, r3
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005246:	404e      	eors	r6, r1
 8005248:	0641      	lsls	r1, r0, #25
 800524a:	d500      	bpl.n	800524e <I2CReadRegisterWordWithCRC.constprop.7+0x24e>
 800524c:	e092      	b.n	8005374 <I2CReadRegisterWordWithCRC.constprop.7+0x374>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800524e:	2107      	movs	r1, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005250:	005e      	lsls	r6, r3, #1
 8005252:	b2f6      	uxtb	r6, r6
 8005254:	b25b      	sxtb	r3, r3
				crc ^= key;
 8005256:	4071      	eors	r1, r6
 8005258:	2b00      	cmp	r3, #0
 800525a:	da00      	bge.n	800525e <I2CReadRegisterWordWithCRC.constprop.7+0x25e>
 800525c:	e0c7      	b.n	80053ee <I2CReadRegisterWordWithCRC.constprop.7+0x3ee>
 800525e:	1c33      	adds	r3, r6, #0
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005260:	2607      	movs	r6, #7
 8005262:	b2d9      	uxtb	r1, r3
 8005264:	4071      	eors	r1, r6
 8005266:	1c1e      	adds	r6, r3, #0
 8005268:	0683      	lsls	r3, r0, #26
 800526a:	d500      	bpl.n	800526e <I2CReadRegisterWordWithCRC.constprop.7+0x26e>
 800526c:	e080      	b.n	8005370 <I2CReadRegisterWordWithCRC.constprop.7+0x370>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800526e:	2107      	movs	r1, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005270:	0073      	lsls	r3, r6, #1
 8005272:	b2db      	uxtb	r3, r3
				crc ^= key;
 8005274:	4059      	eors	r1, r3
 8005276:	468c      	mov	ip, r1
 8005278:	b271      	sxtb	r1, r6
 800527a:	2900      	cmp	r1, #0
 800527c:	da00      	bge.n	8005280 <I2CReadRegisterWordWithCRC.constprop.7+0x280>
 800527e:	e0b4      	b.n	80053ea <I2CReadRegisterWordWithCRC.constprop.7+0x3ea>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005280:	2607      	movs	r6, #7
 8005282:	b2d9      	uxtb	r1, r3
 8005284:	4071      	eors	r1, r6
 8005286:	1c1e      	adds	r6, r3, #0
 8005288:	06c3      	lsls	r3, r0, #27
 800528a:	d467      	bmi.n	800535c <I2CReadRegisterWordWithCRC.constprop.7+0x35c>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800528c:	2107      	movs	r1, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800528e:	0073      	lsls	r3, r6, #1
 8005290:	b2db      	uxtb	r3, r3
				crc ^= key;
 8005292:	4059      	eors	r1, r3
 8005294:	4688      	mov	r8, r1
 8005296:	b271      	sxtb	r1, r6
 8005298:	2900      	cmp	r1, #0
 800529a:	da00      	bge.n	800529e <I2CReadRegisterWordWithCRC.constprop.7+0x29e>
 800529c:	e09f      	b.n	80053de <I2CReadRegisterWordWithCRC.constprop.7+0x3de>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800529e:	2607      	movs	r6, #7
 80052a0:	b2d9      	uxtb	r1, r3
 80052a2:	4071      	eors	r1, r6
 80052a4:	1c1e      	adds	r6, r3, #0
 80052a6:	0703      	lsls	r3, r0, #28
 80052a8:	d456      	bmi.n	8005358 <I2CReadRegisterWordWithCRC.constprop.7+0x358>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80052aa:	2107      	movs	r1, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80052ac:	0073      	lsls	r3, r6, #1
 80052ae:	b2db      	uxtb	r3, r3
				crc ^= key;
 80052b0:	4059      	eors	r1, r3
 80052b2:	468c      	mov	ip, r1
 80052b4:	b271      	sxtb	r1, r6
 80052b6:	2900      	cmp	r1, #0
 80052b8:	da00      	bge.n	80052bc <I2CReadRegisterWordWithCRC.constprop.7+0x2bc>
 80052ba:	e08e      	b.n	80053da <I2CReadRegisterWordWithCRC.constprop.7+0x3da>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80052bc:	2607      	movs	r6, #7
 80052be:	b2d9      	uxtb	r1, r3
 80052c0:	4071      	eors	r1, r6
 80052c2:	1c1e      	adds	r6, r3, #0
 80052c4:	0743      	lsls	r3, r0, #29
 80052c6:	d445      	bmi.n	8005354 <I2CReadRegisterWordWithCRC.constprop.7+0x354>
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80052c8:	2107      	movs	r1, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80052ca:	0073      	lsls	r3, r6, #1
 80052cc:	b2db      	uxtb	r3, r3
				crc ^= key;
 80052ce:	4059      	eors	r1, r3
 80052d0:	4688      	mov	r8, r1
 80052d2:	b271      	sxtb	r1, r6
 80052d4:	2900      	cmp	r1, #0
 80052d6:	da00      	bge.n	80052da <I2CReadRegisterWordWithCRC.constprop.7+0x2da>
 80052d8:	e07d      	b.n	80053d6 <I2CReadRegisterWordWithCRC.constprop.7+0x3d6>
 80052da:	b2d9      	uxtb	r1, r3
 80052dc:	4688      	mov	r8, r1
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80052de:	2107      	movs	r1, #7
 80052e0:	468c      	mov	ip, r1
 80052e2:	4641      	mov	r1, r8
 80052e4:	4666      	mov	r6, ip
 80052e6:	4071      	eors	r1, r6
 80052e8:	468c      	mov	ip, r1
 80052ea:	0781      	lsls	r1, r0, #30
 80052ec:	d430      	bmi.n	8005350 <I2CReadRegisterWordWithCRC.constprop.7+0x350>
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80052ee:	466e      	mov	r6, sp
 80052f0:	0059      	lsls	r1, r3, #1
 80052f2:	71f1      	strb	r1, [r6, #7]
 80052f4:	79f1      	ldrb	r1, [r6, #7]
 80052f6:	b25b      	sxtb	r3, r3
 80052f8:	468c      	mov	ip, r1
				crc ^= key;
 80052fa:	2107      	movs	r1, #7
 80052fc:	4666      	mov	r6, ip
 80052fe:	4071      	eors	r1, r6
 8005300:	2b00      	cmp	r3, #0
 8005302:	db66      	blt.n	80053d2 <I2CReadRegisterWordWithCRC.constprop.7+0x3d2>
 8005304:	4663      	mov	r3, ip
 8005306:	b2d9      	uxtb	r1, r3
 8005308:	4688      	mov	r8, r1
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800530a:	2107      	movs	r1, #7
 800530c:	468c      	mov	ip, r1
 800530e:	4641      	mov	r1, r8
 8005310:	4666      	mov	r6, ip
 8005312:	4071      	eors	r1, r6
 8005314:	468c      	mov	ip, r1
 8005316:	07c1      	lsls	r1, r0, #31
 8005318:	d418      	bmi.n	800534c <I2CReadRegisterWordWithCRC.constprop.7+0x34c>
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
  crc[0] = CRC8(CRCInput, 2, 7) ;
  //CRC check for second byte
  CRCInput[0] = rx_buffer[2];
  crc[1] = CRC8(CRCInput, 1, 7);
 800531a:	7053      	strb	r3, [r2, #1]
  if (crc[0] != rx_buffer[1] || crc[1]!= rx_buffer[3] )
 800531c:	7813      	ldrb	r3, [r2, #0]
 800531e:	7860      	ldrb	r0, [r4, #1]
 8005320:	4298      	cmp	r0, r3
 8005322:	d000      	beq.n	8005326 <I2CReadRegisterWordWithCRC.constprop.7+0x326>
 8005324:	e075      	b.n	8005412 <I2CReadRegisterWordWithCRC.constprop.7+0x412>
 8005326:	7853      	ldrb	r3, [r2, #1]
 8005328:	78e2      	ldrb	r2, [r4, #3]
 800532a:	429a      	cmp	r2, r3
 800532c:	d000      	beq.n	8005330 <I2CReadRegisterWordWithCRC.constprop.7+0x330>
 800532e:	e070      	b.n	8005412 <I2CReadRegisterWordWithCRC.constprop.7+0x412>
    return -1;
  else 
    *data = (rx_buffer[0]<<8) + rx_buffer[2];
 8005330:	4653      	mov	r3, sl
  return msg;
 8005332:	4648      	mov	r0, r9
  CRCInput[0] = rx_buffer[2];
  crc[1] = CRC8(CRCInput, 1, 7);
  if (crc[0] != rx_buffer[1] || crc[1]!= rx_buffer[3] )
    return -1;
  else 
    *data = (rx_buffer[0]<<8) + rx_buffer[2];
 8005334:	0219      	lsls	r1, r3, #8
 8005336:	19cf      	adds	r7, r1, r7
 8005338:	802f      	strh	r7, [r5, #0]
  return msg;
}
 800533a:	b006      	add	sp, #24
 800533c:	bc1c      	pop	{r2, r3, r4}
 800533e:	4690      	mov	r8, r2
 8005340:	4699      	mov	r9, r3
 8005342:	46a2      	mov	sl, r4
 8005344:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 8005346:	4809      	ldr	r0, [pc, #36]	; (800536c <I2CReadRegisterWordWithCRC.constprop.7+0x36c>)
 8005348:	f7fd fb12 	bl	8002970 <chSysHalt>
 800534c:	4663      	mov	r3, ip
 800534e:	e7e4      	b.n	800531a <I2CReadRegisterWordWithCRC.constprop.7+0x31a>
 8005350:	4663      	mov	r3, ip
 8005352:	e7cc      	b.n	80052ee <I2CReadRegisterWordWithCRC.constprop.7+0x2ee>
 8005354:	1c0e      	adds	r6, r1, #0
 8005356:	e7b7      	b.n	80052c8 <I2CReadRegisterWordWithCRC.constprop.7+0x2c8>
 8005358:	1c0e      	adds	r6, r1, #0
 800535a:	e7a6      	b.n	80052aa <I2CReadRegisterWordWithCRC.constprop.7+0x2aa>
 800535c:	1c0e      	adds	r6, r1, #0
 800535e:	e795      	b.n	800528c <I2CReadRegisterWordWithCRC.constprop.7+0x28c>
 8005360:	20000700 	.word	0x20000700
 8005364:	08005808 	.word	0x08005808
 8005368:	20000f84 	.word	0x20000f84
 800536c:	08005810 	.word	0x08005810
 8005370:	1c0e      	adds	r6, r1, #0
 8005372:	e77c      	b.n	800526e <I2CReadRegisterWordWithCRC.constprop.7+0x26e>
 8005374:	1c33      	adds	r3, r6, #0
 8005376:	e76a      	b.n	800524e <I2CReadRegisterWordWithCRC.constprop.7+0x24e>
 8005378:	2307      	movs	r3, #7
 800537a:	e760      	b.n	800523e <I2CReadRegisterWordWithCRC.constprop.7+0x23e>
 800537c:	1c3b      	adds	r3, r7, #0
 800537e:	e755      	b.n	800522c <I2CReadRegisterWordWithCRC.constprop.7+0x22c>
 8005380:	1c3b      	adds	r3, r7, #0
 8005382:	e744      	b.n	800520e <I2CReadRegisterWordWithCRC.constprop.7+0x20e>
 8005384:	1c1f      	adds	r7, r3, #0
 8005386:	e734      	b.n	80051f2 <I2CReadRegisterWordWithCRC.constprop.7+0x1f2>
 8005388:	1c3b      	adds	r3, r7, #0
 800538a:	e724      	b.n	80051d6 <I2CReadRegisterWordWithCRC.constprop.7+0x1d6>
 800538c:	1c1f      	adds	r7, r3, #0
 800538e:	e714      	b.n	80051ba <I2CReadRegisterWordWithCRC.constprop.7+0x1ba>
 8005390:	1c3b      	adds	r3, r7, #0
 8005392:	e704      	b.n	800519e <I2CReadRegisterWordWithCRC.constprop.7+0x19e>
 8005394:	1c1f      	adds	r7, r3, #0
 8005396:	e6f4      	b.n	8005182 <I2CReadRegisterWordWithCRC.constprop.7+0x182>
 8005398:	1c33      	adds	r3, r6, #0
 800539a:	e6e4      	b.n	8005166 <I2CReadRegisterWordWithCRC.constprop.7+0x166>
 800539c:	1c3b      	adds	r3, r7, #0
 800539e:	e6d2      	b.n	8005146 <I2CReadRegisterWordWithCRC.constprop.7+0x146>
 80053a0:	1c1f      	adds	r7, r3, #0
 80053a2:	e6c2      	b.n	800512a <I2CReadRegisterWordWithCRC.constprop.7+0x12a>
 80053a4:	1c3b      	adds	r3, r7, #0
 80053a6:	e6b2      	b.n	800510e <I2CReadRegisterWordWithCRC.constprop.7+0x10e>
 80053a8:	1c1f      	adds	r7, r3, #0
 80053aa:	e6a2      	b.n	80050f2 <I2CReadRegisterWordWithCRC.constprop.7+0xf2>
 80053ac:	1c3b      	adds	r3, r7, #0
 80053ae:	e692      	b.n	80050d6 <I2CReadRegisterWordWithCRC.constprop.7+0xd6>
 80053b0:	1c1f      	adds	r7, r3, #0
 80053b2:	e682      	b.n	80050ba <I2CReadRegisterWordWithCRC.constprop.7+0xba>
 80053b4:	1c3b      	adds	r3, r7, #0
 80053b6:	e672      	b.n	800509e <I2CReadRegisterWordWithCRC.constprop.7+0x9e>
 80053b8:	2307      	movs	r3, #7
 80053ba:	e668      	b.n	800508e <I2CReadRegisterWordWithCRC.constprop.7+0x8e>
 80053bc:	4816      	ldr	r0, [pc, #88]	; (8005418 <I2CReadRegisterWordWithCRC.constprop.7+0x418>)
 80053be:	f7fd fad7 	bl	8002970 <chSysHalt>
 80053c2:	1c33      	adds	r3, r6, #0
 80053c4:	e681      	b.n	80050ca <I2CReadRegisterWordWithCRC.constprop.7+0xca>
 80053c6:	1c37      	adds	r7, r6, #0
 80053c8:	e671      	b.n	80050ae <I2CReadRegisterWordWithCRC.constprop.7+0xae>
 80053ca:	1c33      	adds	r3, r6, #0
 80053cc:	e699      	b.n	8005102 <I2CReadRegisterWordWithCRC.constprop.7+0x102>
 80053ce:	1c37      	adds	r7, r6, #0
 80053d0:	e689      	b.n	80050e6 <I2CReadRegisterWordWithCRC.constprop.7+0xe6>
 80053d2:	1c0b      	adds	r3, r1, #0
 80053d4:	e797      	b.n	8005306 <I2CReadRegisterWordWithCRC.constprop.7+0x306>
 80053d6:	4643      	mov	r3, r8
 80053d8:	e77f      	b.n	80052da <I2CReadRegisterWordWithCRC.constprop.7+0x2da>
 80053da:	4663      	mov	r3, ip
 80053dc:	e76e      	b.n	80052bc <I2CReadRegisterWordWithCRC.constprop.7+0x2bc>
 80053de:	4643      	mov	r3, r8
 80053e0:	e75d      	b.n	800529e <I2CReadRegisterWordWithCRC.constprop.7+0x29e>
 80053e2:	1c33      	adds	r3, r6, #0
 80053e4:	e71c      	b.n	8005220 <I2CReadRegisterWordWithCRC.constprop.7+0x220>
 80053e6:	1c33      	adds	r3, r6, #0
 80053e8:	e70b      	b.n	8005202 <I2CReadRegisterWordWithCRC.constprop.7+0x202>
 80053ea:	4663      	mov	r3, ip
 80053ec:	e748      	b.n	8005280 <I2CReadRegisterWordWithCRC.constprop.7+0x280>
 80053ee:	1c0b      	adds	r3, r1, #0
 80053f0:	e736      	b.n	8005260 <I2CReadRegisterWordWithCRC.constprop.7+0x260>
 80053f2:	1c37      	adds	r7, r6, #0
 80053f4:	e6db      	b.n	80051ae <I2CReadRegisterWordWithCRC.constprop.7+0x1ae>
 80053f6:	1c33      	adds	r3, r6, #0
 80053f8:	e6cb      	b.n	8005192 <I2CReadRegisterWordWithCRC.constprop.7+0x192>
 80053fa:	1c37      	adds	r7, r6, #0
 80053fc:	e6f3      	b.n	80051e6 <I2CReadRegisterWordWithCRC.constprop.7+0x1e6>
 80053fe:	1c33      	adds	r3, r6, #0
 8005400:	e6e3      	b.n	80051ca <I2CReadRegisterWordWithCRC.constprop.7+0x1ca>
 8005402:	1c33      	adds	r3, r6, #0
 8005404:	e699      	b.n	800513a <I2CReadRegisterWordWithCRC.constprop.7+0x13a>
 8005406:	1c37      	adds	r7, r6, #0
 8005408:	e689      	b.n	800511e <I2CReadRegisterWordWithCRC.constprop.7+0x11e>
 800540a:	1c37      	adds	r7, r6, #0
 800540c:	e6b3      	b.n	8005176 <I2CReadRegisterWordWithCRC.constprop.7+0x176>
 800540e:	1c33      	adds	r3, r6, #0
 8005410:	e6a3      	b.n	800515a <I2CReadRegisterWordWithCRC.constprop.7+0x15a>
  crc[0] = CRC8(CRCInput, 2, 7) ;
  //CRC check for second byte
  CRCInput[0] = rx_buffer[2];
  crc[1] = CRC8(CRCInput, 1, 7);
  if (crc[0] != rx_buffer[1] || crc[1]!= rx_buffer[3] )
    return -1;
 8005412:	2001      	movs	r0, #1
 8005414:	4240      	negs	r0, r0
 8005416:	e790      	b.n	800533a <I2CReadRegisterWordWithCRC.constprop.7+0x33a>
 8005418:	08005b24 	.word	0x08005b24
 800541c:	00000000 	.word	0x00000000

08005420 <I2CReadRegisterByteWithCRC.constprop.0>:
  if (msg != MSG_OK)
    err = i2cGetErrors(i2cp);
  return msg;
}

msg_t I2CReadRegisterByteWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint8_t *data) {
 8005420:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8005422:	4f5c      	ldr	r7, [pc, #368]	; (8005594 <I2CReadRegisterByteWithCRC.constprop.0+0x174>)
 8005424:	b085      	sub	sp, #20
  msg_t msg;
  i2cflags_t err;
  uint8_t tx_buffer[1] = {reg_address};
 8005426:	ad01      	add	r5, sp, #4
 8005428:	7028      	strb	r0, [r5, #0]
  uint8_t CRCInput[2];
  uint8_t crc;

  //read data from i2c bus
  i2cAcquireBus(i2cp);
  msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, 1,
 800542a:	ac02      	add	r4, sp, #8
 800542c:	1c38      	adds	r0, r7, #0
  if (msg != MSG_OK)
    err = i2cGetErrors(i2cp);
  return msg;
}

msg_t I2CReadRegisterByteWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint8_t *data) {
 800542e:	1c0e      	adds	r6, r1, #0
 8005430:	f7fe fa5e 	bl	80038f0 <chMtxLock>
  uint8_t CRCInput[2];
  uint8_t crc;

  //read data from i2c bus
  i2cAcquireBus(i2cp);
  msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, 1,
 8005434:	2101      	movs	r1, #1
 8005436:	1c22      	adds	r2, r4, #0
 8005438:	2302      	movs	r3, #2
 800543a:	1c28      	adds	r0, r5, #0
 800543c:	f7ff fa60 	bl	8004900 <i2cMasterTransmitTimeout.constprop.30>
 8005440:	1c05      	adds	r5, r0, #0
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8005442:	1c38      	adds	r0, r7, #0
 8005444:	f7fe f8e4 	bl	8003610 <chMtxUnlock>
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005448:	231c      	movs	r3, #28
				crc ^= key;
 800544a:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800544c:	b2db      	uxtb	r3, r3
 800544e:	005a      	lsls	r2, r3, #1
  if (msg != MSG_OK)
    err = i2cGetErrors(i2cp);

  //CRC check
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
 8005450:	7820      	ldrb	r0, [r4, #0]
  i2cReleaseBus(i2cp);
  if (msg != MSG_OK)
    err = i2cGetErrors(i2cp);

  //CRC check
  CRCInput[0] = (addr_bq76920 << 1) + 1;
 8005452:	a903      	add	r1, sp, #12
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005454:	b2d2      	uxtb	r2, r2
 8005456:	b25b      	sxtb	r3, r3
  if (msg != MSG_OK)
    err = i2cGetErrors(i2cp);

  //CRC check
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
 8005458:	7048      	strb	r0, [r1, #1]
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800545a:	4057      	eors	r7, r2
 800545c:	2b00      	cmp	r3, #0
 800545e:	da00      	bge.n	8005462 <I2CReadRegisterByteWithCRC.constprop.0+0x42>
 8005460:	e086      	b.n	8005570 <I2CReadRegisterByteWithCRC.constprop.0+0x150>
 8005462:	1c13      	adds	r3, r2, #0
 8005464:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005466:	005a      	lsls	r2, r3, #1
 8005468:	b2d2      	uxtb	r2, r2
 800546a:	b25b      	sxtb	r3, r3
				crc ^= key;
 800546c:	4057      	eors	r7, r2
 800546e:	2b00      	cmp	r3, #0
 8005470:	da00      	bge.n	8005474 <I2CReadRegisterByteWithCRC.constprop.0+0x54>
 8005472:	e079      	b.n	8005568 <I2CReadRegisterByteWithCRC.constprop.0+0x148>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005474:	2707      	movs	r7, #7
 8005476:	b2d2      	uxtb	r2, r2
 8005478:	407a      	eors	r2, r7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800547a:	0053      	lsls	r3, r2, #1
 800547c:	b2db      	uxtb	r3, r3
				crc ^= key;
 800547e:	405f      	eors	r7, r3
 8005480:	b252      	sxtb	r2, r2
 8005482:	7849      	ldrb	r1, [r1, #1]
 8005484:	b2ff      	uxtb	r7, r7
 8005486:	2a00      	cmp	r2, #0
 8005488:	da00      	bge.n	800548c <I2CReadRegisterByteWithCRC.constprop.0+0x6c>
 800548a:	e081      	b.n	8005590 <I2CReadRegisterByteWithCRC.constprop.0+0x170>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800548c:	2207      	movs	r2, #7
 800548e:	b2df      	uxtb	r7, r3
 8005490:	4057      	eors	r7, r2
 8005492:	09ca      	lsrs	r2, r1, #7
 8005494:	d000      	beq.n	8005498 <I2CReadRegisterByteWithCRC.constprop.0+0x78>
 8005496:	1c3b      	adds	r3, r7, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8005498:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800549a:	005a      	lsls	r2, r3, #1
 800549c:	b2d2      	uxtb	r2, r2
 800549e:	b25b      	sxtb	r3, r3
				crc ^= key;
 80054a0:	4057      	eors	r7, r2
 80054a2:	2b00      	cmp	r3, #0
 80054a4:	da00      	bge.n	80054a8 <I2CReadRegisterByteWithCRC.constprop.0+0x88>
 80054a6:	e071      	b.n	800558c <I2CReadRegisterByteWithCRC.constprop.0+0x16c>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80054a8:	2307      	movs	r3, #7
 80054aa:	b2d7      	uxtb	r7, r2
 80054ac:	407b      	eors	r3, r7
 80054ae:	064f      	lsls	r7, r1, #25
 80054b0:	d500      	bpl.n	80054b4 <I2CReadRegisterByteWithCRC.constprop.0+0x94>
 80054b2:	1c1a      	adds	r2, r3, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80054b4:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80054b6:	0053      	lsls	r3, r2, #1
 80054b8:	b2db      	uxtb	r3, r3
 80054ba:	b252      	sxtb	r2, r2
				crc ^= key;
 80054bc:	405f      	eors	r7, r3
 80054be:	2a00      	cmp	r2, #0
 80054c0:	db62      	blt.n	8005588 <I2CReadRegisterByteWithCRC.constprop.0+0x168>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80054c2:	2207      	movs	r2, #7
 80054c4:	b2df      	uxtb	r7, r3
 80054c6:	407a      	eors	r2, r7
 80054c8:	068f      	lsls	r7, r1, #26
 80054ca:	d500      	bpl.n	80054ce <I2CReadRegisterByteWithCRC.constprop.0+0xae>
 80054cc:	1c13      	adds	r3, r2, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80054ce:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80054d0:	005a      	lsls	r2, r3, #1
 80054d2:	b2d2      	uxtb	r2, r2
 80054d4:	b25b      	sxtb	r3, r3
				crc ^= key;
 80054d6:	4057      	eors	r7, r2
 80054d8:	2b00      	cmp	r3, #0
 80054da:	db53      	blt.n	8005584 <I2CReadRegisterByteWithCRC.constprop.0+0x164>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80054dc:	2307      	movs	r3, #7
 80054de:	b2d7      	uxtb	r7, r2
 80054e0:	407b      	eors	r3, r7
 80054e2:	06cf      	lsls	r7, r1, #27
 80054e4:	d500      	bpl.n	80054e8 <I2CReadRegisterByteWithCRC.constprop.0+0xc8>
 80054e6:	1c1a      	adds	r2, r3, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80054e8:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80054ea:	0053      	lsls	r3, r2, #1
 80054ec:	b2db      	uxtb	r3, r3
 80054ee:	b252      	sxtb	r2, r2
				crc ^= key;
 80054f0:	405f      	eors	r7, r3
 80054f2:	2a00      	cmp	r2, #0
 80054f4:	db44      	blt.n	8005580 <I2CReadRegisterByteWithCRC.constprop.0+0x160>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80054f6:	2207      	movs	r2, #7
 80054f8:	b2df      	uxtb	r7, r3
 80054fa:	407a      	eors	r2, r7
 80054fc:	070f      	lsls	r7, r1, #28
 80054fe:	d500      	bpl.n	8005502 <I2CReadRegisterByteWithCRC.constprop.0+0xe2>
 8005500:	1c13      	adds	r3, r2, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8005502:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005504:	005a      	lsls	r2, r3, #1
 8005506:	b2d2      	uxtb	r2, r2
 8005508:	b25b      	sxtb	r3, r3
				crc ^= key;
 800550a:	4057      	eors	r7, r2
 800550c:	2b00      	cmp	r3, #0
 800550e:	db35      	blt.n	800557c <I2CReadRegisterByteWithCRC.constprop.0+0x15c>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005510:	2307      	movs	r3, #7
 8005512:	b2d7      	uxtb	r7, r2
 8005514:	407b      	eors	r3, r7
 8005516:	074f      	lsls	r7, r1, #29
 8005518:	d500      	bpl.n	800551c <I2CReadRegisterByteWithCRC.constprop.0+0xfc>
 800551a:	1c1a      	adds	r2, r3, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800551c:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800551e:	0053      	lsls	r3, r2, #1
 8005520:	b2db      	uxtb	r3, r3
 8005522:	b252      	sxtb	r2, r2
				crc ^= key;
 8005524:	405f      	eors	r7, r3
 8005526:	2a00      	cmp	r2, #0
 8005528:	db26      	blt.n	8005578 <I2CReadRegisterByteWithCRC.constprop.0+0x158>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800552a:	2207      	movs	r2, #7
 800552c:	b2df      	uxtb	r7, r3
 800552e:	407a      	eors	r2, r7
 8005530:	078f      	lsls	r7, r1, #30
 8005532:	d500      	bpl.n	8005536 <I2CReadRegisterByteWithCRC.constprop.0+0x116>
 8005534:	1c13      	adds	r3, r2, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8005536:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8005538:	005a      	lsls	r2, r3, #1
 800553a:	b2d2      	uxtb	r2, r2
 800553c:	b25b      	sxtb	r3, r3
				crc ^= key;
 800553e:	4057      	eors	r7, r2
 8005540:	2b00      	cmp	r3, #0
 8005542:	db17      	blt.n	8005574 <I2CReadRegisterByteWithCRC.constprop.0+0x154>
 8005544:	1c13      	adds	r3, r2, #0
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8005546:	2207      	movs	r2, #7
 8005548:	b2df      	uxtb	r7, r3
 800554a:	407a      	eors	r2, r7
 800554c:	07c9      	lsls	r1, r1, #31
 800554e:	d500      	bpl.n	8005552 <I2CReadRegisterByteWithCRC.constprop.0+0x132>
 8005550:	1c13      	adds	r3, r2, #0

  //CRC check
  CRCInput[0] = (addr_bq76920 << 1) + 1;
  CRCInput[1] = rx_buffer[0];
  crc = CRC8(CRCInput, 2, 7);
  if (crc != rx_buffer[1])
 8005552:	7862      	ldrb	r2, [r4, #1]
 8005554:	b2db      	uxtb	r3, r3
 8005556:	429a      	cmp	r2, r3
 8005558:	d008      	beq.n	800556c <I2CReadRegisterByteWithCRC.constprop.0+0x14c>
    palSetPad(GPIOA, GPIOA_LED2);
 800555a:	2390      	movs	r3, #144	; 0x90
 800555c:	2240      	movs	r2, #64	; 0x40
 800555e:	05db      	lsls	r3, r3, #23
 8005560:	831a      	strh	r2, [r3, #24]
  else
    *data = rx_buffer[0];
  return msg;
}
 8005562:	1c28      	adds	r0, r5, #0
 8005564:	b005      	add	sp, #20
 8005566:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005568:	1c3a      	adds	r2, r7, #0
 800556a:	e783      	b.n	8005474 <I2CReadRegisterByteWithCRC.constprop.0+0x54>
  CRCInput[1] = rx_buffer[0];
  crc = CRC8(CRCInput, 2, 7);
  if (crc != rx_buffer[1])
    palSetPad(GPIOA, GPIOA_LED2);
  else
    *data = rx_buffer[0];
 800556c:	7030      	strb	r0, [r6, #0]
 800556e:	e7f8      	b.n	8005562 <I2CReadRegisterByteWithCRC.constprop.0+0x142>
 8005570:	1c3b      	adds	r3, r7, #0
 8005572:	e777      	b.n	8005464 <I2CReadRegisterByteWithCRC.constprop.0+0x44>
 8005574:	1c3b      	adds	r3, r7, #0
 8005576:	e7e6      	b.n	8005546 <I2CReadRegisterByteWithCRC.constprop.0+0x126>
 8005578:	1c3b      	adds	r3, r7, #0
 800557a:	e7d6      	b.n	800552a <I2CReadRegisterByteWithCRC.constprop.0+0x10a>
 800557c:	1c3a      	adds	r2, r7, #0
 800557e:	e7c7      	b.n	8005510 <I2CReadRegisterByteWithCRC.constprop.0+0xf0>
 8005580:	1c3b      	adds	r3, r7, #0
 8005582:	e7b8      	b.n	80054f6 <I2CReadRegisterByteWithCRC.constprop.0+0xd6>
 8005584:	1c3a      	adds	r2, r7, #0
 8005586:	e7a9      	b.n	80054dc <I2CReadRegisterByteWithCRC.constprop.0+0xbc>
 8005588:	1c3b      	adds	r3, r7, #0
 800558a:	e79a      	b.n	80054c2 <I2CReadRegisterByteWithCRC.constprop.0+0xa2>
 800558c:	1c3a      	adds	r2, r7, #0
 800558e:	e78b      	b.n	80054a8 <I2CReadRegisterByteWithCRC.constprop.0+0x88>
 8005590:	1c3b      	adds	r3, r7, #0
 8005592:	e77b      	b.n	800548c <I2CReadRegisterByteWithCRC.constprop.0+0x6c>
 8005594:	20000f90 	.word	0x20000f90

08005598 <memset>:
 8005598:	b570      	push	{r4, r5, r6, lr}
 800559a:	0783      	lsls	r3, r0, #30
 800559c:	d03f      	beq.n	800561e <memset+0x86>
 800559e:	1e54      	subs	r4, r2, #1
 80055a0:	2a00      	cmp	r2, #0
 80055a2:	d03b      	beq.n	800561c <memset+0x84>
 80055a4:	b2ce      	uxtb	r6, r1
 80055a6:	1c03      	adds	r3, r0, #0
 80055a8:	2503      	movs	r5, #3
 80055aa:	e003      	b.n	80055b4 <memset+0x1c>
 80055ac:	1e62      	subs	r2, r4, #1
 80055ae:	2c00      	cmp	r4, #0
 80055b0:	d034      	beq.n	800561c <memset+0x84>
 80055b2:	1c14      	adds	r4, r2, #0
 80055b4:	3301      	adds	r3, #1
 80055b6:	1e5a      	subs	r2, r3, #1
 80055b8:	7016      	strb	r6, [r2, #0]
 80055ba:	422b      	tst	r3, r5
 80055bc:	d1f6      	bne.n	80055ac <memset+0x14>
 80055be:	2c03      	cmp	r4, #3
 80055c0:	d924      	bls.n	800560c <memset+0x74>
 80055c2:	25ff      	movs	r5, #255	; 0xff
 80055c4:	400d      	ands	r5, r1
 80055c6:	022a      	lsls	r2, r5, #8
 80055c8:	4315      	orrs	r5, r2
 80055ca:	042a      	lsls	r2, r5, #16
 80055cc:	4315      	orrs	r5, r2
 80055ce:	2c0f      	cmp	r4, #15
 80055d0:	d911      	bls.n	80055f6 <memset+0x5e>
 80055d2:	1c26      	adds	r6, r4, #0
 80055d4:	3e10      	subs	r6, #16
 80055d6:	0936      	lsrs	r6, r6, #4
 80055d8:	3601      	adds	r6, #1
 80055da:	0136      	lsls	r6, r6, #4
 80055dc:	1c1a      	adds	r2, r3, #0
 80055de:	199b      	adds	r3, r3, r6
 80055e0:	6015      	str	r5, [r2, #0]
 80055e2:	6055      	str	r5, [r2, #4]
 80055e4:	6095      	str	r5, [r2, #8]
 80055e6:	60d5      	str	r5, [r2, #12]
 80055e8:	3210      	adds	r2, #16
 80055ea:	4293      	cmp	r3, r2
 80055ec:	d1f8      	bne.n	80055e0 <memset+0x48>
 80055ee:	220f      	movs	r2, #15
 80055f0:	4014      	ands	r4, r2
 80055f2:	2c03      	cmp	r4, #3
 80055f4:	d90a      	bls.n	800560c <memset+0x74>
 80055f6:	1f26      	subs	r6, r4, #4
 80055f8:	08b6      	lsrs	r6, r6, #2
 80055fa:	3601      	adds	r6, #1
 80055fc:	00b6      	lsls	r6, r6, #2
 80055fe:	1c1a      	adds	r2, r3, #0
 8005600:	199b      	adds	r3, r3, r6
 8005602:	c220      	stmia	r2!, {r5}
 8005604:	4293      	cmp	r3, r2
 8005606:	d1fc      	bne.n	8005602 <memset+0x6a>
 8005608:	2203      	movs	r2, #3
 800560a:	4014      	ands	r4, r2
 800560c:	2c00      	cmp	r4, #0
 800560e:	d005      	beq.n	800561c <memset+0x84>
 8005610:	b2c9      	uxtb	r1, r1
 8005612:	191c      	adds	r4, r3, r4
 8005614:	7019      	strb	r1, [r3, #0]
 8005616:	3301      	adds	r3, #1
 8005618:	42a3      	cmp	r3, r4
 800561a:	d1fb      	bne.n	8005614 <memset+0x7c>
 800561c:	bd70      	pop	{r4, r5, r6, pc}
 800561e:	1c14      	adds	r4, r2, #0
 8005620:	1c03      	adds	r3, r0, #0
 8005622:	e7cc      	b.n	80055be <memset+0x26>
