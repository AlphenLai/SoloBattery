
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000200 	.word	0x20000200
 8000004:	08000191 	.word	0x08000191
 8000008:	08002701 	.word	0x08002701
 800000c:	08000193 	.word	0x08000193
 8000010:	08000193 	.word	0x08000193
 8000014:	08000193 	.word	0x08000193
 8000018:	08000193 	.word	0x08000193
 800001c:	08000193 	.word	0x08000193
 8000020:	08000193 	.word	0x08000193
 8000024:	08000193 	.word	0x08000193
 8000028:	08000193 	.word	0x08000193
 800002c:	08000193 	.word	0x08000193
 8000030:	08000193 	.word	0x08000193
 8000034:	08000193 	.word	0x08000193
 8000038:	08000193 	.word	0x08000193
 800003c:	08000193 	.word	0x08000193
 8000040:	08000193 	.word	0x08000193
 8000044:	08000193 	.word	0x08000193
 8000048:	08000193 	.word	0x08000193
 800004c:	08000193 	.word	0x08000193
 8000050:	08000193 	.word	0x08000193
 8000054:	08000193 	.word	0x08000193
 8000058:	08000193 	.word	0x08000193
 800005c:	08000193 	.word	0x08000193
 8000060:	08000193 	.word	0x08000193
 8000064:	08002221 	.word	0x08002221
 8000068:	08002f31 	.word	0x08002f31
 800006c:	08002e11 	.word	0x08002e11
 8000070:	08002b91 	.word	0x08002b91
 8000074:	08000193 	.word	0x08000193
 8000078:	08000193 	.word	0x08000193
 800007c:	08000193 	.word	0x08000193
 8000080:	08001be1 	.word	0x08001be1
 8000084:	08000193 	.word	0x08000193
 8000088:	08000193 	.word	0x08000193
 800008c:	08000193 	.word	0x08000193
 8000090:	08000193 	.word	0x08000193
 8000094:	08000193 	.word	0x08000193
 8000098:	08000193 	.word	0x08000193
 800009c:	08001db1 	.word	0x08001db1
 80000a0:	08000193 	.word	0x08000193
 80000a4:	08000193 	.word	0x08000193
 80000a8:	08000193 	.word	0x08000193
 80000ac:	08000193 	.word	0x08000193
 80000b0:	08000193 	.word	0x08000193
 80000b4:	08000193 	.word	0x08000193
 80000b8:	08000193 	.word	0x08000193
 80000bc:	08000193 	.word	0x08000193

Disassembly of section .text:

080000c0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80000c0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80000c2:	4824      	ldr	r0, [pc, #144]	; (8000154 <endfiniloop+0x6>)
                msr     MSP, r0
 80000c4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80000c8:	4823      	ldr	r0, [pc, #140]	; (8000158 <endfiniloop+0xa>)
                msr     PSP, r0
 80000ca:	f380 8809 	msr	PSP, r0

                /* CPU mode initialization as configured.*/
                movs    r0, #CRT0_CONTROL_INIT
 80000ce:	2002      	movs	r0, #2
                msr     CONTROL, r0
 80000d0:	f380 8814 	msr	CONTROL, r0
                isb
 80000d4:	f3bf 8f6f 	isb	sy
                str     r0, [r1]
#endif

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 80000d8:	f003 f81a 	bl	8003110 <__core_init>
#endif

                /* Early initialization..*/
                bl      __early_init
 80000dc:	f001 fcd8 	bl	8001a90 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80000e0:	481e      	ldr	r0, [pc, #120]	; (800015c <endfiniloop+0xe>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80000e2:	491f      	ldr	r1, [pc, #124]	; (8000160 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 80000e4:	4a1b      	ldr	r2, [pc, #108]	; (8000154 <endfiniloop+0x6>)

080000e6 <msloop>:
msloop:
                cmp     r1, r2
 80000e6:	4291      	cmp	r1, r2
                bge     endmsloop
 80000e8:	da02      	bge.n	80000f0 <endmsloop>
                str     r0, [r1]
 80000ea:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000ec:	3104      	adds	r1, #4
                b       msloop
 80000ee:	e7fa      	b.n	80000e6 <msloop>

080000f0 <endmsloop>:
endmsloop:
                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80000f0:	491c      	ldr	r1, [pc, #112]	; (8000164 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 80000f2:	4a19      	ldr	r2, [pc, #100]	; (8000158 <endfiniloop+0xa>)

080000f4 <psloop>:
psloop:
                cmp     r1, r2
 80000f4:	4291      	cmp	r1, r2
                bge     endpsloop
 80000f6:	da02      	bge.n	80000fe <endpsloop>
                str     r0, [r1]
 80000f8:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 80000fa:	3104      	adds	r1, #4
                b       psloop
 80000fc:	e7fa      	b.n	80000f4 <psloop>

080000fe <endpsloop>:
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata
 80000fe:	491a      	ldr	r1, [pc, #104]	; (8000168 <endfiniloop+0x1a>)
                ldr     r2, =_data
 8000100:	4a1a      	ldr	r2, [pc, #104]	; (800016c <endfiniloop+0x1e>)
                ldr     r3, =_edata
 8000102:	4b1b      	ldr	r3, [pc, #108]	; (8000170 <endfiniloop+0x22>)

08000104 <dloop>:
dloop:
                cmp     r2, r3
 8000104:	429a      	cmp	r2, r3
                bge     enddloop
 8000106:	da04      	bge.n	8000112 <enddloop>
                ldr     r0, [r1]
 8000108:	6808      	ldr	r0, [r1, #0]
                str     r0, [r2]
 800010a:	6010      	str	r0, [r2, #0]
                adds    r1, #4
 800010c:	3104      	adds	r1, #4
                adds    r2, #4
 800010e:	3204      	adds	r2, #4
                b       dloop
 8000110:	e7f8      	b.n	8000104 <dloop>

08000112 <enddloop>:
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000112:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000114:	4917      	ldr	r1, [pc, #92]	; (8000174 <endfiniloop+0x26>)
                ldr     r2, =_bss_end
 8000116:	4a18      	ldr	r2, [pc, #96]	; (8000178 <endfiniloop+0x2a>)

08000118 <bloop>:
bloop:
                cmp     r1, r2
 8000118:	4291      	cmp	r1, r2
                bge     endbloop
 800011a:	da02      	bge.n	8000122 <endbloop>
                str     r0, [r1]
 800011c:	6008      	str	r0, [r1, #0]
                adds    r1, #4
 800011e:	3104      	adds	r1, #4
                b       bloop
 8000120:	e7fa      	b.n	8000118 <bloop>

08000122 <endbloop>:
endbloop:
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000122:	f002 ffbd 	bl	80030a0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000126:	f002 ffeb 	bl	8003100 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800012a:	4c14      	ldr	r4, [pc, #80]	; (800017c <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end
 800012c:	4d14      	ldr	r5, [pc, #80]	; (8000180 <endfiniloop+0x32>)

0800012e <initloop>:
initloop:
                cmp     r4, r5
 800012e:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000130:	da03      	bge.n	800013a <endinitloop>
                ldr     r1, [r4]
 8000132:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000134:	4788      	blx	r1
                adds    r4, #4
 8000136:	3404      	adds	r4, #4
                b       initloop
 8000138:	e7f9      	b.n	800012e <initloop>

0800013a <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 800013a:	f000 f859 	bl	80001f0 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 800013e:	4c11      	ldr	r4, [pc, #68]	; (8000184 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end
 8000140:	4d11      	ldr	r5, [pc, #68]	; (8000188 <endfiniloop+0x3a>)

08000142 <finiloop>:
finiloop:
                cmp     r4, r5
 8000142:	42ac      	cmp	r4, r5
                bge     endfiniloop
 8000144:	da03      	bge.n	800014e <endfiniloop>
                ldr     r1, [r4]
 8000146:	6821      	ldr	r1, [r4, #0]
                blx     r1
 8000148:	4788      	blx	r1
                adds    r4, #4
 800014a:	3404      	adds	r4, #4
                b       finiloop
 800014c:	e7f9      	b.n	8000142 <finiloop>

0800014e <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                ldr     r1, =__default_exit
 800014e:	490f      	ldr	r1, [pc, #60]	; (800018c <endfiniloop+0x3e>)
                bx      r1
 8000150:	4708      	bx	r1
 8000152:	0000      	.short	0x0000
                /* Interrupts are globally masked initially.*/
                cpsid   i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 8000154:	20000200 	.word	0x20000200
                msr     MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000158:	20000400 	.word	0x20000400

                /* Early initialization..*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800015c:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000160:	20000000 	.word	0x20000000
                b       msloop
endmsloop:
                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000164:	20000200 	.word	0x20000200
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata
 8000168:	080039d4 	.word	0x080039d4
                ldr     r2, =_data
 800016c:	20000400 	.word	0x20000400
                ldr     r3, =_edata
 8000170:	20000400 	.word	0x20000400

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 8000174:	20000400 	.word	0x20000400
                ldr     r2, =_bss_end
 8000178:	20000fb8 	.word	0x20000fb8
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800017c:	080000c0 	.word	0x080000c0
                ldr     r5, =__init_array_end
 8000180:	080000c0 	.word	0x080000c0
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000184:	080000c0 	.word	0x080000c0
                ldr     r5, =__fini_array_end
 8000188:	080000c0 	.word	0x080000c0
                b       finiloop
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                ldr     r1, =__default_exit
 800018c:	080030f1 	.word	0x080030f1

08000190 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000190:	e796      	b.n	80000c0 <_crt0_entry>

08000192 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000192:	f000 f800 	bl	8000196 <_unhandled_exception>

08000196 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000196:	e7fe      	b.n	8000196 <_unhandled_exception>

08000198 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, lr}
 8000198:	b5f0      	push	{r4, r5, r6, r7, lr}
                mov     r4, r8
 800019a:	4644      	mov	r4, r8
                mov     r5, r9
 800019c:	464d      	mov	r5, r9
                mov     r6, r10
 800019e:	4656      	mov	r6, sl
                mov     r7, r11
 80001a0:	465f      	mov	r7, fp
                push    {r4, r5, r6, r7}
 80001a2:	b4f0      	push	{r4, r5, r6, r7}
                
                mov     r3, sp
 80001a4:	466b      	mov	r3, sp
                str     r3, [r1, #CONTEXT_OFFSET]
 80001a6:	60cb      	str	r3, [r1, #12]
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80001a8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80001aa:	469d      	mov	sp, r3
                
                pop     {r4, r5, r6, r7}
 80001ac:	bcf0      	pop	{r4, r5, r6, r7}
                mov     r8, r4
 80001ae:	46a0      	mov	r8, r4
                mov     r9, r5
 80001b0:	46a9      	mov	r9, r5
                mov     r10, r6
 80001b2:	46b2      	mov	sl, r6
                mov     r11, r7
 80001b4:	46bb      	mov	fp, r7
                pop     {r4, r5, r6, r7, pc}
 80001b6:	bdf0      	pop	{r4, r5, r6, r7, pc}

080001b8 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80001b8:	f000 fff2 	bl	80011a0 <_dbg_check_unlock>
#endif
#if CH_DBG_STATISTICS
                bl      _stats_stop_measure_crit_thd
#endif
                cpsie   i
 80001bc:	b662      	cpsie	i
                mov     r0, r5
 80001be:	1c28      	adds	r0, r5, #0
                blx     r4
 80001c0:	47a0      	blx	r4
#if defined(_CHIBIOS_RT_CONF_)
                movs    r0, #0              /* MSG_OK */
 80001c2:	2000      	movs	r0, #0
                bl      chThdExit
 80001c4:	f001 f9c4 	bl	8001550 <chThdExit>

080001c8 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 80001c8:	f001 f802 	bl	80011d0 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 80001cc:	f001 fa40 	bl	8001650 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 80001d0:	f000 ffe6 	bl	80011a0 <_dbg_check_unlock>

080001d4 <_port_exit_from_isr>:
#if CH_DBG_STATISTICS
                bl      _stats_stop_measure_crit_thd
#endif
                .globl  _port_exit_from_isr
_port_exit_from_isr:
                ldr     r2, .L2
 80001d4:	4a01      	ldr	r2, [pc, #4]	; (80001dc <_port_exit_from_isr+0x8>)
                ldr     r3, .L3
 80001d6:	4b02      	ldr	r3, [pc, #8]	; (80001e0 <_port_exit_from_isr+0xc>)
                str     r3, [r2, #0]
 80001d8:	6013      	str	r3, [r2, #0]
#if CORTEX_ALTERNATE_SWITCH
                cpsie   i
#endif
.L1:            b       .L1
 80001da:	e7fe      	b.n	80001da <_port_exit_from_isr+0x6>
 80001dc:	e000ed04 	.word	0xe000ed04
 80001e0:	80000000 	.word	0x80000000
	...

080001f0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 80001f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80001f2:	4644      	mov	r4, r8
 80001f4:	465f      	mov	r7, fp
 80001f6:	4656      	mov	r6, sl
 80001f8:	464d      	mov	r5, r9
void hal_lld_init(void) {

  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
 80001fa:	4bd2      	ldr	r3, [pc, #840]	; (8000544 <main+0x354>)
 80001fc:	49d2      	ldr	r1, [pc, #840]	; (8000548 <main+0x358>)
 80001fe:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000200:	b4f0      	push	{r4, r5, r6, r7}
 8000202:	430a      	orrs	r2, r1
 8000204:	629a      	str	r2, [r3, #40]	; 0x28
 8000206:	22bc      	movs	r2, #188	; 0xbc
 8000208:	6a99      	ldr	r1, [r3, #40]	; 0x28
 800020a:	03d2      	lsls	r2, r2, #15
 800020c:	400a      	ands	r2, r1
 800020e:	629a      	str	r2, [r3, #40]	; 0x28
 8000210:	6a9a      	ldr	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8000212:	691a      	ldr	r2, [r3, #16]
 8000214:	2201      	movs	r2, #1
 8000216:	2000      	movs	r0, #0
 8000218:	4252      	negs	r2, r2
 800021a:	611a      	str	r2, [r3, #16]
 800021c:	691a      	ldr	r2, [r3, #16]
 800021e:	6118      	str	r0, [r3, #16]
 8000220:	691a      	ldr	r2, [r3, #16]
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000222:	49ca      	ldr	r1, [pc, #808]	; (800054c <main+0x35c>)
 8000224:	68da      	ldr	r2, [r3, #12]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000226:	2480      	movs	r4, #128	; 0x80
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000228:	430a      	orrs	r2, r1
 800022a:	60da      	str	r2, [r3, #12]
 800022c:	2280      	movs	r2, #128	; 0x80
 800022e:	68d9      	ldr	r1, [r3, #12]
 8000230:	03d2      	lsls	r2, r2, #15
 8000232:	400a      	ands	r2, r1

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8000234:	2180      	movs	r1, #128	; 0x80
  /* Reset of all peripherals.
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB(~STM32_GPIO_EN_MASK);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);
 8000236:	60da      	str	r2, [r3, #12]
 8000238:	68da      	ldr	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 800023a:	69da      	ldr	r2, [r3, #28]
 800023c:	0549      	lsls	r1, r1, #21
 800023e:	430a      	orrs	r2, r1
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000240:	49c3      	ldr	r1, [pc, #780]	; (8000550 <main+0x360>)
  rccResetAHB(~STM32_GPIO_EN_MASK);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(~RCC_APB2RSTR_DBGMCURST);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8000242:	61da      	str	r2, [r3, #28]
 8000244:	69da      	ldr	r2, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000246:	680a      	ldr	r2, [r1, #0]
 8000248:	0064      	lsls	r4, r4, #1
 800024a:	4322      	orrs	r2, r4
 800024c:	600a      	str	r2, [r1, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800024e:	22c0      	movs	r2, #192	; 0xc0
 8000250:	6a19      	ldr	r1, [r3, #32]
 8000252:	0092      	lsls	r2, r2, #2
 8000254:	400a      	ands	r2, r1
 8000256:	2180      	movs	r1, #128	; 0x80
 8000258:	b095      	sub	sp, #84	; 0x54
 800025a:	0089      	lsls	r1, r1, #2
 800025c:	428a      	cmp	r2, r1
 800025e:	d003      	beq.n	8000268 <main+0x78>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000260:	2280      	movs	r2, #128	; 0x80
 8000262:	0252      	lsls	r2, r2, #9
 8000264:	621a      	str	r2, [r3, #32]
    RCC->BDCR = 0;
 8000266:	6218      	str	r0, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8000268:	2280      	movs	r2, #128	; 0x80
 800026a:	4bb6      	ldr	r3, [pc, #728]	; (8000544 <main+0x354>)
 800026c:	0212      	lsls	r2, r2, #8
 800026e:	6a19      	ldr	r1, [r3, #32]
 8000270:	4211      	tst	r1, r2
 8000272:	d107      	bne.n	8000284 <main+0x94>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8000274:	2080      	movs	r0, #128	; 0x80
 8000276:	6a19      	ldr	r1, [r3, #32]
 8000278:	0080      	lsls	r0, r0, #2
 800027a:	4301      	orrs	r1, r0
 800027c:	6219      	str	r1, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 800027e:	6a19      	ldr	r1, [r3, #32]
 8000280:	430a      	orrs	r2, r1
 8000282:	621a      	str	r2, [r3, #32]
 * @init
 */
void dmaInit(void) {
  int i;

  dma.allocated_mask = 0U;
 8000284:	2400      	movs	r4, #0
 8000286:	4bb3      	ldr	r3, [pc, #716]	; (8000554 <main+0x364>)
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8000288:	4ab3      	ldr	r2, [pc, #716]	; (8000558 <main+0x368>)
 */
void dmaInit(void) {
  int i;

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
 800028a:	605c      	str	r4, [r3, #4]
 * @init
 */
void dmaInit(void) {
  int i;

  dma.allocated_mask = 0U;
 800028c:	601c      	str	r4, [r3, #0]
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 800028e:	6014      	str	r4, [r2, #0]
 8000290:	4ab2      	ldr	r2, [pc, #712]	; (800055c <main+0x36c>)
    dma.streams[i].func = NULL;
 8000292:	609c      	str	r4, [r3, #8]
  int i;

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8000294:	6014      	str	r4, [r2, #0]
 8000296:	4ab2      	ldr	r2, [pc, #712]	; (8000560 <main+0x370>)
    dma.streams[i].func = NULL;
 8000298:	611c      	str	r4, [r3, #16]
  int i;

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 800029a:	6014      	str	r4, [r2, #0]
 800029c:	4ab1      	ldr	r2, [pc, #708]	; (8000564 <main+0x374>)
    dma.streams[i].func = NULL;
 800029e:	619c      	str	r4, [r3, #24]
  int i;

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80002a0:	6014      	str	r4, [r2, #0]
 80002a2:	4ab1      	ldr	r2, [pc, #708]	; (8000568 <main+0x378>)
    dma.streams[i].func = NULL;
 80002a4:	621c      	str	r4, [r3, #32]
  int i;

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80002a6:	6014      	str	r4, [r2, #0]
    dma.streams[i].func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 80002a8:	2201      	movs	r2, #1

  dma.allocated_mask = 0U;
  dma.isr_mask       = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = STM32_DMA_CCR_RESET_VALUE;
    dma.streams[i].func = NULL;
 80002aa:	629c      	str	r4, [r3, #40]	; 0x28
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 80002ac:	4baf      	ldr	r3, [pc, #700]	; (800056c <main+0x37c>)
 80002ae:	4252      	negs	r2, r2
 80002b0:	605a      	str	r2, [r3, #4]
 * @notapi
 */
void irqInit(void) {

#if HAL_USE_PAL
  nvicEnableVector(EXTI0_1_IRQn, STM32_IRQ_EXTI0_1_PRIORITY);
 80002b2:	2005      	movs	r0, #5
 80002b4:	2103      	movs	r1, #3
 80002b6:	f002 fecb 	bl	8003050 <nvicEnableVector>
  nvicEnableVector(EXTI2_3_IRQn, STM32_IRQ_EXTI2_3_PRIORITY);
 80002ba:	2006      	movs	r0, #6
 80002bc:	2103      	movs	r1, #3
 80002be:	f002 fec7 	bl	8003050 <nvicEnableVector>
  nvicEnableVector(EXTI4_15_IRQn, STM32_IRQ_EXTI4_15_PRIORITY);
 80002c2:	2007      	movs	r0, #7
 80002c4:	2103      	movs	r1, #3
 80002c6:	f002 fec3 	bl	8003050 <nvicEnableVector>
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 80002ca:	2301      	movs	r3, #1
 80002cc:	4fa8      	ldr	r7, [pc, #672]	; (8000570 <main+0x380>)
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc     = ADC1;
 80002ce:	4ea9      	ldr	r6, [pc, #676]	; (8000574 <main+0x384>)
 80002d0:	703b      	strb	r3, [r7, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80002d2:	1c3b      	adds	r3, r7, #0
 80002d4:	3318      	adds	r3, #24
 80002d6:	61bb      	str	r3, [r7, #24]
  tqp->prev = (thread_t *)tqp;
 80002d8:	61fb      	str	r3, [r7, #28]
  ADCD1.dmastp  = NULL;
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 80002da:	4ba7      	ldr	r3, [pc, #668]	; (8000578 <main+0x388>)
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;

#if STM32_ADC1_IRQ_SHARED_WITH_EXTI == FALSE
  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(12, STM32_ADC_ADC1_IRQ_PRIORITY);
 80002dc:	2102      	movs	r1, #2
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 80002de:	623c      	str	r4, [r7, #32]
 80002e0:	200c      	movs	r0, #12
#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc     = ADC1;
  ADCD1.dmastp  = NULL;
  ADCD1.dmamode = STM32_DMA_CR_CHSEL(ADC1_DMA_CHANNEL) |
 80002e2:	633b      	str	r3, [r7, #48]	; 0x30
  adcp->config   = NULL;
 80002e4:	607c      	str	r4, [r7, #4]
  adcp->samples  = NULL;
 80002e6:	60bc      	str	r4, [r7, #8]
  adcp->depth    = 0;
 80002e8:	60fc      	str	r4, [r7, #12]
  adcp->grpp     = NULL;
 80002ea:	613c      	str	r4, [r7, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 80002ec:	617c      	str	r4, [r7, #20]
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc     = ADC1;
 80002ee:	62be      	str	r6, [r7, #40]	; 0x28
  ADCD1.dmastp  = NULL;
 80002f0:	62fc      	str	r4, [r7, #44]	; 0x2c
                  STM32_DMA_CR_DMEIE       | STM32_DMA_CR_TEIE;

#if STM32_ADC1_IRQ_SHARED_WITH_EXTI == FALSE
  /* The shared vector is initialized on driver initialization and never
     disabled.*/
  nvicEnableVector(12, STM32_ADC_ADC1_IRQ_PRIORITY);
 80002f2:	f002 fead 	bl	8003050 <nvicEnableVector>
#endif
#endif

  /* Calibration procedure.*/
  rccEnableADC1(true);
 80002f6:	2180      	movs	r1, #128	; 0x80
 80002f8:	4b92      	ldr	r3, [pc, #584]	; (8000544 <main+0x354>)
 80002fa:	0089      	lsls	r1, r1, #2
 80002fc:	699a      	ldr	r2, [r3, #24]
 80002fe:	430a      	orrs	r2, r1
 8000300:	619a      	str	r2, [r3, #24]
 8000302:	699b      	ldr	r3, [r3, #24]

  /* CCR setup.*/
#if STM32_ADC_SUPPORTS_PRESCALER
  ADC->CCR = STM32_ADC_PRESC << 18;
#else
  ADC->CCR = 0;
 8000304:	4b9d      	ldr	r3, [pc, #628]	; (800057c <main+0x38c>)
 8000306:	601c      	str	r4, [r3, #0]
#endif

  osalDbgAssert(ADC1->CR == 0, "invalid register state");
 8000308:	68b3      	ldr	r3, [r6, #8]
 800030a:	9300      	str	r3, [sp, #0]
 800030c:	2b00      	cmp	r3, #0
 800030e:	d000      	beq.n	8000312 <main+0x122>
 8000310:	e0c3      	b.n	800049a <main+0x2aa>
  ADC1->CR |= ADC_CR_ADCAL;
 8000312:	2280      	movs	r2, #128	; 0x80
 8000314:	68b3      	ldr	r3, [r6, #8]
 8000316:	0612      	lsls	r2, r2, #24
 8000318:	4313      	orrs	r3, r2
 800031a:	60b3      	str	r3, [r6, #8]
  osalDbgAssert(ADC1->CR != 0, "invalid register state");
 800031c:	68b3      	ldr	r3, [r6, #8]
 800031e:	2b00      	cmp	r3, #0
 8000320:	d100      	bne.n	8000324 <main+0x134>
 8000322:	e0ba      	b.n	800049a <main+0x2aa>
  while (ADC1->CR & ADC_CR_ADCAL)
 8000324:	1c33      	adds	r3, r6, #0
 8000326:	689a      	ldr	r2, [r3, #8]
 8000328:	2a00      	cmp	r2, #0
 800032a:	dbfc      	blt.n	8000326 <main+0x136>
    ;
  rccDisableADC1();
 800032c:	4b85      	ldr	r3, [pc, #532]	; (8000544 <main+0x354>)
 800032e:	4a94      	ldr	r2, [pc, #592]	; (8000580 <main+0x390>)
 8000330:	6999      	ldr	r1, [r3, #24]
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8000332:	4e94      	ldr	r6, [pc, #592]	; (8000584 <main+0x394>)
 8000334:	400a      	ands	r2, r1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000336:	4994      	ldr	r1, [pc, #592]	; (8000588 <main+0x398>)
 8000338:	619a      	str	r2, [r3, #24]
 800033a:	699a      	ldr	r2, [r3, #24]
 800033c:	468b      	mov	fp, r1
 800033e:	60f1      	str	r1, [r6, #12]
  tqp->prev = (thread_t *)tqp;
 8000340:	6131      	str	r1, [r6, #16]
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
  I2CD1.i2c    = I2C1;
 8000342:	4992      	ldr	r1, [pc, #584]	; (800058c <main+0x39c>)
  i2cp->config = NULL;
 8000344:	2500      	movs	r5, #0
 8000346:	6331      	str	r1, [r6, #48]	; 0x30

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000348:	2102      	movs	r1, #2
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 800034a:	2201      	movs	r2, #1
 800034c:	69d8      	ldr	r0, [r3, #28]
 800034e:	7032      	strb	r2, [r6, #0]
 8000350:	4308      	orrs	r0, r1
  i2cp->config = NULL;
 8000352:	6075      	str	r5, [r6, #4]
 8000354:	6175      	str	r5, [r6, #20]
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 8000356:	61f5      	str	r5, [r6, #28]
  I2CD1.i2c    = I2C1;
#if STM32_I2C_USE_DMA == TRUE
  I2CD1.dmarx  = NULL;
 8000358:	62b5      	str	r5, [r6, #40]	; 0x28
  I2CD1.dmatx  = NULL;
 800035a:	62f5      	str	r5, [r6, #44]	; 0x2c
 800035c:	61d8      	str	r0, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800035e:	488c      	ldr	r0, [pc, #560]	; (8000590 <main+0x3a0>)

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000360:	69db      	ldr	r3, [r3, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000362:	6883      	ldr	r3, [r0, #8]
 8000364:	430b      	orrs	r3, r1
 8000366:	6083      	str	r3, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000368:	4b8a      	ldr	r3, [pc, #552]	; (8000594 <main+0x3a4>)
 800036a:	488b      	ldr	r0, [pc, #556]	; (8000598 <main+0x3a8>)
 800036c:	6298      	str	r0, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800036e:	488b      	ldr	r0, [pc, #556]	; (800059c <main+0x3ac>)
 8000370:	62d8      	str	r0, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8000372:	619d      	str	r5, [r3, #24]
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8000374:	2010      	movs	r0, #16

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
  STM32_ST_TIM->CCR[0] = 0;
 8000376:	635d      	str	r5, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8000378:	60dd      	str	r5, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 800037a:	605d      	str	r5, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800037c:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 800037e:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8000380:	f002 fe66 	bl	8003050 <nvicEnableVector>
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000384:	4c86      	ldr	r4, [pc, #536]	; (80005a0 <main+0x3b0>)
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000386:	4b87      	ldr	r3, [pc, #540]	; (80005a4 <main+0x3b4>)

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8000388:	2107      	movs	r1, #7
 800038a:	61e3      	str	r3, [r4, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 800038c:	6223      	str	r3, [r4, #32]
  ch.vtlist.delta = (sysinterval_t)-1;
 800038e:	2301      	movs	r3, #1
 8000390:	425b      	negs	r3, r3
 8000392:	6263      	str	r3, [r4, #36]	; 0x24
 * @note    Internal use only.
 */
void _trace_init(void) {
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8000394:	3b0f      	subs	r3, #15
 8000396:	8723      	strh	r3, [r4, #56]	; 0x38
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8000398:	3390      	adds	r3, #144	; 0x90
 800039a:	8763      	strh	r3, [r4, #58]	; 0x3a
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 800039c:	4b82      	ldr	r3, [pc, #520]	; (80005a8 <main+0x3b8>)
 800039e:	6024      	str	r4, [r4, #0]
 80003a0:	63e3      	str	r3, [r4, #60]	; 0x3c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 80003a2:	1c2b      	adds	r3, r5, #0
  tqp->prev = (thread_t *)tqp;
 80003a4:	6064      	str	r4, [r4, #4]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 80003a6:	60a5      	str	r5, [r4, #8]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 80003a8:	8525      	strh	r5, [r4, #40]	; 0x28
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 80003aa:	3301      	adds	r3, #1
 80003ac:	011a      	lsls	r2, r3, #4
 80003ae:	18a2      	adds	r2, r4, r2
 80003b0:	3228      	adds	r2, #40	; 0x28
 80003b2:	7a10      	ldrb	r0, [r2, #8]
 80003b4:	4388      	bics	r0, r1
 80003b6:	7210      	strb	r0, [r2, #8]
  unsigned i;

  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 80003b8:	2b80      	cmp	r3, #128	; 0x80
 80003ba:	d1f6      	bne.n	80003aa <main+0x1ba>
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
 80003bc:	2524      	movs	r5, #36	; 0x24
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.nextmem = __heap_base__;
 80003be:	4a7b      	ldr	r2, [pc, #492]	; (80005ac <main+0x3bc>)
 80003c0:	487b      	ldr	r0, [pc, #492]	; (80005b0 <main+0x3c0>)
  _scheduler_init();
  _vt_init();
  _trace_init();

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  ch.dbg.isr_cnt  = (cnt_t)0;
 80003c2:	2100      	movs	r1, #0
 80003c4:	6010      	str	r0, [r2, #0]
  ch_memcore.endmem  = __heap_end__;
 80003c6:	487b      	ldr	r0, [pc, #492]	; (80005b4 <main+0x3c4>)
 80003c8:	46a9      	mov	r9, r5
 80003ca:	6050      	str	r0, [r2, #4]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80003cc:	4a7a      	ldr	r2, [pc, #488]	; (80005b8 <main+0x3c8>)
 80003ce:	487b      	ldr	r0, [pc, #492]	; (80005bc <main+0x3cc>)
  H_NEXT(&default_heap.header) = NULL;
 80003d0:	6051      	str	r1, [r2, #4]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80003d2:	6010      	str	r0, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80003d4:	1c10      	adds	r0, r2, #0
 80003d6:	300c      	adds	r0, #12
  H_NEXT(&default_heap.header) = NULL;
  H_PAGES(&default_heap.header) = 0;
 80003d8:	6091      	str	r1, [r2, #8]
  tqp->prev = (thread_t *)tqp;
 80003da:	6110      	str	r0, [r2, #16]
 80003dc:	6151      	str	r1, [r2, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80003de:	60d0      	str	r0, [r2, #12]
 80003e0:	4a77      	ldr	r2, [pc, #476]	; (80005c0 <main+0x3d0>)
 80003e2:	6321      	str	r1, [r4, #48]	; 0x30
 80003e4:	4491      	add	r9, r2
 80003e6:	464d      	mov	r5, r9
 80003e8:	1c10      	adds	r0, r2, #0
 80003ea:	6255      	str	r5, [r2, #36]	; 0x24
 80003ec:	2528      	movs	r5, #40	; 0x28
 80003ee:	3010      	adds	r0, #16
 80003f0:	6110      	str	r0, [r2, #16]
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 80003f2:	2014      	movs	r0, #20
 80003f4:	46a9      	mov	r9, r5
 80003f6:	6190      	str	r0, [r2, #24]
  mp->align = align;
 80003f8:	3810      	subs	r0, #16
 80003fa:	4684      	mov	ip, r0
 80003fc:	61d0      	str	r0, [r2, #28]
  mp->provider = provider;
 80003fe:	4871      	ldr	r0, [pc, #452]	; (80005c4 <main+0x3d4>)
 8000400:	4491      	add	r9, r2
 8000402:	6210      	str	r0, [r2, #32]
 8000404:	6390      	str	r0, [r2, #56]	; 0x38
 8000406:	1c10      	adds	r0, r2, #0
 8000408:	464d      	mov	r5, r9
 800040a:	303c      	adds	r0, #60	; 0x3c
 800040c:	63d0      	str	r0, [r2, #60]	; 0x3c
 800040e:	1c10      	adds	r0, r2, #0
 8000410:	6295      	str	r5, [r2, #40]	; 0x28
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
 8000412:	251c      	movs	r5, #28
 8000414:	3040      	adds	r0, #64	; 0x40
 8000416:	6410      	str	r0, [r2, #64]	; 0x40
 8000418:	1c10      	adds	r0, r2, #0
 800041a:	6315      	str	r5, [r2, #48]	; 0x30
  mp->align = align;
 800041c:	4665      	mov	r5, ip
 800041e:	3044      	adds	r0, #68	; 0x44
  ch.dbg.lock_cnt = (cnt_t)0;
 8000420:	6361      	str	r1, [r4, #52]	; 0x34
 8000422:	6091      	str	r1, [r2, #8]
  chDbgCheck((mp != NULL) &&
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8000424:	6151      	str	r1, [r2, #20]
 8000426:	62d1      	str	r1, [r2, #44]	; 0x2c
  mp->object_size = size;
  mp->align = align;
 8000428:	6355      	str	r5, [r2, #52]	; 0x34
 800042a:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 800042c:	6052      	str	r2, [r2, #4]
 800042e:	6450      	str	r0, [r2, #68]	; 0x44
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000430:	4a65      	ldr	r2, [pc, #404]	; (80005c8 <main+0x3d8>)
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000432:	4866      	ldr	r0, [pc, #408]	; (80005cc <main+0x3dc>)
 8000434:	50a3      	str	r3, [r4, r2]
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000436:	4a66      	ldr	r2, [pc, #408]	; (80005d0 <main+0x3e0>)
 8000438:	54a1      	strb	r1, [r4, r2]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800043a:	4a66      	ldr	r2, [pc, #408]	; (80005d4 <main+0x3e4>)
 800043c:	50a3      	str	r3, [r4, r2]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800043e:	2201      	movs	r2, #1
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8000440:	4b65      	ldr	r3, [pc, #404]	; (80005d8 <main+0x3e8>)
 8000442:	50e1      	str	r1, [r4, r3]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000444:	4b65      	ldr	r3, [pc, #404]	; (80005dc <main+0x3ec>)
 8000446:	50e1      	str	r1, [r4, r3]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000448:	4b65      	ldr	r3, [pc, #404]	; (80005e0 <main+0x3f0>)
  tp->name      = name;
 800044a:	4966      	ldr	r1, [pc, #408]	; (80005e4 <main+0x3f4>)
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800044c:	54e2      	strb	r2, [r4, r3]
  tp->name      = name;
 800044e:	4b66      	ldr	r3, [pc, #408]	; (80005e8 <main+0x3f8>)
 8000450:	50e1      	str	r1, [r4, r3]
  REG_INSERT(tp);
 8000452:	3b08      	subs	r3, #8
 8000454:	4965      	ldr	r1, [pc, #404]	; (80005ec <main+0x3fc>)
 8000456:	50e4      	str	r4, [r4, r3]
 8000458:	4b65      	ldr	r3, [pc, #404]	; (80005f0 <main+0x400>)
 800045a:	5060      	str	r0, [r4, r1]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800045c:	4965      	ldr	r1, [pc, #404]	; (80005f4 <main+0x404>)
 800045e:	4866      	ldr	r0, [pc, #408]	; (80005f8 <main+0x408>)
 8000460:	50e4      	str	r4, [r4, r3]
 8000462:	4b66      	ldr	r3, [pc, #408]	; (80005fc <main+0x40c>)
 8000464:	5021      	str	r1, [r4, r0]
  tqp->prev = (thread_t *)tqp;
 8000466:	3004      	adds	r0, #4
 8000468:	6123      	str	r3, [r4, #16]
 800046a:	6163      	str	r3, [r4, #20]
 800046c:	5021      	str	r1, [r4, r0]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 800046e:	61a3      	str	r3, [r4, #24]
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  {
    /* Setting up the base address of the static main thread stack, the
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
 8000470:	4963      	ldr	r1, [pc, #396]	; (8000600 <main+0x410>)
 8000472:	4b64      	ldr	r3, [pc, #400]	; (8000604 <main+0x414>)
 8000474:	50e1      	str	r1, [r4, r3]
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8000476:	3304      	adds	r3, #4
 8000478:	54e2      	strb	r2, [r4, r3]
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
 800047a:	4a63      	ldr	r2, [pc, #396]	; (8000608 <main+0x418>)
 800047c:	4b63      	ldr	r3, [pc, #396]	; (800060c <main+0x41c>)
 800047e:	6a11      	ldr	r1, [r2, #32]
 8000480:	400b      	ands	r3, r1
 8000482:	6213      	str	r3, [r2, #32]
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000484:	b662      	cpsie	i
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
  thread_t *tp;

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 8000486:	4b62      	ldr	r3, [pc, #392]	; (8000610 <main+0x420>)
 8000488:	1c18      	adds	r0, r3, #0
 800048a:	4699      	mov	r9, r3
 800048c:	f000 ff18 	bl	80012c0 <chRegFindThreadByWorkingArea>
 8000490:	2800      	cmp	r0, #0
 8000492:	d005      	beq.n	80004a0 <main+0x2b0>
 8000494:	485f      	ldr	r0, [pc, #380]	; (8000614 <main+0x424>)
 8000496:	f000 fe6b 	bl	8001170 <chSysHalt>
  ADC->CCR = STM32_ADC_PRESC << 18;
#else
  ADC->CCR = 0;
#endif

  osalDbgAssert(ADC1->CR == 0, "invalid register state");
 800049a:	485f      	ldr	r0, [pc, #380]	; (8000618 <main+0x428>)
 800049c:	f000 fe68 	bl	8001170 <chSysHalt>
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 80004a0:	2355      	movs	r3, #85	; 0x55
 80004a2:	464a      	mov	r2, r9
 80004a4:	5413      	strb	r3, [r2, r0]
 80004a6:	3001      	adds	r0, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80004a8:	28d8      	cmp	r0, #216	; 0xd8
 80004aa:	d1fa      	bne.n	80004a2 <main+0x2b2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80004ac:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80004ae:	f000 fe8f 	bl	80011d0 <_dbg_check_lock>
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
  thread_t *tp;

  chDbgCheckClassI();
 80004b2:	f000 fed5 	bl	8001260 <chDbgCheckClassI>
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 80004b6:	23ac      	movs	r3, #172	; 0xac
 80004b8:	464a      	mov	r2, r9
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80004ba:	4649      	mov	r1, r9
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 80004bc:	50d2      	str	r2, [r2, r3]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80004be:	326c      	adds	r2, #108	; 0x6c
 80004c0:	3b10      	subs	r3, #16
 80004c2:	50ca      	str	r2, [r1, r3]
 80004c4:	4b55      	ldr	r3, [pc, #340]	; (800061c <main+0x42c>)
 80004c6:	2280      	movs	r2, #128	; 0x80
 80004c8:	67cb      	str	r3, [r1, #124]	; 0x7c
 80004ca:	2300      	movs	r3, #0
 80004cc:	508b      	str	r3, [r1, r2]
 80004ce:	4a54      	ldr	r2, [pc, #336]	; (8000620 <main+0x430>)
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 80004d0:	464d      	mov	r5, r9
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80004d2:	4692      	mov	sl, r2
 80004d4:	228c      	movs	r2, #140	; 0x8c
 80004d6:	4650      	mov	r0, sl
 80004d8:	5088      	str	r0, [r1, r2]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 80004da:	2198      	movs	r1, #152	; 0x98
 80004dc:	4648      	mov	r0, r9
 80004de:	3a8b      	subs	r2, #139	; 0x8b
 80004e0:	5042      	str	r2, [r0, r1]
  tp->state     = CH_STATE_WTSTART;
 80004e2:	2002      	movs	r0, #2
 80004e4:	3118      	adds	r1, #24
 80004e6:	5468      	strb	r0, [r5, r1]
  tp->flags     = CH_FLAG_MODE_STATIC;
 80004e8:	3101      	adds	r1, #1
 80004ea:	546b      	strb	r3, [r5, r1]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 80004ec:	311b      	adds	r1, #27
 80004ee:	506a      	str	r2, [r5, r1]
  tp->mtxlist   = NULL;
 80004f0:	3904      	subs	r1, #4
 80004f2:	506b      	str	r3, [r5, r1]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 80004f4:	3904      	subs	r1, #4
 80004f6:	506b      	str	r3, [r5, r1]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 80004f8:	33b2      	adds	r3, #178	; 0xb2
 80004fa:	54ea      	strb	r2, [r5, r3]
  tp->name      = name;
 80004fc:	4a49      	ldr	r2, [pc, #292]	; (8000624 <main+0x434>)
 80004fe:	3b0a      	subs	r3, #10
 8000500:	50ea      	str	r2, [r5, r3]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000502:	4648      	mov	r0, r9
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000504:	22a4      	movs	r2, #164	; 0xa4
 8000506:	3b08      	subs	r3, #8
 8000508:	50ec      	str	r4, [r5, r3]
 800050a:	6963      	ldr	r3, [r4, #20]
 800050c:	3090      	adds	r0, #144	; 0x90
 800050e:	50ab      	str	r3, [r5, r2]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000510:	464a      	mov	r2, r9
 8000512:	6118      	str	r0, [r3, #16]
 8000514:	23b8      	movs	r3, #184	; 0xb8
 8000516:	32b8      	adds	r2, #184	; 0xb8
 8000518:	50ea      	str	r2, [r5, r3]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800051a:	464b      	mov	r3, r9
 800051c:	22bc      	movs	r2, #188	; 0xbc
 800051e:	33bc      	adds	r3, #188	; 0xbc
 8000520:	50ab      	str	r3, [r5, r2]
  tqp->prev = (thread_t *)tqp;
 8000522:	3204      	adds	r2, #4
 8000524:	50ab      	str	r3, [r5, r2]
 8000526:	6160      	str	r0, [r4, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
  chSchWakeupS(tp, MSG_OK);
 8000528:	f002 fef2 	bl	8003310 <chSchWakeupS.constprop.20>
  chSysUnlock();
 800052c:	f000 fea8 	bl	8001280 <chSysUnlock.lto_priv.49>
 * @api
 */
void i2cStart(I2CDriver *i2cp, const I2CConfig *config) {

  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
 8000530:	7833      	ldrb	r3, [r6, #0]
 8000532:	1e5a      	subs	r2, r3, #1
 8000534:	2a01      	cmp	r2, #1
 8000536:	d979      	bls.n	800062c <main+0x43c>
 8000538:	2b05      	cmp	r3, #5
 800053a:	d077      	beq.n	800062c <main+0x43c>
 800053c:	483a      	ldr	r0, [pc, #232]	; (8000628 <main+0x438>)
 800053e:	f000 fe17 	bl	8001170 <chSysHalt>
 8000542:	46c0      	nop			; (mov r8, r8)
 8000544:	40021000 	.word	0x40021000
 8000548:	ffa1ffff 	.word	0xffa1ffff
 800054c:	ffbfffff 	.word	0xffbfffff
 8000550:	40007000 	.word	0x40007000
 8000554:	2000046c 	.word	0x2000046c
 8000558:	40020008 	.word	0x40020008
 800055c:	4002001c 	.word	0x4002001c
 8000560:	40020030 	.word	0x40020030
 8000564:	40020044 	.word	0x40020044
 8000568:	40020058 	.word	0x40020058
 800056c:	40020000 	.word	0x40020000
 8000570:	20000578 	.word	0x20000578
 8000574:	40012400 	.word	0x40012400
 8000578:	0000258a 	.word	0x0000258a
 800057c:	40012708 	.word	0x40012708
 8000580:	fffffdff 	.word	0xfffffdff
 8000584:	20000f84 	.word	0x20000f84
 8000588:	20000f90 	.word	0x20000f90
 800058c:	40005400 	.word	0x40005400
 8000590:	40015800 	.word	0x40015800
 8000594:	40000400 	.word	0x40000400
 8000598:	0000095f 	.word	0x0000095f
 800059c:	0000ffff 	.word	0x0000ffff
 80005a0:	20000700 	.word	0x20000700
 80005a4:	2000071c 	.word	0x2000071c
 80005a8:	20000740 	.word	0x20000740
 80005ac:	20000464 	.word	0x20000464
 80005b0:	20000fb8 	.word	0x20000fb8
 80005b4:	20001000 	.word	0x20001000
 80005b8:	20000448 	.word	0x20000448
 80005bc:	08002371 	.word	0x08002371
 80005c0:	20000400 	.word	0x20000400
 80005c4:	08002311 	.word	0x08002311
 80005c8:	00000848 	.word	0x00000848
 80005cc:	20000f68 	.word	0x20000f68
 80005d0:	00000861 	.word	0x00000861
 80005d4:	0000087c 	.word	0x0000087c
 80005d8:	00000878 	.word	0x00000878
 80005dc:	00000874 	.word	0x00000874
 80005e0:	00000862 	.word	0x00000862
 80005e4:	080036a0 	.word	0x080036a0
 80005e8:	00000858 	.word	0x00000858
 80005ec:	00000868 	.word	0x00000868
 80005f0:	00000854 	.word	0x00000854
 80005f4:	20000f6c 	.word	0x20000f6c
 80005f8:	0000086c 	.word	0x0000086c
 80005fc:	20000f40 	.word	0x20000f40
 8000600:	20000200 	.word	0x20000200
 8000604:	0000085c 	.word	0x0000085c
 8000608:	e000ed00 	.word	0xe000ed00
 800060c:	ff00ffff 	.word	0xff00ffff
 8000610:	200004a0 	.word	0x200004a0
 8000614:	08003720 	.word	0x08003720
 8000618:	08003608 	.word	0x08003608
 800061c:	08001a81 	.word	0x08001a81
 8000620:	080001b9 	.word	0x080001b9
 8000624:	080036b8 	.word	0x080036b8
 8000628:	08003738 	.word	0x08003738
 800062c:	b672      	cpsid	i
 800062e:	f000 fdcf 	bl	80011d0 <_dbg_check_lock>
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 8000632:	4bd4      	ldr	r3, [pc, #848]	; (8000984 <main+0x794>)
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 8000634:	2201      	movs	r2, #1
 8000636:	6073      	str	r3, [r6, #4]
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 8000638:	6b33      	ldr	r3, [r6, #48]	; 0x30

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 800063a:	7835      	ldrb	r5, [r6, #0]
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 800063c:	4699      	mov	r9, r3

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 800063e:	681b      	ldr	r3, [r3, #0]
 8000640:	4393      	bics	r3, r2
 8000642:	464a      	mov	r2, r9
 8000644:	6013      	str	r3, [r2, #0]

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 8000646:	2d01      	cmp	r5, #1
 8000648:	d02b      	beq.n	80006a2 <main+0x4b2>
#endif /* STM32_I2C_USE_I2C4 */
  }

#if STM32_I2C_USE_DMA == TRUE
  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->RXDR);
 800064a:	464a      	mov	r2, r9
 800064c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 800064e:	3224      	adds	r2, #36	; 0x24
 8000650:	685b      	ldr	r3, [r3, #4]
 8000652:	609a      	str	r2, [r3, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->TXDR);
 8000654:	6af3      	ldr	r3, [r6, #44]	; 0x2c
 8000656:	3204      	adds	r2, #4
 8000658:	685b      	ldr	r3, [r3, #4]
 800065a:	609a      	str	r2, [r3, #8]
#endif

  /* Reset i2c peripheral, the TCIE bit will be handled separately.*/
  dp->CR1 = i2cp->config->cr1 |
 800065c:	6872      	ldr	r2, [r6, #4]
#if STM32_I2C_USE_DMA == TRUE
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;
 800065e:	4bca      	ldr	r3, [pc, #808]	; (8000988 <main+0x798>)
 8000660:	6851      	ldr	r1, [r2, #4]
 8000662:	430b      	orrs	r3, r1
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->RXDR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->TXDR);
#endif

  /* Reset i2c peripheral, the TCIE bit will be handled separately.*/
  dp->CR1 = i2cp->config->cr1 |
 8000664:	4649      	mov	r1, r9
 8000666:	600b      	str	r3, [r1, #0]
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;

  /* Setup I2C parameters.*/
  dp->TIMINGR = i2cp->config->timingr;
 8000668:	6813      	ldr	r3, [r2, #0]

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 800066a:	2201      	movs	r2, #1
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;

  /* Setup I2C parameters.*/
  dp->TIMINGR = i2cp->config->timingr;
 800066c:	610b      	str	r3, [r1, #16]

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 800066e:	680b      	ldr	r3, [r1, #0]
 8000670:	4313      	orrs	r3, r2
 8000672:	600b      	str	r3, [r1, #0]
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 8000674:	2302      	movs	r3, #2
 8000676:	7033      	strb	r3, [r6, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 8000678:	f000 fd92 	bl	80011a0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800067c:	6823      	ldr	r3, [r4, #0]
 800067e:	42a3      	cmp	r3, r4
 8000680:	d004      	beq.n	800068c <main+0x49c>
 8000682:	69a2      	ldr	r2, [r4, #24]
 8000684:	689b      	ldr	r3, [r3, #8]
 8000686:	6892      	ldr	r2, [r2, #8]
 8000688:	429a      	cmp	r2, r3
 800068a:	d33c      	bcc.n	8000706 <main+0x516>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800068c:	b662      	cpsie	i
             MEM_IS_ALIGNED(size, PORT_STACK_ALIGN) &&
             (prio <= HIGHPRIO) && (pf != NULL));

#if (CH_CFG_USE_REGISTRY == TRUE) &&                                        \
    ((CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE))
  chDbgAssert(chRegFindThreadByWorkingArea(wsp) == NULL,
 800068e:	4bbf      	ldr	r3, [pc, #764]	; (800098c <main+0x79c>)
 8000690:	1c18      	adds	r0, r3, #0
 8000692:	4698      	mov	r8, r3
 8000694:	f000 fe14 	bl	80012c0 <chRegFindThreadByWorkingArea>
 8000698:	2800      	cmp	r0, #0
 800069a:	d037      	beq.n	800070c <main+0x51c>
 800069c:	48bc      	ldr	r0, [pc, #752]	; (8000990 <main+0x7a0>)
 800069e:	f000 fd67 	bl	8001170 <chSysHalt>
  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {

#if STM32_I2C_USE_DMA == TRUE
    /* Common DMA modes.*/
    i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
 80006a2:	239a      	movs	r3, #154	; 0x9a
#endif

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {

      rccResetI2C1();
 80006a4:	2080      	movs	r0, #128	; 0x80
  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {

#if STM32_I2C_USE_DMA == TRUE
    /* Common DMA modes.*/
    i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
 80006a6:	6273      	str	r3, [r6, #36]	; 0x24
    i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
 80006a8:	3b10      	subs	r3, #16
 80006aa:	6233      	str	r3, [r6, #32]
#endif

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {

      rccResetI2C1();
 80006ac:	4bb9      	ldr	r3, [pc, #740]	; (8000994 <main+0x7a4>)
 80006ae:	0380      	lsls	r0, r0, #14
 80006b0:	691a      	ldr	r2, [r3, #16]
 80006b2:	49b9      	ldr	r1, [pc, #740]	; (8000998 <main+0x7a8>)
 80006b4:	4302      	orrs	r2, r0
 80006b6:	611a      	str	r2, [r3, #16]
 80006b8:	691a      	ldr	r2, [r3, #16]
 80006ba:	4011      	ands	r1, r2
 80006bc:	6119      	str	r1, [r3, #16]
 80006be:	691a      	ldr	r2, [r3, #16]
      rccEnableI2C1(true);
 80006c0:	69da      	ldr	r2, [r3, #28]
#if STM32_I2C_USE_DMA == TRUE
      {
        i2cp->dmarx = dmaStreamAllocI(STM32_I2C_I2C1_RX_DMA_STREAM,
 80006c2:	2103      	movs	r1, #3

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {

      rccResetI2C1();
      rccEnableI2C1(true);
 80006c4:	4302      	orrs	r2, r0
 80006c6:	61da      	str	r2, [r3, #28]
 80006c8:	69db      	ldr	r3, [r3, #28]
#if STM32_I2C_USE_DMA == TRUE
      {
        i2cp->dmarx = dmaStreamAllocI(STM32_I2C_I2C1_RX_DMA_STREAM,
 80006ca:	2002      	movs	r0, #2
 80006cc:	2200      	movs	r2, #0
 80006ce:	1c33      	adds	r3, r6, #0
 80006d0:	f001 fd3e 	bl	8002150 <dmaStreamAllocI>
 80006d4:	62b0      	str	r0, [r6, #40]	; 0x28
                                      STM32_I2C_I2C1_IRQ_PRIORITY,
                                      NULL,
                                      (void *)i2cp);
        osalDbgAssert(i2cp->dmarx != NULL, "unable to allocate stream");
 80006d6:	2800      	cmp	r0, #0
 80006d8:	d07d      	beq.n	80007d6 <main+0x5e6>
        i2cp->dmatx = dmaStreamAllocI(STM32_I2C_I2C1_TX_DMA_STREAM,
 80006da:	1c28      	adds	r0, r5, #0
 80006dc:	2103      	movs	r1, #3
 80006de:	2200      	movs	r2, #0
 80006e0:	1c33      	adds	r3, r6, #0
 80006e2:	f001 fd35 	bl	8002150 <dmaStreamAllocI>
 80006e6:	62f0      	str	r0, [r6, #44]	; 0x2c
                                      STM32_I2C_I2C1_IRQ_PRIORITY,
                                      NULL,
                                      (void *)i2cp);
        osalDbgAssert(i2cp->dmatx != NULL, "unable to allocate stream");
 80006e8:	2800      	cmp	r0, #0
 80006ea:	d074      	beq.n	80007d6 <main+0x5e6>

        i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 80006ec:	2380      	movs	r3, #128	; 0x80
 80006ee:	6a32      	ldr	r2, [r6, #32]
 80006f0:	015b      	lsls	r3, r3, #5
 80006f2:	431a      	orrs	r2, r3
 80006f4:	6232      	str	r2, [r6, #32]
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
        i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80006f6:	6a72      	ldr	r2, [r6, #36]	; 0x24
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      }
#endif /* STM32_I2C_USE_DMA == TRUE */

#if defined(STM32_I2C1_GLOBAL_NUMBER) || defined(__DOXYGEN__)
      nvicEnableVector(STM32_I2C1_GLOBAL_NUMBER, STM32_I2C_I2C1_IRQ_PRIORITY);
 80006f8:	2017      	movs	r0, #23
                                      (void *)i2cp);
        osalDbgAssert(i2cp->dmatx != NULL, "unable to allocate stream");

        i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
        i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80006fa:	4313      	orrs	r3, r2
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      }
#endif /* STM32_I2C_USE_DMA == TRUE */

#if defined(STM32_I2C1_GLOBAL_NUMBER) || defined(__DOXYGEN__)
      nvicEnableVector(STM32_I2C1_GLOBAL_NUMBER, STM32_I2C_I2C1_IRQ_PRIORITY);
 80006fc:	2103      	movs	r1, #3
                                      (void *)i2cp);
        osalDbgAssert(i2cp->dmatx != NULL, "unable to allocate stream");

        i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
        i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 80006fe:	6273      	str	r3, [r6, #36]	; 0x24
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
      }
#endif /* STM32_I2C_USE_DMA == TRUE */

#if defined(STM32_I2C1_GLOBAL_NUMBER) || defined(__DOXYGEN__)
      nvicEnableVector(STM32_I2C1_GLOBAL_NUMBER, STM32_I2C_I2C1_IRQ_PRIORITY);
 8000700:	f002 fca6 	bl	8003050 <nvicEnableVector>
 8000704:	e7a1      	b.n	800064a <main+0x45a>
 8000706:	48a5      	ldr	r0, [pc, #660]	; (800099c <main+0x7ac>)
 8000708:	f000 fd32 	bl	8001170 <chSysHalt>
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 800070c:	23a4      	movs	r3, #164	; 0xa4
    *startp++ = v;
 800070e:	2255      	movs	r2, #85	; 0x55
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000710:	005b      	lsls	r3, r3, #1
    *startp++ = v;
 8000712:	4641      	mov	r1, r8
 8000714:	540a      	strb	r2, [r1, r0]
 8000716:	3001      	adds	r0, #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8000718:	4298      	cmp	r0, r3
 800071a:	d1fa      	bne.n	8000712 <main+0x522>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800071c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800071e:	f000 fd57 	bl	80011d0 <_dbg_check_lock>
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8000722:	238e      	movs	r3, #142	; 0x8e
 8000724:	4642      	mov	r2, r8
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8000726:	4641      	mov	r1, r8
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8000728:	005b      	lsls	r3, r3, #1
 800072a:	50d2      	str	r2, [r2, r3]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 800072c:	32dc      	adds	r2, #220	; 0xdc
 800072e:	3b10      	subs	r3, #16
 8000730:	50ca      	str	r2, [r1, r3]
 8000732:	4a9b      	ldr	r2, [pc, #620]	; (80009a0 <main+0x7b0>)
 8000734:	3b20      	subs	r3, #32
 8000736:	50ca      	str	r2, [r1, r3]
 8000738:	2300      	movs	r3, #0
 800073a:	4699      	mov	r9, r3
 800073c:	4642      	mov	r2, r8
 800073e:	4649      	mov	r1, r9
 8000740:	33f0      	adds	r3, #240	; 0xf0
 8000742:	50d1      	str	r1, [r2, r3]
 8000744:	4651      	mov	r1, sl
 8000746:	330c      	adds	r3, #12
 8000748:	50d1      	str	r1, [r2, r3]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 800074a:	2284      	movs	r2, #132	; 0x84
 800074c:	4641      	mov	r1, r8
 800074e:	3b7c      	subs	r3, #124	; 0x7c
 8000750:	0052      	lsls	r2, r2, #1
 8000752:	508b      	str	r3, [r1, r2]
  tp->state     = CH_STATE_WTSTART;
 8000754:	3a07      	subs	r2, #7
 8000756:	3aff      	subs	r2, #255	; 0xff
 8000758:	4692      	mov	sl, r2
 800075a:	4650      	mov	r0, sl
 800075c:	321f      	adds	r2, #31
 800075e:	32ff      	adds	r2, #255	; 0xff
 8000760:	5488      	strb	r0, [r1, r2]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000762:	2222      	movs	r2, #34	; 0x22
 8000764:	4648      	mov	r0, r9
 8000766:	32ff      	adds	r2, #255	; 0xff
 8000768:	5488      	strb	r0, [r1, r2]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks     = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 800076a:	321b      	adds	r2, #27
 800076c:	508b      	str	r3, [r1, r2]
  tp->mtxlist   = NULL;
 800076e:	4642      	mov	r2, r8
 8000770:	4649      	mov	r1, r9
 8000772:	33b8      	adds	r3, #184	; 0xb8
 8000774:	50d1      	str	r1, [r2, r3]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000776:	3b04      	subs	r3, #4
 8000778:	50d1      	str	r1, [r2, r3]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800077a:	4641      	mov	r1, r8
 800077c:	2201      	movs	r2, #1
 800077e:	3b12      	subs	r3, #18
 8000780:	54ca      	strb	r2, [r1, r3]
  tp->name      = name;
 8000782:	4a88      	ldr	r2, [pc, #544]	; (80009a4 <main+0x7b4>)
 8000784:	3b0a      	subs	r3, #10
 8000786:	50ca      	str	r2, [r1, r3]
  REG_INSERT(tp);
 8000788:	228a      	movs	r2, #138	; 0x8a
 800078a:	3b08      	subs	r3, #8
 800078c:	50cc      	str	r4, [r1, r3]
 800078e:	6963      	ldr	r3, [r4, #20]
 8000790:	1c48      	adds	r0, r1, #1
 8000792:	0052      	lsls	r2, r2, #1
 8000794:	508b      	str	r3, [r1, r2]
 8000796:	30ff      	adds	r0, #255	; 0xff
 8000798:	4642      	mov	r2, r8
 800079a:	6118      	str	r0, [r3, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 800079c:	2394      	movs	r3, #148	; 0x94
 800079e:	3229      	adds	r2, #41	; 0x29
 80007a0:	32ff      	adds	r2, #255	; 0xff
 80007a2:	005b      	lsls	r3, r3, #1
 80007a4:	50ca      	str	r2, [r1, r3]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80007a6:	4643      	mov	r3, r8
 80007a8:	2296      	movs	r2, #150	; 0x96
 80007aa:	332d      	adds	r3, #45	; 0x2d
 80007ac:	33ff      	adds	r3, #255	; 0xff
 80007ae:	0052      	lsls	r2, r2, #1
 80007b0:	508b      	str	r3, [r1, r2]
  tqp->prev = (thread_t *)tqp;
 80007b2:	3204      	adds	r2, #4
 80007b4:	508b      	str	r3, [r1, r2]
 80007b6:	6160      	str	r0, [r4, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 80007b8:	f002 fdaa 	bl	8003310 <chSchWakeupS.constprop.20>
  chSysUnlock();
 80007bc:	f000 fd60 	bl	8001280 <chSysUnlock.lto_priv.49>
 80007c0:	b672      	cpsid	i
 80007c2:	f000 fd05 	bl	80011d0 <_dbg_check_lock>
void adcStart(ADCDriver *adcp, const ADCConfig *config) {

  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
 80007c6:	783b      	ldrb	r3, [r7, #0]
 80007c8:	4698      	mov	r8, r3
 80007ca:	3b01      	subs	r3, #1
 80007cc:	2b01      	cmp	r3, #1
 80007ce:	d905      	bls.n	80007dc <main+0x5ec>
 80007d0:	4875      	ldr	r0, [pc, #468]	; (80009a8 <main+0x7b8>)
 80007d2:	f000 fccd 	bl	8001170 <chSysHalt>
      {
        i2cp->dmarx = dmaStreamAllocI(STM32_I2C_I2C1_RX_DMA_STREAM,
                                      STM32_I2C_I2C1_IRQ_PRIORITY,
                                      NULL,
                                      (void *)i2cp);
        osalDbgAssert(i2cp->dmarx != NULL, "unable to allocate stream");
 80007d6:	4875      	ldr	r0, [pc, #468]	; (80009ac <main+0x7bc>)
 80007d8:	f000 fcca 	bl	8001170 <chSysHalt>
                "invalid state");
  adcp->config = config;
 80007dc:	464b      	mov	r3, r9
 80007de:	607b      	str	r3, [r7, #4]
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 80007e0:	4643      	mov	r3, r8
 80007e2:	2b01      	cmp	r3, #1
 80007e4:	d100      	bne.n	80007e8 <main+0x5f8>
 80007e6:	e0f7      	b.n	80009d8 <main+0x7e8>
  adc_lld_start(adcp);
  adcp->state = ADC_READY;
 80007e8:	2302      	movs	r3, #2
 80007ea:	703b      	strb	r3, [r7, #0]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80007ec:	f000 fcd8 	bl	80011a0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80007f0:	6823      	ldr	r3, [r4, #0]
 80007f2:	42a3      	cmp	r3, r4
 80007f4:	d005      	beq.n	8000802 <main+0x612>
 80007f6:	69a2      	ldr	r2, [r4, #24]
 80007f8:	689b      	ldr	r3, [r3, #8]
 80007fa:	6892      	ldr	r2, [r2, #8]
 80007fc:	429a      	cmp	r2, r3
 80007fe:	d200      	bcs.n	8000802 <main+0x612>
 8000800:	e106      	b.n	8000a10 <main+0x820>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000802:	b662      	cpsie	i

  /*
   * Activates the ADC1 driver and the temperature sensor.
   */
   adcStart(&ADCD1, NULL);
   adcSTM32SetCCR(ADC_CCR_TSEN | ADC_CCR_VREFEN);
 8000804:	22c0      	movs	r2, #192	; 0xc0
 8000806:	4b6a      	ldr	r3, [pc, #424]	; (80009b0 <main+0x7c0>)
 8000808:	0412      	lsls	r2, r2, #16
 800080a:	601a      	str	r2, [r3, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800080c:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 800080e:	f000 fcdf 	bl	80011d0 <_dbg_check_lock>

  chThdSleepMilliseconds(1000);

  //turn on all LEDs
  palClearPad(GPIOA, GPIOA_LED1);
 8000812:	2790      	movs	r7, #144	; 0x90
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8000814:	4967      	ldr	r1, [pc, #412]	; (80009b4 <main+0x7c4>)
 8000816:	2008      	movs	r0, #8
 8000818:	f000 ff7a 	bl	8001710 <chSchGoSleepTimeoutS>
 800081c:	2520      	movs	r5, #32
 */
void chThdSleep(sysinterval_t time) {

  chSysLock();
  chThdSleepS(time);
  chSysUnlock();
 800081e:	f000 fd2f 	bl	8001280 <chSysUnlock.lto_priv.49>
  palClearPad(GPIOA, GPIOA_LED2);
 8000822:	2340      	movs	r3, #64	; 0x40
   adcSTM32SetCCR(ADC_CCR_TSEN | ADC_CCR_VREFEN);

  chThdSleepMilliseconds(1000);

  //turn on all LEDs
  palClearPad(GPIOA, GPIOA_LED1);
 8000824:	05ff      	lsls	r7, r7, #23
 8000826:	837d      	strh	r5, [r7, #26]
  palClearPad(GPIOA, GPIOA_LED2);
 8000828:	469a      	mov	sl, r3
 800082a:	837b      	strh	r3, [r7, #26]
  palClearPad(GPIOA, GPIOA_LED3);
 800082c:	2380      	movs	r3, #128	; 0x80
  palClearPad(GPIOB, GPIOB_LED4);
 800082e:	2201      	movs	r2, #1
  chThdSleepMilliseconds(1000);

  //turn on all LEDs
  palClearPad(GPIOA, GPIOA_LED1);
  palClearPad(GPIOA, GPIOA_LED2);
  palClearPad(GPIOA, GPIOA_LED3);
 8000830:	837b      	strh	r3, [r7, #26]
 8000832:	4699      	mov	r9, r3
  palClearPad(GPIOB, GPIOB_LED4);
 8000834:	4b60      	ldr	r3, [pc, #384]	; (80009b8 <main+0x7c8>)
 8000836:	835a      	strh	r2, [r3, #26]
  palClearPad(GPIOB, GPIOB_LED5);
 8000838:	2202      	movs	r2, #2

  //turn on all LEDs
  palClearPad(GPIOA, GPIOA_LED1);
  palClearPad(GPIOA, GPIOA_LED2);
  palClearPad(GPIOA, GPIOA_LED3);
  palClearPad(GPIOB, GPIOB_LED4);
 800083a:	4698      	mov	r8, r3
  palClearPad(GPIOB, GPIOB_LED5);
 800083c:	835a      	strh	r2, [r3, #26]
 800083e:	b672      	cpsid	i
 8000840:	f000 fcc6 	bl	80011d0 <_dbg_check_lock>
 8000844:	495b      	ldr	r1, [pc, #364]	; (80009b4 <main+0x7c4>)
 8000846:	2008      	movs	r0, #8
 8000848:	f000 ff62 	bl	8001710 <chSchGoSleepTimeoutS>
 800084c:	f000 fd18 	bl	8001280 <chSysUnlock.lto_priv.49>

  chThdSleepMilliseconds(1000);
  //turn off all LEDs
  palSetPad(GPIOA, GPIOA_LED1);
  palSetPad(GPIOA, GPIOA_LED2);
 8000850:	4653      	mov	r3, sl
  palClearPad(GPIOB, GPIOB_LED4);
  palClearPad(GPIOB, GPIOB_LED5);

  chThdSleepMilliseconds(1000);
  //turn off all LEDs
  palSetPad(GPIOA, GPIOA_LED1);
 8000852:	833d      	strh	r5, [r7, #24]
  palSetPad(GPIOA, GPIOA_LED2);
 8000854:	833b      	strh	r3, [r7, #24]
  palSetPad(GPIOA, GPIOA_LED3);
 8000856:	464b      	mov	r3, r9
  palSetPad(GPIOB, GPIOB_LED4);
 8000858:	2201      	movs	r2, #1

  chThdSleepMilliseconds(1000);
  //turn off all LEDs
  palSetPad(GPIOA, GPIOA_LED1);
  palSetPad(GPIOA, GPIOA_LED2);
  palSetPad(GPIOA, GPIOA_LED3);
 800085a:	833b      	strh	r3, [r7, #24]
  palSetPad(GPIOB, GPIOB_LED4);
 800085c:	4643      	mov	r3, r8
 800085e:	831a      	strh	r2, [r3, #24]
  palSetPad(GPIOB, GPIOB_LED5);
 8000860:	2202      	movs	r2, #2
    CRCInput[0]=dev_address << 1;
    CRCInput[1]=reg_address;
    CRCInput[2]=data;

    //generate data sequence
    tx_buffer[0] = reg_address;
 8000862:	2028      	movs	r0, #40	; 0x28
 8000864:	831a      	strh	r2, [r3, #24]
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
    CRCInput[1]=reg_address;
 8000866:	220b      	movs	r2, #11
    CRCInput[2]=data;

    //generate data sequence
    tx_buffer[0] = reg_address;
 8000868:	a904      	add	r1, sp, #16
 800086a:	1809      	adds	r1, r1, r0
    i2cflags_t err;
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
 800086c:	2310      	movs	r3, #16
    CRCInput[1]=reg_address;
    CRCInput[2]=data;

    //generate data sequence
    tx_buffer[0] = reg_address;
 800086e:	700a      	strb	r2, [r1, #0]
    tx_buffer[1] = data;
 8000870:	2129      	movs	r1, #41	; 0x29
    i2cflags_t err;
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
 8000872:	af0f      	add	r7, sp, #60	; 0x3c
    CRCInput[1]=reg_address;
 8000874:	707a      	strb	r2, [r7, #1]
    CRCInput[2]=data;

    //generate data sequence
    tx_buffer[0] = reg_address;
    tx_buffer[1] = data;
 8000876:	aa04      	add	r2, sp, #16
 8000878:	1852      	adds	r2, r2, r1
    i2cflags_t err;
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
 800087a:	703b      	strb	r3, [r7, #0]
    CRCInput[1]=reg_address;
    CRCInput[2]=data;
 800087c:	3309      	adds	r3, #9
 800087e:	70bb      	strb	r3, [r7, #2]

    //generate data sequence
    tx_buffer[0] = reg_address;
    tx_buffer[1] = data;
 8000880:	7013      	strb	r3, [r2, #0]
    cellsVolt[4] = ADCtoVolt(cell_adc[4]);
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
 8000882:	2300      	movs	r3, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8000884:	3922      	subs	r1, #34	; 0x22
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 8000886:	9a00      	ldr	r2, [sp, #0]
 8000888:	2608      	movs	r6, #8
 800088a:	5cba      	ldrb	r2, [r7, r2]
 800088c:	2080      	movs	r0, #128	; 0x80
 800088e:	4690      	mov	r8, r2
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8000890:	1c0a      	adds	r2, r1, #0
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8000892:	005d      	lsls	r5, r3, #1
 8000894:	b2ed      	uxtb	r5, r5
				crc ^= key;
 8000896:	406a      	eors	r2, r5
 8000898:	4691      	mov	r9, r2
 800089a:	b25a      	sxtb	r2, r3
 800089c:	2a00      	cmp	r2, #0
 800089e:	db4a      	blt.n	8000936 <main+0x746>
 80008a0:	1c2b      	adds	r3, r5, #0
 80008a2:	4645      	mov	r5, r8
 80008a4:	b2da      	uxtb	r2, r3
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80008a6:	404a      	eors	r2, r1
 80008a8:	4205      	tst	r5, r0
 80008aa:	d000      	beq.n	80008ae <main+0x6be>
 80008ac:	1c13      	adds	r3, r2, #0
 80008ae:	3e01      	subs	r6, #1
 80008b0:	b2db      	uxtb	r3, r3
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 80008b2:	0840      	lsrs	r0, r0, #1
 80008b4:	2e00      	cmp	r6, #0
 80008b6:	d1eb      	bne.n	8000890 <main+0x6a0>
 80008b8:	9a00      	ldr	r2, [sp, #0]
 80008ba:	3201      	adds	r2, #1
 80008bc:	9200      	str	r2, [sp, #0]
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
 80008be:	2a03      	cmp	r2, #3
 80008c0:	d1e1      	bne.n	8000886 <main+0x696>
    CRCInput[2]=data;

    //generate data sequence
    tx_buffer[0] = reg_address;
    tx_buffer[1] = data;
    tx_buffer[2] = CRC8(CRCInput, 3, 7);
 80008c2:	212a      	movs	r1, #42	; 0x2a
 80008c4:	aa04      	add	r2, sp, #16
 80008c6:	1852      	adds	r2, r2, r1
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 80008c8:	4658      	mov	r0, fp
 80008ca:	7013      	strb	r3, [r2, #0]
 80008cc:	f000 fc98 	bl	8001200 <chMtxLock>

    //write data to i2c bus
    i2cAcquireBus(i2cp);
    msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, sizeof(tx_buffer),
 80008d0:	1c32      	adds	r2, r6, #0
 80008d2:	1c33      	adds	r3, r6, #0
 80008d4:	9900      	ldr	r1, [sp, #0]
 80008d6:	a80e      	add	r0, sp, #56	; 0x38
 80008d8:	f002 fc22 	bl	8003120 <i2cMasterTransmitTimeout.constprop.28>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 80008dc:	4658      	mov	r0, fp
 80008de:	f001 ff17 	bl	8002710 <chMtxUnlock>
    
    //Set CC_CFG to 0x19 as mentioned in datasheet
    msg = I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, CC_CFG, 0x19);

    //get gain for ADC-to-voltage conversion
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN1, &GAIN_buffer);
 80008e2:	1c39      	adds	r1, r7, #0
 80008e4:	2050      	movs	r0, #80	; 0x50
 80008e6:	f002 fd8b 	bl	8003400 <I2CReadRegisterByteWithCRC.constprop.3>
    ADCGAIN_value = (GAIN_buffer &= 0b00001100) << 1;
 80008ea:	230c      	movs	r3, #12
 80008ec:	783a      	ldrb	r2, [r7, #0]
 80008ee:	4d33      	ldr	r5, [pc, #204]	; (80009bc <main+0x7cc>)
 80008f0:	4013      	ands	r3, r2
 80008f2:	703b      	strb	r3, [r7, #0]
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN2, &GAIN_buffer);
 80008f4:	2059      	movs	r0, #89	; 0x59
    //Set CC_CFG to 0x19 as mentioned in datasheet
    msg = I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, CC_CFG, 0x19);

    //get gain for ADC-to-voltage conversion
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN1, &GAIN_buffer);
    ADCGAIN_value = (GAIN_buffer &= 0b00001100) << 1;
 80008f6:	005b      	lsls	r3, r3, #1
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN2, &GAIN_buffer);
 80008f8:	1c39      	adds	r1, r7, #0
    //Set CC_CFG to 0x19 as mentioned in datasheet
    msg = I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, CC_CFG, 0x19);

    //get gain for ADC-to-voltage conversion
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN1, &GAIN_buffer);
    ADCGAIN_value = (GAIN_buffer &= 0b00001100) << 1;
 80008fa:	702b      	strb	r3, [r5, #0]
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN2, &GAIN_buffer);
 80008fc:	f002 fd80 	bl	8003400 <I2CReadRegisterByteWithCRC.constprop.3>
    ADCGAIN_value |= (GAIN_buffer &= 0b00011111);
 8000900:	231f      	movs	r3, #31
 8000902:	783a      	ldrb	r2, [r7, #0]
 8000904:	401a      	ands	r2, r3
 8000906:	782b      	ldrb	r3, [r5, #0]
 8000908:	703a      	strb	r2, [r7, #0]
 800090a:	4313      	orrs	r3, r2
 800090c:	702b      	strb	r3, [r5, #0]
signed char ADCOFFSET_value;
volatile float BatLeft;
float BatMax;

int ADCGAINtoDec(uint8_t ADCGAIN_hex) {
  if (ADCGAIN_hex > 0x1F)
 800090e:	2b1f      	cmp	r3, #31
 8000910:	d813      	bhi.n	800093a <main+0x74a>
    return 396;
  else
    return ADCGAIN_hex + 365;
 8000912:	336e      	adds	r3, #110	; 0x6e
 8000914:	33ff      	adds	r3, #255	; 0xff
    //get gain for ADC-to-voltage conversion
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN1, &GAIN_buffer);
    ADCGAIN_value = (GAIN_buffer &= 0b00001100) << 1;
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN2, &GAIN_buffer);
    ADCGAIN_value |= (GAIN_buffer &= 0b00011111);
    GAIN = ADCGAINtoDec(ADCGAIN_value);
 8000916:	4a2a      	ldr	r2, [pc, #168]	; (80009c0 <main+0x7d0>)

    //get offet for ADC-to-voltage conversion
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCOFFSET, &ADCOFFSET_value);
 8000918:	492a      	ldr	r1, [pc, #168]	; (80009c4 <main+0x7d4>)
 800091a:	2051      	movs	r0, #81	; 0x51
    //get gain for ADC-to-voltage conversion
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN1, &GAIN_buffer);
    ADCGAIN_value = (GAIN_buffer &= 0b00001100) << 1;
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCGAIN2, &GAIN_buffer);
    ADCGAIN_value |= (GAIN_buffer &= 0b00011111);
    GAIN = ADCGAINtoDec(ADCGAIN_value);
 800091c:	6013      	str	r3, [r2, #0]

    //get offet for ADC-to-voltage conversion
    msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, ADCOFFSET, &ADCOFFSET_value);
 800091e:	f002 fd6f 	bl	8003400 <I2CReadRegisterByteWithCRC.constprop.3>
 8000922:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000924:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000926:	2b00      	cmp	r3, #0
 8000928:	d102      	bne.n	8000930 <main+0x740>
 800092a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800092c:	2b00      	cmp	r3, #0
 800092e:	d007      	beq.n	8000940 <main+0x750>
    chSysHalt("SV#4");
 8000930:	4825      	ldr	r0, [pc, #148]	; (80009c8 <main+0x7d8>)
 8000932:	f000 fc1d 	bl	8001170 <chSysHalt>
 8000936:	464b      	mov	r3, r9
 8000938:	e7b3      	b.n	80008a2 <main+0x6b2>
volatile float BatLeft;
float BatMax;

int ADCGAINtoDec(uint8_t ADCGAIN_hex) {
  if (ADCGAIN_hex > 0x1F)
    return 396;
 800093a:	23c6      	movs	r3, #198	; 0xc6
 800093c:	005b      	lsls	r3, r3, #1
 800093e:	e7ea      	b.n	8000916 <main+0x726>
  }
  _dbg_enter_lock();
 8000940:	3301      	adds	r3, #1
 8000942:	6363      	str	r3, [r4, #52]	; 0x34
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 8000944:	69a3      	ldr	r3, [r4, #24]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000946:	4921      	ldr	r1, [pc, #132]	; (80009cc <main+0x7dc>)
 8000948:	613b      	str	r3, [r7, #16]
  vtp->func = vtfunc;
 800094a:	4b21      	ldr	r3, [pc, #132]	; (80009d0 <main+0x7e0>)
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800094c:	69e2      	ldr	r2, [r4, #28]

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 800094e:	60fb      	str	r3, [r7, #12]
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000950:	4820      	ldr	r0, [pc, #128]	; (80009d4 <main+0x7e4>)
 8000952:	6a4b      	ldr	r3, [r1, #36]	; 0x24
 8000954:	b29b      	uxth	r3, r3
 8000956:	4282      	cmp	r2, r0
 8000958:	d100      	bne.n	800095c <main+0x76c>
 800095a:	e204      	b.n	8000d66 <main+0xb76>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 800095c:	21fa      	movs	r1, #250	; 0xfa
 800095e:	8d20      	ldrh	r0, [r4, #40]	; 0x28
 8000960:	0089      	lsls	r1, r1, #2
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8000962:	1a1b      	subs	r3, r3, r0
 8000964:	b29b      	uxth	r3, r3
 8000966:	1859      	adds	r1, r3, r1

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8000968:	428b      	cmp	r3, r1
 800096a:	d800      	bhi.n	800096e <main+0x77e>
 800096c:	e1ea      	b.n	8000d44 <main+0xb54>
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 800096e:	6893      	ldr	r3, [r2, #8]
      p = p->next;
 8000970:	6812      	ldr	r2, [r2, #0]

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8000972:	1ac9      	subs	r1, r1, r3
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8000974:	6893      	ldr	r3, [r2, #8]
 8000976:	4299      	cmp	r1, r3
 8000978:	d953      	bls.n	8000a22 <main+0x832>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 800097a:	42ba      	cmp	r2, r7
 800097c:	d04e      	beq.n	8000a1c <main+0x82c>

    delta -= p->delta;
 800097e:	1ac9      	subs	r1, r1, r3
    p = p->next;
 8000980:	6812      	ldr	r2, [r2, #0]
 8000982:	e7f7      	b.n	8000974 <main+0x784>
 8000984:	08003770 	.word	0x08003770
 8000988:	0000c090 	.word	0x0000c090
 800098c:	200005b8 	.word	0x200005b8
 8000990:	08003744 	.word	0x08003744
 8000994:	40021000 	.word	0x40021000
 8000998:	ffdfffff 	.word	0xffdfffff
 800099c:	0800399c 	.word	0x0800399c
 80009a0:	08002401 	.word	0x08002401
 80009a4:	080036c0 	.word	0x080036c0
 80009a8:	08003764 	.word	0x08003764
 80009ac:	08003704 	.word	0x08003704
 80009b0:	40012708 	.word	0x40012708
 80009b4:	00002710 	.word	0x00002710
 80009b8:	48000400 	.word	0x48000400
 80009bc:	2000049c 	.word	0x2000049c
 80009c0:	200005b0 	.word	0x200005b0
 80009c4:	200005ac 	.word	0x200005ac
 80009c8:	080036c8 	.word	0x080036c8
 80009cc:	40000400 	.word	0x40000400
 80009d0:	080019c1 	.word	0x080019c1
 80009d4:	2000071c 	.word	0x2000071c
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
 80009d8:	4648      	mov	r0, r9
 80009da:	4651      	mov	r1, sl
 80009dc:	4ad0      	ldr	r2, [pc, #832]	; (8000d20 <main+0xb30>)
 80009de:	1c3b      	adds	r3, r7, #0
 80009e0:	f001 fbb6 	bl	8002150 <dmaStreamAllocI>
 80009e4:	62f8      	str	r0, [r7, #44]	; 0x2c
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 80009e6:	2800      	cmp	r0, #0
 80009e8:	d015      	beq.n	8000a16 <main+0x826>
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(true);
 80009ea:	2180      	movs	r1, #128	; 0x80
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 80009ec:	6843      	ldr	r3, [r0, #4]
 80009ee:	4acd      	ldr	r2, [pc, #820]	; (8000d24 <main+0xb34>)
      rccEnableADC1(true);
 80009f0:	0089      	lsls	r1, r1, #2
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 80009f2:	609a      	str	r2, [r3, #8]
      rccEnableADC1(true);
 80009f4:	4bcc      	ldr	r3, [pc, #816]	; (8000d28 <main+0xb38>)
 80009f6:	699a      	ldr	r2, [r3, #24]
 80009f8:	430a      	orrs	r2, r1
 80009fa:	619a      	str	r2, [r3, #24]
 80009fc:	699b      	ldr	r3, [r3, #24]

      /* Clock settings.*/
      adcp->adc->CFGR2 = STM32_ADC_ADC1_CKMODE;
 80009fe:	464b      	mov	r3, r9
 8000a00:	6aba      	ldr	r2, [r7, #40]	; 0x28
 8000a02:	6113      	str	r3, [r2, #16]
    }
#endif /* STM32_ADC_USE_ADC1 */

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR = ADC_CR_ADEN;
 8000a04:	4643      	mov	r3, r8
 8000a06:	6093      	str	r3, [r2, #8]
    while (!(adcp->adc->ISR & ADC_ISR_ADRDY))
 8000a08:	6811      	ldr	r1, [r2, #0]
 8000a0a:	4219      	tst	r1, r3
 8000a0c:	d0fc      	beq.n	8000a08 <main+0x818>
 8000a0e:	e6eb      	b.n	80007e8 <main+0x5f8>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8000a10:	48c6      	ldr	r0, [pc, #792]	; (8000d2c <main+0xb3c>)
 8000a12:	f000 fbad 	bl	8001170 <chSysHalt>
    if (&ADCD1 == adcp) {
      adcp->dmastp = dmaStreamAllocI(STM32_ADC_ADC1_DMA_STREAM,
                                     STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                     (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                     (void *)adcp);
      osalDbgAssert(adcp->dmastp != NULL, "unable to allocate stream");
 8000a16:	48c6      	ldr	r0, [pc, #792]	; (8000d30 <main+0xb40>)
 8000a18:	f000 fbaa 	bl	8001170 <chSysHalt>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 8000a1c:	48c5      	ldr	r0, [pc, #788]	; (8000d34 <main+0xb44>)
 8000a1e:	f000 fba7 	bl	8001170 <chSysHalt>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8000a22:	6853      	ldr	r3, [r2, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8000a24:	920f      	str	r2, [sp, #60]	; 0x3c
  vtp->prev = vtp->next->prev;
 8000a26:	607b      	str	r3, [r7, #4]
  vtp->prev->next = vtp;
 8000a28:	601f      	str	r7, [r3, #0]
  p->prev = vtp;
 8000a2a:	6057      	str	r7, [r2, #4]
  vtp->delta = delta;
 8000a2c:	60b9      	str	r1, [r7, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8000a2e:	6893      	ldr	r3, [r2, #8]
 8000a30:	1a59      	subs	r1, r3, r1

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8000a32:	2301      	movs	r3, #1
 8000a34:	425b      	negs	r3, r3
  vtp->prev->next = vtp;
  p->prev = vtp;
  vtp->delta = delta;

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 8000a36:	6091      	str	r1, [r2, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8000a38:	6263      	str	r3, [r4, #36]	; 0x24
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000a3a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8000a3c:	69a5      	ldr	r5, [r4, #24]
 8000a3e:	2b00      	cmp	r3, #0
 8000a40:	d000      	beq.n	8000a44 <main+0x854>
 8000a42:	e1a9      	b.n	8000d98 <main+0xba8>
 8000a44:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8000a46:	2b00      	cmp	r3, #0
 8000a48:	dc00      	bgt.n	8000a4c <main+0x85c>
 8000a4a:	e1a5      	b.n	8000d98 <main+0xba8>

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8000a4c:	2220      	movs	r2, #32
 8000a4e:	2308      	movs	r3, #8
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8000a50:	6820      	ldr	r0, [r4, #0]
 8000a52:	54ab      	strb	r3, [r5, r2]

  tqp->next             = tp->queue.next;
 8000a54:	6803      	ldr	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8000a56:	605c      	str	r4, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8000a58:	6023      	str	r3, [r4, #0]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8000a5a:	2301      	movs	r3, #1
 8000a5c:	4698      	mov	r8, r3
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8000a5e:	4641      	mov	r1, r8
 8000a60:	5483      	strb	r3, [r0, r2]
 8000a62:	8f23      	ldrh	r3, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8000a64:	61a0      	str	r0, [r4, #24]
 8000a66:	420b      	tst	r3, r1
 8000a68:	d113      	bne.n	8000a92 <main+0x8a2>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8000a6a:	2607      	movs	r6, #7
 8000a6c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8000a6e:	46b4      	mov	ip, r6
 8000a70:	7819      	ldrb	r1, [r3, #0]
 8000a72:	43b1      	bics	r1, r6
 8000a74:	4646      	mov	r6, r8
 8000a76:	430e      	orrs	r6, r1
 8000a78:	701e      	strb	r6, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8000a7a:	4666      	mov	r6, ip
 8000a7c:	5caa      	ldrb	r2, [r5, r2]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8000a7e:	6098      	str	r0, [r3, #8]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8000a80:	00d1      	lsls	r1, r2, #3
 8000a82:	781a      	ldrb	r2, [r3, #0]
 8000a84:	4032      	ands	r2, r6
 8000a86:	430a      	orrs	r2, r1
 8000a88:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8000a8a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000a8c:	60da      	str	r2, [r3, #12]
    trace_next();
 8000a8e:	f000 fb57 	bl	8001140 <trace_next.lto_priv.45>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8000a92:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000a96:	69ea      	ldr	r2, [r5, #28]
 8000a98:	3b24      	subs	r3, #36	; 0x24
 8000a9a:	429a      	cmp	r2, r3
 8000a9c:	d900      	bls.n	8000aa0 <main+0x8b0>
 8000a9e:	e1b1      	b.n	8000e04 <main+0xc14>
 8000aa0:	69a0      	ldr	r0, [r4, #24]
 8000aa2:	1c29      	adds	r1, r5, #0
 8000aa4:	f7ff fb78 	bl	8000198 <_port_switch>
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000aa8:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8000aaa:	2800      	cmp	r0, #0
 8000aac:	da00      	bge.n	8000ab0 <main+0x8c0>
 8000aae:	e1a6      	b.n	8000dfe <main+0xc0e>
 8000ab0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8000ab2:	2b00      	cmp	r3, #0
 8000ab4:	dc00      	bgt.n	8000ab8 <main+0x8c8>
 8000ab6:	e1a2      	b.n	8000dfe <main+0xc0e>
  if (TIME_INFINITE != timeout) {
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt)) {
 8000ab8:	9b12      	ldr	r3, [sp, #72]	; 0x48
 8000aba:	2b00      	cmp	r3, #0
 8000abc:	d012      	beq.n	8000ae4 <main+0x8f4>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8000abe:	69e3      	ldr	r3, [r4, #28]
 8000ac0:	42bb      	cmp	r3, r7
 8000ac2:	d100      	bne.n	8000ac6 <main+0x8d6>
 8000ac4:	e16b      	b.n	8000d9e <main+0xbae>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8000ac6:	687a      	ldr	r2, [r7, #4]
 8000ac8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000aca:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8000acc:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8000ace:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8000ad0:	2200      	movs	r2, #0
 8000ad2:	60fa      	str	r2, [r7, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8000ad4:	4a98      	ldr	r2, [pc, #608]	; (8000d38 <main+0xb48>)
 8000ad6:	4293      	cmp	r3, r2
 8000ad8:	d004      	beq.n	8000ae4 <main+0x8f4>
      vtp->next->delta += vtp->delta;
 8000ada:	68b9      	ldr	r1, [r7, #8]
 8000adc:	689a      	ldr	r2, [r3, #8]
 8000ade:	468c      	mov	ip, r1
 8000ae0:	4462      	add	r2, ip
 8000ae2:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000ae4:	2800      	cmp	r0, #0
 8000ae6:	d000      	beq.n	8000aea <main+0x8fa>
 8000ae8:	e117      	b.n	8000d1a <main+0xb2a>
 8000aea:	6823      	ldr	r3, [r4, #0]
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8000aec:	6360      	str	r0, [r4, #52]	; 0x34
 8000aee:	42a3      	cmp	r3, r4
 8000af0:	d005      	beq.n	8000afe <main+0x90e>
 8000af2:	69a2      	ldr	r2, [r4, #24]
 8000af4:	689b      	ldr	r3, [r3, #8]
 8000af6:	6892      	ldr	r2, [r2, #8]
 8000af8:	429a      	cmp	r2, r3
 8000afa:	d200      	bcs.n	8000afe <main+0x90e>
 8000afc:	e185      	b.n	8000e0a <main+0xc1a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000afe:	b662      	cpsie	i
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8000b00:	2501      	movs	r5, #1
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000b02:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000b04:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000b06:	2b00      	cmp	r3, #0
 8000b08:	d000      	beq.n	8000b0c <main+0x91c>
 8000b0a:	e711      	b.n	8000930 <main+0x740>
 8000b0c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8000b0e:	2b00      	cmp	r3, #0
 8000b10:	d000      	beq.n	8000b14 <main+0x924>
 8000b12:	e70d      	b.n	8000930 <main+0x740>
 8000b14:	21fa      	movs	r1, #250	; 0xfa
 8000b16:	2008      	movs	r0, #8
 8000b18:	0089      	lsls	r1, r1, #2
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8000b1a:	6365      	str	r5, [r4, #52]	; 0x34
 8000b1c:	f000 fdf8 	bl	8001710 <chSchGoSleepTimeoutS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000b20:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000b22:	2b00      	cmp	r3, #0
 8000b24:	d000      	beq.n	8000b28 <main+0x938>
 8000b26:	e0f8      	b.n	8000d1a <main+0xb2a>
 8000b28:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8000b2a:	2a00      	cmp	r2, #0
 8000b2c:	dc00      	bgt.n	8000b30 <main+0x940>
 8000b2e:	e0f4      	b.n	8000d1a <main+0xb2a>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8000b30:	6363      	str	r3, [r4, #52]	; 0x34
 8000b32:	6823      	ldr	r3, [r4, #0]
 8000b34:	42a3      	cmp	r3, r4
 8000b36:	d005      	beq.n	8000b44 <main+0x954>
 8000b38:	69a2      	ldr	r2, [r4, #24]
 8000b3a:	689b      	ldr	r3, [r3, #8]
 8000b3c:	6892      	ldr	r2, [r2, #8]
 8000b3e:	429a      	cmp	r2, r3
 8000b40:	d200      	bcs.n	8000b44 <main+0x954>
 8000b42:	e162      	b.n	8000e0a <main+0xc1a>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000b44:	b662      	cpsie	i
    // volatile float battery_percentage;

    volatile uint16_t foo;
    volatile uint8_t cchi, cclo;
    volatile int16_t cc_adc;
    volatile bool cc_ok = false;
 8000b46:	ab04      	add	r3, sp, #16
 8000b48:	469c      	mov	ip, r3
 8000b4a:	2611      	movs	r6, #17
 8000b4c:	2200      	movs	r2, #0
 8000b4e:	4466      	add	r6, ip
 8000b50:	7032      	strb	r2, [r6, #0]
 8000b52:	4694      	mov	ip, r2
    i2cflags_t err;
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
 8000b54:	2210      	movs	r2, #16
    CRCInput[1]=reg_address;
    CRCInput[2]=data;

    //generate data sequence
    tx_buffer[0] = reg_address;
 8000b56:	2320      	movs	r3, #32
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
    CRCInput[1]=reg_address;
 8000b58:	2105      	movs	r1, #5
    i2cflags_t err;
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
 8000b5a:	a80d      	add	r0, sp, #52	; 0x34
 8000b5c:	7002      	strb	r2, [r0, #0]
    CRCInput[1]=reg_address;
    CRCInput[2]=data;
 8000b5e:	2242      	movs	r2, #66	; 0x42
 8000b60:	9600      	str	r6, [sp, #0]

    //generate data sequence
    tx_buffer[0] = reg_address;
 8000b62:	ae04      	add	r6, sp, #16
 8000b64:	18f6      	adds	r6, r6, r3
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
    CRCInput[1]=reg_address;
 8000b66:	7041      	strb	r1, [r0, #1]
    CRCInput[2]=data;

    //generate data sequence
    tx_buffer[0] = reg_address;
 8000b68:	7031      	strb	r1, [r6, #0]
    tx_buffer[1] = data;
 8000b6a:	ab04      	add	r3, sp, #16
 8000b6c:	311c      	adds	r1, #28
 8000b6e:	185b      	adds	r3, r3, r1
 8000b70:	701a      	strb	r2, [r3, #0]
    cellsVolt[4] = ADCtoVolt(cell_adc[4]);
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
 8000b72:	4663      	mov	r3, ip
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
    CRCInput[1]=reg_address;
    CRCInput[2]=data;
 8000b74:	7082      	strb	r2, [r0, #2]
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8000b76:	391a      	subs	r1, #26
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 8000b78:	4662      	mov	r2, ip
 8000b7a:	5c82      	ldrb	r2, [r0, r2]
 8000b7c:	1c16      	adds	r6, r2, #0
 8000b7e:	2208      	movs	r2, #8
 8000b80:	4690      	mov	r8, r2
 8000b82:	3278      	adds	r2, #120	; 0x78
 8000b84:	4692      	mov	sl, r2
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8000b86:	005a      	lsls	r2, r3, #1
 8000b88:	b2d2      	uxtb	r2, r2
 8000b8a:	b25b      	sxtb	r3, r3
 8000b8c:	4691      	mov	r9, r2
				crc ^= key;
 8000b8e:	404a      	eors	r2, r1
 8000b90:	2b00      	cmp	r3, #0
 8000b92:	da00      	bge.n	8000b96 <main+0x9a6>
 8000b94:	e0b9      	b.n	8000d0a <main+0xb1a>
 8000b96:	464b      	mov	r3, r9
 8000b98:	b2da      	uxtb	r2, r3
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8000b9a:	404a      	eors	r2, r1
 8000b9c:	4691      	mov	r9, r2
 8000b9e:	4652      	mov	r2, sl
 8000ba0:	4216      	tst	r6, r2
 8000ba2:	d000      	beq.n	8000ba6 <main+0x9b6>
 8000ba4:	464b      	mov	r3, r9
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 8000ba6:	4652      	mov	r2, sl
 8000ba8:	0852      	lsrs	r2, r2, #1
 8000baa:	4692      	mov	sl, r2
 8000bac:	2201      	movs	r2, #1
 8000bae:	4252      	negs	r2, r2
 8000bb0:	4691      	mov	r9, r2
 8000bb2:	44c8      	add	r8, r9
 8000bb4:	4642      	mov	r2, r8
 8000bb6:	b2db      	uxtb	r3, r3
 8000bb8:	2a00      	cmp	r2, #0
 8000bba:	d1e4      	bne.n	8000b86 <main+0x996>
 8000bbc:	3201      	adds	r2, #1
 8000bbe:	4691      	mov	r9, r2
 8000bc0:	44cc      	add	ip, r9
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
 8000bc2:	4662      	mov	r2, ip
 8000bc4:	2a03      	cmp	r2, #3
 8000bc6:	d1d7      	bne.n	8000b78 <main+0x988>
    CRCInput[2]=data;

    //generate data sequence
    tx_buffer[0] = reg_address;
    tx_buffer[1] = data;
    tx_buffer[2] = CRC8(CRCInput, 3, 7);
 8000bc8:	2122      	movs	r1, #34	; 0x22
 8000bca:	aa04      	add	r2, sp, #16
 8000bcc:	1852      	adds	r2, r2, r1
 8000bce:	7013      	strb	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000bd0:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000bd2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000bd4:	2b00      	cmp	r3, #0
 8000bd6:	d000      	beq.n	8000bda <main+0x9ea>
 8000bd8:	e6aa      	b.n	8000930 <main+0x740>
 8000bda:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8000bdc:	2b00      	cmp	r3, #0
 8000bde:	d000      	beq.n	8000be2 <main+0x9f2>
 8000be0:	e6a6      	b.n	8000930 <main+0x740>
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8000be2:	4658      	mov	r0, fp
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8000be4:	6365      	str	r5, [r4, #52]	; 0x34
 8000be6:	f001 fe53 	bl	8002890 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000bea:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000bec:	2b00      	cmp	r3, #0
 8000bee:	d000      	beq.n	8000bf2 <main+0xa02>
 8000bf0:	e093      	b.n	8000d1a <main+0xb2a>
 8000bf2:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8000bf4:	2b00      	cmp	r3, #0
 8000bf6:	dc00      	bgt.n	8000bfa <main+0xa0a>
 8000bf8:	e08f      	b.n	8000d1a <main+0xb2a>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8000bfa:	4643      	mov	r3, r8
 8000bfc:	6363      	str	r3, [r4, #52]	; 0x34
 8000bfe:	6823      	ldr	r3, [r4, #0]
 8000c00:	42a3      	cmp	r3, r4
 8000c02:	d005      	beq.n	8000c10 <main+0xa20>
 8000c04:	69a2      	ldr	r2, [r4, #24]
 8000c06:	689b      	ldr	r3, [r3, #8]
 8000c08:	6892      	ldr	r2, [r2, #8]
 8000c0a:	429a      	cmp	r2, r3
 8000c0c:	d200      	bcs.n	8000c10 <main+0xa20>
 8000c0e:	e081      	b.n	8000d14 <main+0xb24>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000c10:	b662      	cpsie	i

    //write data to i2c bus
    i2cAcquireBus(i2cp);
    msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, sizeof(tx_buffer),
 8000c12:	2200      	movs	r2, #0
 8000c14:	2103      	movs	r1, #3
 8000c16:	1c13      	adds	r3, r2, #0
 8000c18:	a80c      	add	r0, sp, #48	; 0x30
 8000c1a:	f002 fa81 	bl	8003120 <i2cMasterTransmitTimeout.constprop.28>
 8000c1e:	4658      	mov	r0, fp
 8000c20:	f001 fd76 	bl	8002710 <chMtxUnlock>
    uint8_t enableCCincontinuous = 0|(1<<CC_EN);
    enableCCincontinuous|=(1<<DSG_ON);
    enableCCincontinuous&=0xff|(0<<CHG_ON);
    I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, SYS_CTRL2, enableCCincontinuous);

    if (palReadPad(GPIOA, GPIOA_ALERT))
 8000c24:	2390      	movs	r3, #144	; 0x90
 8000c26:	2210      	movs	r2, #16
 8000c28:	05db      	lsls	r3, r3, #23
 8000c2a:	691b      	ldr	r3, [r3, #16]
 8000c2c:	4013      	ands	r3, r2
 8000c2e:	d06e      	beq.n	8000d0e <main+0xb1e>
      cc_ok = true;
 8000c30:	9b00      	ldr	r3, [sp, #0]
 8000c32:	701d      	strb	r5, [r3, #0]
    else
      cc_ok = false;

    if(cc_ok)
 8000c34:	9b00      	ldr	r3, [sp, #0]
 8000c36:	781b      	ldrb	r3, [r3, #0]
 8000c38:	2b00      	cmp	r3, #0
 8000c3a:	d100      	bne.n	8000c3e <main+0xa4e>
 8000c3c:	e761      	b.n	8000b02 <main+0x912>
}

msg_t I2CReadRegisterWordWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint16_t *data) {
    msg_t msg;
    i2cflags_t err;
    uint8_t tx_buffer[1] = {reg_address};
 8000c3e:	ab05      	add	r3, sp, #20
 8000c40:	4699      	mov	r9, r3
 8000c42:	2332      	movs	r3, #50	; 0x32
 8000c44:	464a      	mov	r2, r9
    uint8_t rx_buffer[4];
    volatile uint8_t CRCInput[2];
    volatile uint8_t crc[2];
    volatile bool condition1 = false, condition2 = false;
 8000c46:	a904      	add	r1, sp, #16
}

msg_t I2CReadRegisterWordWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint16_t *data) {
    msg_t msg;
    i2cflags_t err;
    uint8_t tx_buffer[1] = {reg_address};
 8000c48:	7013      	strb	r3, [r2, #0]
    uint8_t rx_buffer[4];
    volatile uint8_t CRCInput[2];
    volatile uint8_t crc[2];
    volatile bool condition1 = false, condition2 = false;
 8000c4a:	468c      	mov	ip, r1
 8000c4c:	2212      	movs	r2, #18
 8000c4e:	2300      	movs	r3, #0
 8000c50:	4462      	add	r2, ip
 8000c52:	7013      	strb	r3, [r2, #0]
 8000c54:	2213      	movs	r2, #19
 8000c56:	4462      	add	r2, ip
 8000c58:	7013      	strb	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c5a:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000c5c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000c5e:	2b00      	cmp	r3, #0
 8000c60:	d000      	beq.n	8000c64 <main+0xa74>
 8000c62:	e665      	b.n	8000930 <main+0x740>
 8000c64:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8000c66:	2b00      	cmp	r3, #0
 8000c68:	d000      	beq.n	8000c6c <main+0xa7c>
 8000c6a:	e661      	b.n	8000930 <main+0x740>
 8000c6c:	4658      	mov	r0, fp
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8000c6e:	6365      	str	r5, [r4, #52]	; 0x34
 8000c70:	f001 fe0e 	bl	8002890 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000c74:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000c76:	2b00      	cmp	r3, #0
 8000c78:	d14f      	bne.n	8000d1a <main+0xb2a>
 8000c7a:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8000c7c:	2a00      	cmp	r2, #0
 8000c7e:	dd4c      	ble.n	8000d1a <main+0xb2a>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8000c80:	6363      	str	r3, [r4, #52]	; 0x34
 8000c82:	6823      	ldr	r3, [r4, #0]
 8000c84:	42a3      	cmp	r3, r4
 8000c86:	d004      	beq.n	8000c92 <main+0xaa2>
 8000c88:	69a2      	ldr	r2, [r4, #24]
 8000c8a:	689b      	ldr	r3, [r3, #8]
 8000c8c:	6892      	ldr	r2, [r2, #8]
 8000c8e:	429a      	cmp	r2, r3
 8000c90:	d340      	bcc.n	8000d14 <main+0xb24>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000c92:	b662      	cpsie	i

    //read data from i2c bus
    i2cAcquireBus(i2cp);
    msg = i2cMasterTransmitTimeout(&I2CD1, addr_bq76920, tx_buffer, 1,
 8000c94:	2304      	movs	r3, #4
 8000c96:	1c3a      	adds	r2, r7, #0
 8000c98:	2101      	movs	r1, #1
 8000c9a:	4648      	mov	r0, r9
 8000c9c:	f002 fa40 	bl	8003120 <i2cMasterTransmitTimeout.constprop.28>
 8000ca0:	4658      	mov	r0, fp
 8000ca2:	f001 fd35 	bl	8002710 <chMtxUnlock>
    i2cReleaseBus(i2cp);
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check for first byte
    CRCInput[0] = (addr_bq76920 << 1) + 1;
 8000ca6:	2311      	movs	r3, #17
 8000ca8:	a809      	add	r0, sp, #36	; 0x24
 8000caa:	7003      	strb	r3, [r0, #0]
	  CRCInput[1] = rx_buffer[0];
 8000cac:	783b      	ldrb	r3, [r7, #0]
    cellsVolt[4] = ADCtoVolt(cell_adc[4]);
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
 8000cae:	2200      	movs	r2, #0
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check for first byte
    CRCInput[0] = (addr_bq76920 << 1) + 1;
	  CRCInput[1] = rx_buffer[0];
 8000cb0:	9302      	str	r3, [sp, #8]
 8000cb2:	7043      	strb	r3, [r0, #1]
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8000cb4:	2307      	movs	r3, #7
 8000cb6:	9301      	str	r3, [sp, #4]
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 8000cb8:	4643      	mov	r3, r8
 8000cba:	5cc3      	ldrb	r3, [r0, r3]
 8000cbc:	9303      	str	r3, [sp, #12]
 8000cbe:	2308      	movs	r3, #8
 8000cc0:	4699      	mov	r9, r3
 8000cc2:	3378      	adds	r3, #120	; 0x78
 8000cc4:	469a      	mov	sl, r3
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8000cc6:	0053      	lsls	r3, r2, #1
				crc ^= key;
 8000cc8:	9901      	ldr	r1, [sp, #4]
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8000cca:	b2db      	uxtb	r3, r3
 8000ccc:	b252      	sxtb	r2, r2
				crc ^= key;
 8000cce:	4059      	eors	r1, r3
 8000cd0:	2a00      	cmp	r2, #0
 8000cd2:	da00      	bge.n	8000cd6 <main+0xae6>
 8000cd4:	1c0b      	adds	r3, r1, #0
 8000cd6:	4656      	mov	r6, sl
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8000cd8:	9901      	ldr	r1, [sp, #4]
 8000cda:	b2da      	uxtb	r2, r3
 8000cdc:	404a      	eors	r2, r1
 8000cde:	9903      	ldr	r1, [sp, #12]
 8000ce0:	4231      	tst	r1, r6
 8000ce2:	d000      	beq.n	8000ce6 <main+0xaf6>
 8000ce4:	1c13      	adds	r3, r2, #0
 8000ce6:	b2da      	uxtb	r2, r3
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 8000ce8:	4653      	mov	r3, sl
 8000cea:	085b      	lsrs	r3, r3, #1
 8000cec:	469a      	mov	sl, r3
 8000cee:	2301      	movs	r3, #1
 8000cf0:	425b      	negs	r3, r3
 8000cf2:	469c      	mov	ip, r3
 8000cf4:	44e1      	add	r9, ip
 8000cf6:	464b      	mov	r3, r9
 8000cf8:	2b00      	cmp	r3, #0
 8000cfa:	d1e4      	bne.n	8000cc6 <main+0xad6>
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
 8000cfc:	4643      	mov	r3, r8
 8000cfe:	2b01      	cmp	r3, #1
 8000d00:	d100      	bne.n	8000d04 <main+0xb14>
 8000d02:	e085      	b.n	8000e10 <main+0xc20>
 8000d04:	2301      	movs	r3, #1
 8000d06:	4698      	mov	r8, r3
 8000d08:	e7d6      	b.n	8000cb8 <main+0xac8>
 8000d0a:	1c13      	adds	r3, r2, #0
 8000d0c:	e744      	b.n	8000b98 <main+0x9a8>
    I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, SYS_CTRL2, enableCCincontinuous);

    if (palReadPad(GPIOA, GPIOA_ALERT))
      cc_ok = true;
    else
      cc_ok = false;
 8000d0e:	9a00      	ldr	r2, [sp, #0]
 8000d10:	7013      	strb	r3, [r2, #0]
 8000d12:	e78f      	b.n	8000c34 <main+0xa44>
 8000d14:	4809      	ldr	r0, [pc, #36]	; (8000d3c <main+0xb4c>)
 8000d16:	f000 fa2b 	bl	8001170 <chSysHalt>
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 8000d1a:	4809      	ldr	r0, [pc, #36]	; (8000d40 <main+0xb50>)
 8000d1c:	f000 fa28 	bl	8001170 <chSysHalt>
 8000d20:	080029f1 	.word	0x080029f1
 8000d24:	40012440 	.word	0x40012440
 8000d28:	40021000 	.word	0x40021000
 8000d2c:	0800372c 	.word	0x0800372c
 8000d30:	08003680 	.word	0x08003680
 8000d34:	08003758 	.word	0x08003758
 8000d38:	2000071c 	.word	0x2000071c
 8000d3c:	080036f8 	.word	0x080036f8
 8000d40:	080036f0 	.word	0x080036f0
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 8000d44:	6893      	ldr	r3, [r2, #8]
 8000d46:	4299      	cmp	r1, r3
 8000d48:	d300      	bcc.n	8000d4c <main+0xb5c>
 8000d4a:	e613      	b.n	8000974 <main+0x784>
 8000d4c:	4db2      	ldr	r5, [pc, #712]	; (8001018 <main+0xe28>)
 8000d4e:	1e0b      	subs	r3, r1, #0
 8000d50:	42ab      	cmp	r3, r5
 8000d52:	d900      	bls.n	8000d56 <main+0xb66>
 8000d54:	1c2b      	adds	r3, r5, #0

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8000d56:	18c3      	adds	r3, r0, r3
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000d58:	48b0      	ldr	r0, [pc, #704]	; (800101c <main+0xe2c>)
 8000d5a:	b29b      	uxth	r3, r3
 8000d5c:	68c5      	ldr	r5, [r0, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000d5e:	07ad      	lsls	r5, r5, #30
 8000d60:	d514      	bpl.n	8000d8c <main+0xb9c>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000d62:	6343      	str	r3, [r0, #52]	; 0x34
 8000d64:	e606      	b.n	8000974 <main+0x784>
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 8000d66:	22fa      	movs	r2, #250	; 0xfa
 8000d68:	0092      	lsls	r2, r2, #2
 8000d6a:	4694      	mov	ip, r2
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8000d6c:	900f      	str	r0, [sp, #60]	; 0x3c
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8000d6e:	6078      	str	r0, [r7, #4]
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000d70:	2002      	movs	r0, #2
      vtp->delta = delay;
 8000d72:	60ba      	str	r2, [r7, #8]
 8000d74:	68ca      	ldr	r2, [r1, #12]
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 8000d76:	8523      	strh	r3, [r4, #40]	; 0x28
 8000d78:	4463      	add	r3, ip
      ch.vtlist.next = vtp;
 8000d7a:	61e7      	str	r7, [r4, #28]
      ch.vtlist.prev = vtp;
 8000d7c:	6227      	str	r7, [r4, #32]
 8000d7e:	b29b      	uxth	r3, r3
 8000d80:	4002      	ands	r2, r0
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000d82:	d106      	bne.n	8000d92 <main+0xba2>
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000d84:	634b      	str	r3, [r1, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000d86:	610a      	str	r2, [r1, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000d88:	60c8      	str	r0, [r1, #12]
 8000d8a:	e656      	b.n	8000a3a <main+0x84a>
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000d8c:	48a4      	ldr	r0, [pc, #656]	; (8001020 <main+0xe30>)
 8000d8e:	f000 f9ef 	bl	8001170 <chSysHalt>
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000d92:	48a4      	ldr	r0, [pc, #656]	; (8001024 <main+0xe34>)
 8000d94:	f000 f9ec 	bl	8001170 <chSysHalt>
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#11");
 8000d98:	48a3      	ldr	r0, [pc, #652]	; (8001028 <main+0xe38>)
 8000d9a:	f000 f9e9 	bl	8001170 <chSysHalt>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8000d9e:	683b      	ldr	r3, [r7, #0]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000da0:	4aa2      	ldr	r2, [pc, #648]	; (800102c <main+0xe3c>)

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8000da2:	61e3      	str	r3, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8000da4:	605a      	str	r2, [r3, #4]
  vtp->func = NULL;
 8000da6:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000da8:	49a0      	ldr	r1, [pc, #640]	; (800102c <main+0xe3c>)
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8000daa:	60fa      	str	r2, [r7, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8000dac:	428b      	cmp	r3, r1
 8000dae:	d023      	beq.n	8000df8 <main+0xc08>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8000db0:	6899      	ldr	r1, [r3, #8]
 8000db2:	68ba      	ldr	r2, [r7, #8]
 8000db4:	468c      	mov	ip, r1
 8000db6:	4462      	add	r2, ip
 8000db8:	609a      	str	r2, [r3, #8]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000dba:	4b98      	ldr	r3, [pc, #608]	; (800101c <main+0xe2c>)
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8000dbc:	8d25      	ldrh	r5, [r4, #40]	; 0x28
 8000dbe:	6a59      	ldr	r1, [r3, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8000dc0:	1b49      	subs	r1, r1, r5
 8000dc2:	b289      	uxth	r1, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8000dc4:	428a      	cmp	r2, r1
 8000dc6:	d800      	bhi.n	8000dca <main+0xbda>
 8000dc8:	e68c      	b.n	8000ae4 <main+0x8f4>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8000dca:	1a53      	subs	r3, r2, r1

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8000dcc:	2b01      	cmp	r3, #1
 8000dce:	d90c      	bls.n	8000dea <main+0xbfa>
 8000dd0:	1e13      	subs	r3, r2, #0
 8000dd2:	4a91      	ldr	r2, [pc, #580]	; (8001018 <main+0xe28>)
 8000dd4:	4293      	cmp	r3, r2
 8000dd6:	d900      	bls.n	8000dda <main+0xbea>
 8000dd8:	1c13      	adds	r3, r2, #0
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000dda:	4a90      	ldr	r2, [pc, #576]	; (800101c <main+0xe2c>)

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8000ddc:	18eb      	adds	r3, r5, r3
 8000dde:	68d1      	ldr	r1, [r2, #12]
 8000de0:	b29b      	uxth	r3, r3
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8000de2:	0789      	lsls	r1, r1, #30
 8000de4:	d5d2      	bpl.n	8000d8c <main+0xb9c>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000de6:	6353      	str	r3, [r2, #52]	; 0x34
 8000de8:	e67c      	b.n	8000ae4 <main+0x8f4>
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
 8000dea:	4a8b      	ldr	r2, [pc, #556]	; (8001018 <main+0xe28>)
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8000dec:	1c8b      	adds	r3, r1, #2
 8000dee:	4293      	cmp	r3, r2
 8000df0:	d9f3      	bls.n	8000dda <main+0xbea>
 8000df2:	488f      	ldr	r0, [pc, #572]	; (8001030 <main+0xe40>)
 8000df4:	f000 f9bc 	bl	8001170 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000df8:	4b88      	ldr	r3, [pc, #544]	; (800101c <main+0xe2c>)
 8000dfa:	60da      	str	r2, [r3, #12]
 8000dfc:	e672      	b.n	8000ae4 <main+0x8f4>
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#10");
 8000dfe:	488d      	ldr	r0, [pc, #564]	; (8001034 <main+0xe44>)
 8000e00:	f000 f9b6 	bl	8001170 <chSysHalt>
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8000e04:	488c      	ldr	r0, [pc, #560]	; (8001038 <main+0xe48>)
 8000e06:	f000 f9b3 	bl	8001170 <chSysHalt>
 8000e0a:	488c      	ldr	r0, [pc, #560]	; (800103c <main+0xe4c>)
 8000e0c:	f000 f9b0 	bl	8001170 <chSysHalt>
      err = i2cGetErrors(i2cp);

    //CRC check for first byte
    CRCInput[0] = (addr_bq76920 << 1) + 1;
	  CRCInput[1] = rx_buffer[0];
    crc[0] = CRC8(CRCInput, 2, 7) ;
 8000e10:	a90a      	add	r1, sp, #40	; 0x28
 8000e12:	700a      	strb	r2, [r1, #0]
    //CRC check for second byte
    CRCInput[0] = rx_buffer[2];
 8000e14:	78ba      	ldrb	r2, [r7, #2]
 8000e16:	464b      	mov	r3, r9
 8000e18:	7002      	strb	r2, [r0, #0]
 8000e1a:	4692      	mov	sl, r2
				crc ^= key;
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 8000e1c:	7802      	ldrb	r2, [r0, #0]
 8000e1e:	9201      	str	r2, [sp, #4]
 8000e20:	2208      	movs	r2, #8
 8000e22:	4690      	mov	r8, r2
 8000e24:	3278      	adds	r2, #120	; 0x78
 8000e26:	4694      	mov	ip, r2
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8000e28:	3a79      	subs	r2, #121	; 0x79
 8000e2a:	4691      	mov	r9, r2
 8000e2c:	4660      	mov	r0, ip
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8000e2e:	005a      	lsls	r2, r3, #1
 8000e30:	b2d2      	uxtb	r2, r2
 8000e32:	4694      	mov	ip, r2
				crc ^= key;
 8000e34:	464a      	mov	r2, r9
 8000e36:	4666      	mov	r6, ip
 8000e38:	4072      	eors	r2, r6
 8000e3a:	061b      	lsls	r3, r3, #24
 8000e3c:	d479      	bmi.n	8000f32 <main+0xd42>
 8000e3e:	4663      	mov	r3, ip
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8000e40:	464e      	mov	r6, r9
 8000e42:	b2da      	uxtb	r2, r3
 8000e44:	4072      	eors	r2, r6
 8000e46:	9e01      	ldr	r6, [sp, #4]
 8000e48:	4206      	tst	r6, r0
 8000e4a:	d000      	beq.n	8000e4e <main+0xc5e>
 8000e4c:	1c13      	adds	r3, r2, #0
 8000e4e:	2201      	movs	r2, #1
 8000e50:	4252      	negs	r2, r2
 8000e52:	4694      	mov	ip, r2
 8000e54:	44e0      	add	r8, ip
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 8000e56:	4642      	mov	r2, r8
 8000e58:	b2db      	uxtb	r3, r3
 8000e5a:	0840      	lsrs	r0, r0, #1
 8000e5c:	2a00      	cmp	r2, #0
 8000e5e:	d1e6      	bne.n	8000e2e <main+0xc3e>
    CRCInput[0] = (addr_bq76920 << 1) + 1;
	  CRCInput[1] = rx_buffer[0];
    crc[0] = CRC8(CRCInput, 2, 7) ;
    //CRC check for second byte
    CRCInput[0] = rx_buffer[2];
    crc[1] = CRC8(CRCInput, 1, 7);
 8000e60:	704b      	strb	r3, [r1, #1]
    if (crc[0] != rx_buffer[1] || crc[1]!= rx_buffer[3] )
 8000e62:	780b      	ldrb	r3, [r1, #0]
 8000e64:	787a      	ldrb	r2, [r7, #1]
 8000e66:	429a      	cmp	r2, r3
 8000e68:	d108      	bne.n	8000e7c <main+0xc8c>
 8000e6a:	784b      	ldrb	r3, [r1, #1]
 8000e6c:	78fa      	ldrb	r2, [r7, #3]
 8000e6e:	429a      	cmp	r2, r3
 8000e70:	d104      	bne.n	8000e7c <main+0xc8c>
      return -1;
    else 
      *data = (rx_buffer[0]<<8) + rx_buffer[2];
 8000e72:	9b02      	ldr	r3, [sp, #8]
 8000e74:	aa0b      	add	r2, sp, #44	; 0x2c
 8000e76:	021b      	lsls	r3, r3, #8
 8000e78:	4453      	add	r3, sl
 8000e7a:	8013      	strh	r3, [r2, #0]
}

msg_t I2CReadRegisterByteWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint8_t *data) {
    msg_t msg;
    i2cflags_t err;
    uint8_t tx_buffer[1] = {reg_address};
 8000e7c:	ab06      	add	r3, sp, #24
 8000e7e:	4699      	mov	r9, r3
 8000e80:	2332      	movs	r3, #50	; 0x32
 8000e82:	464a      	mov	r2, r9
 8000e84:	7013      	strb	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000e86:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000e88:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000e8a:	2b00      	cmp	r3, #0
 8000e8c:	d000      	beq.n	8000e90 <main+0xca0>
 8000e8e:	e54f      	b.n	8000930 <main+0x740>
 8000e90:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8000e92:	2b00      	cmp	r3, #0
 8000e94:	d000      	beq.n	8000e98 <main+0xca8>
 8000e96:	e54b      	b.n	8000930 <main+0x740>
 8000e98:	4658      	mov	r0, fp
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8000e9a:	6365      	str	r5, [r4, #52]	; 0x34
 8000e9c:	f001 fcf8 	bl	8002890 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000ea0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000ea2:	2b00      	cmp	r3, #0
 8000ea4:	d000      	beq.n	8000ea8 <main+0xcb8>
 8000ea6:	e738      	b.n	8000d1a <main+0xb2a>
 8000ea8:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8000eaa:	2a00      	cmp	r2, #0
 8000eac:	dc00      	bgt.n	8000eb0 <main+0xcc0>
 8000eae:	e734      	b.n	8000d1a <main+0xb2a>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8000eb0:	6363      	str	r3, [r4, #52]	; 0x34
 8000eb2:	6823      	ldr	r3, [r4, #0]
 8000eb4:	42a3      	cmp	r3, r4
 8000eb6:	d005      	beq.n	8000ec4 <main+0xcd4>
 8000eb8:	69a2      	ldr	r2, [r4, #24]
 8000eba:	689b      	ldr	r3, [r3, #8]
 8000ebc:	6892      	ldr	r2, [r2, #8]
 8000ebe:	429a      	cmp	r2, r3
 8000ec0:	d200      	bcs.n	8000ec4 <main+0xcd4>
 8000ec2:	e727      	b.n	8000d14 <main+0xb24>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000ec4:	b662      	cpsie	i
    uint8_t CRCInput[2];
    uint8_t crc;

    //read data from i2c bus
    i2cAcquireBus(i2cp);
    msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, 1,
 8000ec6:	2101      	movs	r1, #1
 8000ec8:	aa0e      	add	r2, sp, #56	; 0x38
 8000eca:	2302      	movs	r3, #2
 8000ecc:	4648      	mov	r0, r9
 8000ece:	f002 f927 	bl	8003120 <i2cMasterTransmitTimeout.constprop.28>
 8000ed2:	4658      	mov	r0, fp
 8000ed4:	f001 fc1c 	bl	8002710 <chMtxUnlock>
    i2cReleaseBus(i2cp);
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
 8000ed8:	2311      	movs	r3, #17
	  CRCInput[1] = rx_buffer[0];
 8000eda:	2228      	movs	r2, #40	; 0x28
    i2cReleaseBus(i2cp);
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
 8000edc:	703b      	strb	r3, [r7, #0]
	  CRCInput[1] = rx_buffer[0];
 8000ede:	ab04      	add	r3, sp, #16
 8000ee0:	189b      	adds	r3, r3, r2
 8000ee2:	7819      	ldrb	r1, [r3, #0]
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8000ee4:	3a21      	subs	r2, #33	; 0x21
    cellsVolt[4] = ADCtoVolt(cell_adc[4]);
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
 8000ee6:	2300      	movs	r3, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8000ee8:	4694      	mov	ip, r2
 8000eea:	468a      	mov	sl, r1
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
	  CRCInput[1] = rx_buffer[0];
 8000eec:	7079      	strb	r1, [r7, #1]
				crc ^= key;
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 8000eee:	4642      	mov	r2, r8
 8000ef0:	5cba      	ldrb	r2, [r7, r2]
 8000ef2:	2108      	movs	r1, #8
 8000ef4:	9201      	str	r2, [sp, #4]
 8000ef6:	2280      	movs	r2, #128	; 0x80
 8000ef8:	1c10      	adds	r0, r2, #0
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8000efa:	005a      	lsls	r2, r3, #1
 8000efc:	b2d2      	uxtb	r2, r2
 8000efe:	4691      	mov	r9, r2
				crc ^= key;
 8000f00:	4662      	mov	r2, ip
 8000f02:	464e      	mov	r6, r9
 8000f04:	b25b      	sxtb	r3, r3
 8000f06:	4072      	eors	r2, r6
 8000f08:	2b00      	cmp	r3, #0
 8000f0a:	db14      	blt.n	8000f36 <main+0xd46>
 8000f0c:	464b      	mov	r3, r9
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8000f0e:	4666      	mov	r6, ip
 8000f10:	b2da      	uxtb	r2, r3
 8000f12:	4072      	eors	r2, r6
 8000f14:	9e01      	ldr	r6, [sp, #4]
 8000f16:	4206      	tst	r6, r0
 8000f18:	d000      	beq.n	8000f1c <main+0xd2c>
 8000f1a:	1c13      	adds	r3, r2, #0
 8000f1c:	3901      	subs	r1, #1
 8000f1e:	b2db      	uxtb	r3, r3
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 8000f20:	0840      	lsrs	r0, r0, #1
 8000f22:	2900      	cmp	r1, #0
 8000f24:	d1e9      	bne.n	8000efa <main+0xd0a>
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
 8000f26:	4642      	mov	r2, r8
 8000f28:	2a01      	cmp	r2, #1
 8000f2a:	d006      	beq.n	8000f3a <main+0xd4a>
 8000f2c:	2201      	movs	r2, #1
 8000f2e:	4690      	mov	r8, r2
 8000f30:	e7dd      	b.n	8000eee <main+0xcfe>
 8000f32:	1c13      	adds	r3, r2, #0
 8000f34:	e784      	b.n	8000e40 <main+0xc50>
 8000f36:	1c13      	adds	r3, r2, #0
 8000f38:	e7e9      	b.n	8000f0e <main+0xd1e>

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
	  CRCInput[1] = rx_buffer[0];
    crc = CRC8(CRCInput, 2, 7);
    if (crc != rx_buffer[1])
 8000f3a:	2029      	movs	r0, #41	; 0x29
 8000f3c:	aa04      	add	r2, sp, #16
 8000f3e:	1812      	adds	r2, r2, r0
 8000f40:	7812      	ldrb	r2, [r2, #0]
 8000f42:	4689      	mov	r9, r1
 8000f44:	4651      	mov	r1, sl
 8000f46:	429a      	cmp	r2, r3
 8000f48:	d060      	beq.n	800100c <main+0xe1c>
      palSetPad(GPIOA, GPIOA_LED2);
 8000f4a:	2390      	movs	r3, #144	; 0x90
 8000f4c:	2240      	movs	r2, #64	; 0x40
 8000f4e:	05db      	lsls	r3, r3, #23
 8000f50:	831a      	strh	r2, [r3, #24]
}

msg_t I2CReadRegisterByteWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint8_t *data) {
    msg_t msg;
    i2cflags_t err;
    uint8_t tx_buffer[1] = {reg_address};
 8000f52:	ab07      	add	r3, sp, #28
 8000f54:	4698      	mov	r8, r3
 8000f56:	2333      	movs	r3, #51	; 0x33
 8000f58:	4642      	mov	r2, r8
 8000f5a:	7013      	strb	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000f5c:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8000f5e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000f60:	2b00      	cmp	r3, #0
 8000f62:	d000      	beq.n	8000f66 <main+0xd76>
 8000f64:	e4e4      	b.n	8000930 <main+0x740>
 8000f66:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8000f68:	2b00      	cmp	r3, #0
 8000f6a:	d000      	beq.n	8000f6e <main+0xd7e>
 8000f6c:	e4e0      	b.n	8000930 <main+0x740>
 8000f6e:	4658      	mov	r0, fp
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8000f70:	6365      	str	r5, [r4, #52]	; 0x34
 8000f72:	f001 fc8d 	bl	8002890 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8000f76:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8000f78:	2b00      	cmp	r3, #0
 8000f7a:	d000      	beq.n	8000f7e <main+0xd8e>
 8000f7c:	e6cd      	b.n	8000d1a <main+0xb2a>
 8000f7e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8000f80:	2a00      	cmp	r2, #0
 8000f82:	dc00      	bgt.n	8000f86 <main+0xd96>
 8000f84:	e6c9      	b.n	8000d1a <main+0xb2a>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8000f86:	6363      	str	r3, [r4, #52]	; 0x34
 8000f88:	6823      	ldr	r3, [r4, #0]
 8000f8a:	42a3      	cmp	r3, r4
 8000f8c:	d005      	beq.n	8000f9a <main+0xdaa>
 8000f8e:	69a2      	ldr	r2, [r4, #24]
 8000f90:	689b      	ldr	r3, [r3, #8]
 8000f92:	6892      	ldr	r2, [r2, #8]
 8000f94:	429a      	cmp	r2, r3
 8000f96:	d200      	bcs.n	8000f9a <main+0xdaa>
 8000f98:	e6bc      	b.n	8000d14 <main+0xb24>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000f9a:	b662      	cpsie	i
    uint8_t CRCInput[2];
    uint8_t crc;

    //read data from i2c bus
    i2cAcquireBus(i2cp);
    msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, 1,
 8000f9c:	2101      	movs	r1, #1
 8000f9e:	aa0e      	add	r2, sp, #56	; 0x38
 8000fa0:	2302      	movs	r3, #2
 8000fa2:	4640      	mov	r0, r8
 8000fa4:	f002 f8bc 	bl	8003120 <i2cMasterTransmitTimeout.constprop.28>
 8000fa8:	4658      	mov	r0, fp
 8000faa:	f001 fbb1 	bl	8002710 <chMtxUnlock>
    i2cReleaseBus(i2cp);
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
 8000fae:	2311      	movs	r3, #17
	  CRCInput[1] = rx_buffer[0];
 8000fb0:	2228      	movs	r2, #40	; 0x28
    i2cReleaseBus(i2cp);
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
 8000fb2:	703b      	strb	r3, [r7, #0]
	  CRCInput[1] = rx_buffer[0];
 8000fb4:	ab04      	add	r3, sp, #16
 8000fb6:	189b      	adds	r3, r3, r2
 8000fb8:	7819      	ldrb	r1, [r3, #0]
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8000fba:	3a21      	subs	r2, #33	; 0x21
    cellsVolt[4] = ADCtoVolt(cell_adc[4]);
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
 8000fbc:	2300      	movs	r3, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8000fbe:	4690      	mov	r8, r2
 8000fc0:	468a      	mov	sl, r1
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
	  CRCInput[1] = rx_buffer[0];
 8000fc2:	7079      	strb	r1, [r7, #1]
				crc ^= key;
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 8000fc4:	464a      	mov	r2, r9
 8000fc6:	5cba      	ldrb	r2, [r7, r2]
 8000fc8:	2008      	movs	r0, #8
 8000fca:	9201      	str	r2, [sp, #4]
 8000fcc:	2280      	movs	r2, #128	; 0x80
 8000fce:	1c11      	adds	r1, r2, #0
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8000fd0:	005a      	lsls	r2, r3, #1
 8000fd2:	b2d2      	uxtb	r2, r2
 8000fd4:	4694      	mov	ip, r2
				crc ^= key;
 8000fd6:	4642      	mov	r2, r8
 8000fd8:	4666      	mov	r6, ip
 8000fda:	b25b      	sxtb	r3, r3
 8000fdc:	4072      	eors	r2, r6
 8000fde:	2b00      	cmp	r3, #0
 8000fe0:	db12      	blt.n	8001008 <main+0xe18>
 8000fe2:	4663      	mov	r3, ip
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8000fe4:	4646      	mov	r6, r8
 8000fe6:	b2da      	uxtb	r2, r3
 8000fe8:	4072      	eors	r2, r6
 8000fea:	9e01      	ldr	r6, [sp, #4]
 8000fec:	420e      	tst	r6, r1
 8000fee:	d000      	beq.n	8000ff2 <main+0xe02>
 8000ff0:	1c13      	adds	r3, r2, #0
 8000ff2:	3801      	subs	r0, #1
 8000ff4:	b2db      	uxtb	r3, r3
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 8000ff6:	0849      	lsrs	r1, r1, #1
 8000ff8:	2800      	cmp	r0, #0
 8000ffa:	d1e9      	bne.n	8000fd0 <main+0xde0>
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
 8000ffc:	464a      	mov	r2, r9
 8000ffe:	2a01      	cmp	r2, #1
 8001000:	d01e      	beq.n	8001040 <main+0xe50>
 8001002:	2201      	movs	r2, #1
 8001004:	4691      	mov	r9, r2
 8001006:	e7dd      	b.n	8000fc4 <main+0xdd4>
 8001008:	1c13      	adds	r3, r2, #0
 800100a:	e7eb      	b.n	8000fe4 <main+0xdf4>
	  CRCInput[1] = rx_buffer[0];
    crc = CRC8(CRCInput, 2, 7);
    if (crc != rx_buffer[1])
      palSetPad(GPIOA, GPIOA_LED2);
    else
      *data = rx_buffer[0];
 800100c:	aa04      	add	r2, sp, #16
 800100e:	230f      	movs	r3, #15
 8001010:	4694      	mov	ip, r2
 8001012:	4463      	add	r3, ip
 8001014:	7019      	strb	r1, [r3, #0]
 8001016:	e79c      	b.n	8000f52 <main+0xd62>
 8001018:	0000ffff 	.word	0x0000ffff
 800101c:	40000400 	.word	0x40000400
 8001020:	08003714 	.word	0x08003714
 8001024:	08003690 	.word	0x08003690
 8001028:	080036d0 	.word	0x080036d0
 800102c:	2000071c 	.word	0x2000071c
 8001030:	08003624 	.word	0x08003624
 8001034:	080036e8 	.word	0x080036e8
 8001038:	080036d8 	.word	0x080036d8
 800103c:	08003618 	.word	0x08003618

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
	  CRCInput[1] = rx_buffer[0];
    crc = CRC8(CRCInput, 2, 7);
    if (crc != rx_buffer[1])
 8001040:	2629      	movs	r6, #41	; 0x29
 8001042:	aa04      	add	r2, sp, #16
 8001044:	1992      	adds	r2, r2, r6
 8001046:	7812      	ldrb	r2, [r2, #0]
 8001048:	4651      	mov	r1, sl
 800104a:	429a      	cmp	r2, r3
 800104c:	d072      	beq.n	8001134 <main+0xf44>
      palSetPad(GPIOA, GPIOA_LED2);
 800104e:	2390      	movs	r3, #144	; 0x90
 8001050:	2240      	movs	r2, #64	; 0x40
 8001052:	05db      	lsls	r3, r3, #23
 8001054:	831a      	strh	r2, [r3, #24]
    if(cc_ok)
    {
      msg = I2CReadRegisterWordWithCRC(&I2CD1, addr_bq76920, CC_HI, &foo);
      msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, CC_HI, &cchi);
      msg = I2CReadRegisterByteWithCRC(&I2CD1, addr_bq76920, CC_LO, &cclo);
      cc_adc = foo;
 8001056:	a904      	add	r1, sp, #16
 8001058:	468c      	mov	ip, r1
 800105a:	221e      	movs	r2, #30
 800105c:	ab0b      	add	r3, sp, #44	; 0x2c
 800105e:	881b      	ldrh	r3, [r3, #0]
 8001060:	4462      	add	r2, ip
 8001062:	8013      	strh	r3, [r2, #0]
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
    CRCInput[1]=reg_address;
    CRCInput[2]=data;
 8001064:	2210      	movs	r2, #16
    i2cflags_t err;
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
 8001066:	2310      	movs	r3, #16
    CRCInput[1]=reg_address;
    CRCInput[2]=data;
 8001068:	70ba      	strb	r2, [r7, #2]

    //generate data sequence
    tx_buffer[0] = reg_address;
 800106a:	1c0a      	adds	r2, r1, #0
 800106c:	2128      	movs	r1, #40	; 0x28
    i2cflags_t err;
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
 800106e:	703b      	strb	r3, [r7, #0]
    CRCInput[1]=reg_address;
 8001070:	2300      	movs	r3, #0
    CRCInput[2]=data;

    //generate data sequence
    tx_buffer[0] = reg_address;
 8001072:	1852      	adds	r2, r2, r1
 8001074:	7013      	strb	r3, [r2, #0]
    tx_buffer[1] = data;
 8001076:	4662      	mov	r2, ip
 8001078:	3101      	adds	r1, #1
 800107a:	1852      	adds	r2, r2, r1
 800107c:	3919      	subs	r1, #25
 800107e:	7011      	strb	r1, [r2, #0]
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8001080:	2107      	movs	r1, #7
    uint8_t tx_buffer[3];
    uint8_t CRCInput[3];

    //generate CRC
    CRCInput[0]=dev_address << 1;
    CRCInput[1]=reg_address;
 8001082:	707b      	strb	r3, [r7, #1]
				crc ^= key;
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
 8001084:	5c3a      	ldrb	r2, [r7, r0]
 8001086:	2680      	movs	r6, #128	; 0x80
 8001088:	4690      	mov	r8, r2
 800108a:	2208      	movs	r2, #8
 800108c:	4681      	mov	r9, r0
 800108e:	46b4      	mov	ip, r6
 8001090:	1c10      	adds	r0, r2, #0
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8001092:	005a      	lsls	r2, r3, #1
 8001094:	b2d2      	uxtb	r2, r2
 8001096:	b25b      	sxtb	r3, r3
 8001098:	4692      	mov	sl, r2
				crc ^= key;
 800109a:	404a      	eors	r2, r1
 800109c:	2b00      	cmp	r3, #0
 800109e:	db47      	blt.n	8001130 <main+0xf40>
 80010a0:	4653      	mov	r3, sl
 80010a2:	b2da      	uxtb	r2, r3
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80010a4:	404a      	eors	r2, r1
 80010a6:	4692      	mov	sl, r2
 80010a8:	4646      	mov	r6, r8
 80010aa:	4662      	mov	r2, ip
 80010ac:	4216      	tst	r6, r2
 80010ae:	d000      	beq.n	80010b2 <main+0xec2>
 80010b0:	4653      	mov	r3, sl
uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
	{
		for(i=0x80; i!=0; i/=2)
 80010b2:	4662      	mov	r2, ip
 80010b4:	3801      	subs	r0, #1
 80010b6:	0852      	lsrs	r2, r2, #1
 80010b8:	b2db      	uxtb	r3, r3
 80010ba:	4694      	mov	ip, r2
 80010bc:	2800      	cmp	r0, #0
 80010be:	d1e8      	bne.n	8001092 <main+0xea2>
 80010c0:	1c02      	adds	r2, r0, #0
 80010c2:	4648      	mov	r0, r9
 80010c4:	3001      	adds	r0, #1
}

uint8_t CRC8(uint8_t *ptr, uint8_t len, uint8_t key) {
	uint8_t i;
	uint8_t crc=0;
	while(len--!=0)
 80010c6:	2803      	cmp	r0, #3
 80010c8:	d1dc      	bne.n	8001084 <main+0xe94>
    CRCInput[2]=data;

    //generate data sequence
    tx_buffer[0] = reg_address;
    tx_buffer[1] = data;
    tx_buffer[2] = CRC8(CRCInput, 3, 7);
 80010ca:	212a      	movs	r1, #42	; 0x2a
 80010cc:	4690      	mov	r8, r2
 80010ce:	aa04      	add	r2, sp, #16
 80010d0:	1852      	adds	r2, r2, r1
 80010d2:	7013      	strb	r3, [r2, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80010d4:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80010d6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80010d8:	2b00      	cmp	r3, #0
 80010da:	d000      	beq.n	80010de <main+0xeee>
 80010dc:	e428      	b.n	8000930 <main+0x740>
 80010de:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80010e0:	2b00      	cmp	r3, #0
 80010e2:	d000      	beq.n	80010e6 <main+0xef6>
 80010e4:	e424      	b.n	8000930 <main+0x740>
 80010e6:	4658      	mov	r0, fp
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80010e8:	6365      	str	r5, [r4, #52]	; 0x34
 80010ea:	f001 fbd1 	bl	8002890 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80010ee:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80010f0:	2b00      	cmp	r3, #0
 80010f2:	d000      	beq.n	80010f6 <main+0xf06>
 80010f4:	e611      	b.n	8000d1a <main+0xb2a>
 80010f6:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80010f8:	2b00      	cmp	r3, #0
 80010fa:	dc00      	bgt.n	80010fe <main+0xf0e>
 80010fc:	e60d      	b.n	8000d1a <main+0xb2a>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80010fe:	4643      	mov	r3, r8
 8001100:	6363      	str	r3, [r4, #52]	; 0x34
 8001102:	6823      	ldr	r3, [r4, #0]
 8001104:	42a3      	cmp	r3, r4
 8001106:	d005      	beq.n	8001114 <main+0xf24>
 8001108:	69a2      	ldr	r2, [r4, #24]
 800110a:	689b      	ldr	r3, [r3, #8]
 800110c:	6892      	ldr	r2, [r2, #8]
 800110e:	429a      	cmp	r2, r3
 8001110:	d200      	bcs.n	8001114 <main+0xf24>
 8001112:	e5ff      	b.n	8000d14 <main+0xb24>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001114:	b662      	cpsie	i

    //write data to i2c bus
    i2cAcquireBus(i2cp);
    msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, sizeof(tx_buffer),
 8001116:	2200      	movs	r2, #0
 8001118:	2103      	movs	r1, #3
 800111a:	1c13      	adds	r3, r2, #0
 800111c:	a80e      	add	r0, sp, #56	; 0x38
 800111e:	f001 ffff 	bl	8003120 <i2cMasterTransmitTimeout.constprop.28>
 8001122:	4658      	mov	r0, fp
 8001124:	f001 faf4 	bl	8002710 <chMtxUnlock>
      I2CWriteRegisterByteWithCRC(&I2CD1, addr_bq76920, SYS_STAT, 0b00010000);
      cc_ok = false;
 8001128:	2300      	movs	r3, #0
 800112a:	9a00      	ldr	r2, [sp, #0]
 800112c:	7013      	strb	r3, [r2, #0]
 800112e:	e4e8      	b.n	8000b02 <main+0x912>
 8001130:	1c13      	adds	r3, r2, #0
 8001132:	e7b6      	b.n	80010a2 <main+0xeb2>
	  CRCInput[1] = rx_buffer[0];
    crc = CRC8(CRCInput, 2, 7);
    if (crc != rx_buffer[1])
      palSetPad(GPIOA, GPIOA_LED2);
    else
      *data = rx_buffer[0];
 8001134:	ab08      	add	r3, sp, #32
 8001136:	7019      	strb	r1, [r3, #0]
 8001138:	e78d      	b.n	8001056 <main+0xe66>
 800113a:	46c0      	nop			; (mov r8, r8)
 800113c:	0000      	movs	r0, r0
	...

08001140 <trace_next.lto_priv.45>:
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8001140:	4a08      	ldr	r2, [pc, #32]	; (8001164 <trace_next.lto_priv.45+0x24>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001142:	4909      	ldr	r1, [pc, #36]	; (8001168 <trace_next.lto_priv.45+0x28>)
 8001144:	6bd3      	ldr	r3, [r2, #60]	; 0x3c
 8001146:	6a49      	ldr	r1, [r1, #36]	; 0x24
 8001148:	8099      	strh	r1, [r3, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
#else
  ch.dbg.trace_buffer.ptr->rtstamp = (rtcnt_t)0;
 800114a:	7819      	ldrb	r1, [r3, #0]
 800114c:	6019      	str	r1, [r3, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 800114e:	2184      	movs	r1, #132	; 0x84
 8001150:	0109      	lsls	r1, r1, #4
 8001152:	3310      	adds	r3, #16
 8001154:	1851      	adds	r1, r2, r1
 8001156:	428b      	cmp	r3, r1
 8001158:	d301      	bcc.n	800115e <trace_next.lto_priv.45+0x1e>
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 800115a:	1c13      	adds	r3, r2, #0
 800115c:	3340      	adds	r3, #64	; 0x40
 800115e:	63d3      	str	r3, [r2, #60]	; 0x3c
  }
}
 8001160:	4770      	bx	lr
 8001162:	46c0      	nop			; (mov r8, r8)
 8001164:	20000700 	.word	0x20000700
 8001168:	40000400 	.word	0x40000400
 800116c:	00000000 	.word	0x00000000

08001170 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8001170:	b538      	push	{r3, r4, r5, lr}
 8001172:	1c05      	adds	r5, r0, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001174:	b672      	cpsid	i
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8001176:	4c09      	ldr	r4, [pc, #36]	; (800119c <chSysHalt+0x2c>)
 8001178:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800117a:	075b      	lsls	r3, r3, #29
 800117c:	d501      	bpl.n	8001182 <chSysHalt+0x12>

  /* Logging the event.*/
  _trace_halt(reason);

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800117e:	62e5      	str	r5, [r4, #44]	; 0x2c
 8001180:	e7fe      	b.n	8001180 <chSysHalt+0x10>
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8001182:	2007      	movs	r0, #7
 8001184:	2204      	movs	r2, #4
 8001186:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001188:	780b      	ldrb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 800118a:	608d      	str	r5, [r1, #8]
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 800118c:	4383      	bics	r3, r0
 800118e:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state         = 0;
 8001190:	4003      	ands	r3, r0
 8001192:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
    trace_next();
 8001194:	f7ff ffd4 	bl	8001140 <trace_next.lto_priv.45>
 8001198:	62e5      	str	r5, [r4, #44]	; 0x2c
 800119a:	e7f1      	b.n	8001180 <chSysHalt+0x10>
 800119c:	20000700 	.word	0x20000700

080011a0 <_dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void _dbg_check_unlock(void) {
 80011a0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80011a2:	4b06      	ldr	r3, [pc, #24]	; (80011bc <_dbg_check_unlock+0x1c>)
 80011a4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80011a6:	2a00      	cmp	r2, #0
 80011a8:	d104      	bne.n	80011b4 <_dbg_check_unlock+0x14>
 80011aa:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80011ac:	2900      	cmp	r1, #0
 80011ae:	dd01      	ble.n	80011b4 <_dbg_check_unlock+0x14>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80011b0:	635a      	str	r2, [r3, #52]	; 0x34
}
 80011b2:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 80011b4:	4802      	ldr	r0, [pc, #8]	; (80011c0 <_dbg_check_unlock+0x20>)
 80011b6:	f7ff ffdb 	bl	8001170 <chSysHalt>
 80011ba:	46c0      	nop			; (mov r8, r8)
 80011bc:	20000700 	.word	0x20000700
 80011c0:	080036f0 	.word	0x080036f0
	...

080011d0 <_dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void _dbg_check_lock(void) {
 80011d0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80011d2:	4b06      	ldr	r3, [pc, #24]	; (80011ec <_dbg_check_lock+0x1c>)
 80011d4:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 80011d6:	2a00      	cmp	r2, #0
 80011d8:	d102      	bne.n	80011e0 <_dbg_check_lock+0x10>
 80011da:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80011dc:	2a00      	cmp	r2, #0
 80011de:	d002      	beq.n	80011e6 <_dbg_check_lock+0x16>
    chSysHalt("SV#4");
 80011e0:	4803      	ldr	r0, [pc, #12]	; (80011f0 <_dbg_check_lock+0x20>)
 80011e2:	f7ff ffc5 	bl	8001170 <chSysHalt>
  }
  _dbg_enter_lock();
 80011e6:	2201      	movs	r2, #1
 80011e8:	635a      	str	r2, [r3, #52]	; 0x34
}
 80011ea:	bd08      	pop	{r3, pc}
 80011ec:	20000700 	.word	0x20000700
 80011f0:	080036c8 	.word	0x080036c8
	...

08001200 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001200:	b510      	push	{r4, lr}
 8001202:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001204:	4c12      	ldr	r4, [pc, #72]	; (8001250 <chMtxLock+0x50>)
 8001206:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001208:	2b00      	cmp	r3, #0
 800120a:	d102      	bne.n	8001212 <chMtxLock+0x12>
 800120c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800120e:	2b00      	cmp	r3, #0
 8001210:	d002      	beq.n	8001218 <chMtxLock+0x18>
    chSysHalt("SV#4");
 8001212:	4810      	ldr	r0, [pc, #64]	; (8001254 <chMtxLock+0x54>)
 8001214:	f7ff ffac 	bl	8001170 <chSysHalt>
  }
  _dbg_enter_lock();
 8001218:	2301      	movs	r3, #1
 800121a:	6363      	str	r3, [r4, #52]	; 0x34

  chSysLock();
  chMtxLockS(mp);
 800121c:	f001 fb38 	bl	8002890 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001220:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001222:	2b00      	cmp	r3, #0
 8001224:	d10d      	bne.n	8001242 <chMtxLock+0x42>
 8001226:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001228:	2a00      	cmp	r2, #0
 800122a:	dd0a      	ble.n	8001242 <chMtxLock+0x42>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800122c:	6363      	str	r3, [r4, #52]	; 0x34
 800122e:	6823      	ldr	r3, [r4, #0]
 8001230:	42a3      	cmp	r3, r4
 8001232:	d004      	beq.n	800123e <chMtxLock+0x3e>
 8001234:	69a2      	ldr	r2, [r4, #24]
 8001236:	689b      	ldr	r3, [r3, #8]
 8001238:	6892      	ldr	r2, [r2, #8]
 800123a:	429a      	cmp	r2, r3
 800123c:	d304      	bcc.n	8001248 <chMtxLock+0x48>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800123e:	b662      	cpsie	i
  chSysUnlock();
}
 8001240:	bd10      	pop	{r4, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 8001242:	4805      	ldr	r0, [pc, #20]	; (8001258 <chMtxLock+0x58>)
 8001244:	f7ff ff94 	bl	8001170 <chSysHalt>
 8001248:	4804      	ldr	r0, [pc, #16]	; (800125c <chMtxLock+0x5c>)
 800124a:	f7ff ff91 	bl	8001170 <chSysHalt>
 800124e:	46c0      	nop			; (mov r8, r8)
 8001250:	20000700 	.word	0x20000700
 8001254:	080036c8 	.word	0x080036c8
 8001258:	080036f0 	.word	0x080036f0
 800125c:	080036f8 	.word	0x080036f8

08001260 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8001260:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001262:	4b05      	ldr	r3, [pc, #20]	; (8001278 <chDbgCheckClassI+0x18>)
 8001264:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001266:	2a00      	cmp	r2, #0
 8001268:	db03      	blt.n	8001272 <chDbgCheckClassI+0x12>
 800126a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800126c:	2b00      	cmp	r3, #0
 800126e:	dd00      	ble.n	8001272 <chDbgCheckClassI+0x12>
    chSysHalt("SV#10");
  }
}
 8001270:	bd08      	pop	{r3, pc}
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#10");
 8001272:	4802      	ldr	r0, [pc, #8]	; (800127c <chDbgCheckClassI+0x1c>)
 8001274:	f7ff ff7c 	bl	8001170 <chSysHalt>
 8001278:	20000700 	.word	0x20000700
 800127c:	080036e8 	.word	0x080036e8

08001280 <chSysUnlock.lto_priv.49>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001280:	b508      	push	{r3, lr}
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001282:	4b0c      	ldr	r3, [pc, #48]	; (80012b4 <chSysUnlock.lto_priv.49+0x34>)
 8001284:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001286:	2a00      	cmp	r2, #0
 8001288:	d10d      	bne.n	80012a6 <chSysUnlock.lto_priv.49+0x26>
 800128a:	6b59      	ldr	r1, [r3, #52]	; 0x34
 800128c:	2900      	cmp	r1, #0
 800128e:	dd0a      	ble.n	80012a6 <chSysUnlock.lto_priv.49+0x26>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8001290:	635a      	str	r2, [r3, #52]	; 0x34

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001292:	681a      	ldr	r2, [r3, #0]
 8001294:	429a      	cmp	r2, r3
 8001296:	d004      	beq.n	80012a2 <chSysUnlock.lto_priv.49+0x22>
 8001298:	699b      	ldr	r3, [r3, #24]
 800129a:	6899      	ldr	r1, [r3, #8]
 800129c:	6893      	ldr	r3, [r2, #8]
 800129e:	4299      	cmp	r1, r3
 80012a0:	d304      	bcc.n	80012ac <chSysUnlock.lto_priv.49+0x2c>
 80012a2:	b662      	cpsie	i
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  port_unlock();
}
 80012a4:	bd08      	pop	{r3, pc}
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 80012a6:	4804      	ldr	r0, [pc, #16]	; (80012b8 <chSysUnlock.lto_priv.49+0x38>)
 80012a8:	f7ff ff62 	bl	8001170 <chSysHalt>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80012ac:	4803      	ldr	r0, [pc, #12]	; (80012bc <chSysUnlock.lto_priv.49+0x3c>)
 80012ae:	f7ff ff5f 	bl	8001170 <chSysHalt>
 80012b2:	46c0      	nop			; (mov r8, r8)
 80012b4:	20000700 	.word	0x20000700
 80012b8:	080036f0 	.word	0x080036f0
 80012bc:	08003618 	.word	0x08003618

080012c0 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 80012c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80012c2:	464d      	mov	r5, r9
 80012c4:	465f      	mov	r7, fp
 80012c6:	4656      	mov	r6, sl
 80012c8:	4644      	mov	r4, r8
 80012ca:	b4f0      	push	{r4, r5, r6, r7}
 80012cc:	1c05      	adds	r5, r0, #0
 80012ce:	b083      	sub	sp, #12
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80012d0:	b672      	cpsid	i
 */
static inline void chSysLock(void) {

  port_lock();
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
 80012d2:	f7ff ff7d 	bl	80011d0 <_dbg_check_lock>
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 80012d6:	2222      	movs	r2, #34	; 0x22
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 80012d8:	4c90      	ldr	r4, [pc, #576]	; (800151c <chRegFindThreadByWorkingArea+0x25c>)
 80012da:	6927      	ldr	r7, [r4, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 80012dc:	5cbb      	ldrb	r3, [r7, r2]
 80012de:	3301      	adds	r3, #1
 80012e0:	54bb      	strb	r3, [r7, r2]
 *
 * @special
 */
static inline void chSysUnlock(void) {

  _dbg_check_unlock();
 80012e2:	f7ff ff5d 	bl	80011a0 <_dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchResceduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80012e6:	6823      	ldr	r3, [r4, #0]
 80012e8:	42a3      	cmp	r3, r4
 80012ea:	d004      	beq.n	80012f6 <chRegFindThreadByWorkingArea+0x36>
 80012ec:	69a2      	ldr	r2, [r4, #24]
 80012ee:	689b      	ldr	r3, [r3, #8]
 80012f0:	6892      	ldr	r2, [r2, #8]
 80012f2:	429a      	cmp	r2, r3
 80012f4:	d327      	bcc.n	8001346 <chRegFindThreadByWorkingArea+0x86>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80012f6:	b662      	cpsie	i
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80012f8:	2301      	movs	r3, #1
 80012fa:	469b      	mov	fp, r3
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 80012fc:	3320      	adds	r3, #32
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 80012fe:	2622      	movs	r6, #34	; 0x22
 8001300:	4699      	mov	r9, r3
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8001302:	69fb      	ldr	r3, [r7, #28]
 8001304:	42ab      	cmp	r3, r5
 8001306:	d045      	beq.n	8001394 <chRegFindThreadByWorkingArea+0xd4>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001308:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800130a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800130c:	2b00      	cmp	r3, #0
 800130e:	d102      	bne.n	8001316 <chRegFindThreadByWorkingArea+0x56>
 8001310:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001312:	2b00      	cmp	r3, #0
 8001314:	d002      	beq.n	800131c <chRegFindThreadByWorkingArea+0x5c>
    chSysHalt("SV#4");
 8001316:	4882      	ldr	r0, [pc, #520]	; (8001520 <chRegFindThreadByWorkingArea+0x260>)
 8001318:	f7ff ff2a 	bl	8001170 <chSysHalt>
  }
  _dbg_enter_lock();
 800131c:	465a      	mov	r2, fp
 800131e:	6362      	str	r2, [r4, #52]	; 0x34
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 8001320:	693a      	ldr	r2, [r7, #16]
 8001322:	4690      	mov	r8, r2
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001324:	42a2      	cmp	r2, r4
 8001326:	d043      	beq.n	80013b0 <chRegFindThreadByWorkingArea+0xf0>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8001328:	5d93      	ldrb	r3, [r2, r6]
 800132a:	2bff      	cmp	r3, #255	; 0xff
 800132c:	d03a      	beq.n	80013a4 <chRegFindThreadByWorkingArea+0xe4>
    ntp->refs++;
 800132e:	3301      	adds	r3, #1
 8001330:	5593      	strb	r3, [r2, r6]
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8001332:	2300      	movs	r3, #0
 8001334:	6363      	str	r3, [r4, #52]	; 0x34
 8001336:	6823      	ldr	r3, [r4, #0]
 8001338:	42a3      	cmp	r3, r4
 800133a:	d007      	beq.n	800134c <chRegFindThreadByWorkingArea+0x8c>
 800133c:	69a2      	ldr	r2, [r4, #24]
 800133e:	689b      	ldr	r3, [r3, #8]
 8001340:	6892      	ldr	r2, [r2, #8]
 8001342:	429a      	cmp	r2, r3
 8001344:	d202      	bcs.n	800134c <chRegFindThreadByWorkingArea+0x8c>
 8001346:	4877      	ldr	r0, [pc, #476]	; (8001524 <chRegFindThreadByWorkingArea+0x264>)
 8001348:	f7ff ff12 	bl	8001170 <chSysHalt>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800134c:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800134e:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001350:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001352:	2b00      	cmp	r3, #0
 8001354:	d1df      	bne.n	8001316 <chRegFindThreadByWorkingArea+0x56>
 8001356:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001358:	2b00      	cmp	r3, #0
 800135a:	d1dc      	bne.n	8001316 <chRegFindThreadByWorkingArea+0x56>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 800135c:	465a      	mov	r2, fp
 800135e:	6362      	str	r2, [r4, #52]	; 0x34
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8001360:	5dba      	ldrb	r2, [r7, r6]
 8001362:	2a00      	cmp	r2, #0
 8001364:	d021      	beq.n	80013aa <chRegFindThreadByWorkingArea+0xea>
  tp->refs--;
 8001366:	3a01      	subs	r2, #1
 8001368:	55ba      	strb	r2, [r7, r6]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800136a:	6a39      	ldr	r1, [r7, #32]
 800136c:	4a6e      	ldr	r2, [pc, #440]	; (8001528 <chRegFindThreadByWorkingArea+0x268>)
 800136e:	400a      	ands	r2, r1
 8001370:	2a0f      	cmp	r2, #15
 8001372:	d01f      	beq.n	80013b4 <chRegFindThreadByWorkingArea+0xf4>
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8001374:	6363      	str	r3, [r4, #52]	; 0x34
 8001376:	6823      	ldr	r3, [r4, #0]
 8001378:	42a3      	cmp	r3, r4
 800137a:	d004      	beq.n	8001386 <chRegFindThreadByWorkingArea+0xc6>
 800137c:	69a2      	ldr	r2, [r4, #24]
 800137e:	689b      	ldr	r3, [r3, #8]
 8001380:	6892      	ldr	r2, [r2, #8]
 8001382:	429a      	cmp	r2, r3
 8001384:	d345      	bcc.n	8001412 <chRegFindThreadByWorkingArea+0x152>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001386:	b662      	cpsie	i
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);
 8001388:	4643      	mov	r3, r8
 800138a:	2b00      	cmp	r3, #0
 800138c:	d100      	bne.n	8001390 <chRegFindThreadByWorkingArea+0xd0>
 800138e:	e08a      	b.n	80014a6 <chRegFindThreadByWorkingArea+0x1e6>
 8001390:	4647      	mov	r7, r8
 8001392:	e7b6      	b.n	8001302 <chRegFindThreadByWorkingArea+0x42>
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8001394:	1c38      	adds	r0, r7, #0
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
}
 8001396:	b003      	add	sp, #12
 8001398:	bc3c      	pop	{r2, r3, r4, r5}
 800139a:	4690      	mov	r8, r2
 800139c:	4699      	mov	r9, r3
 800139e:	46a2      	mov	sl, r4
 80013a0:	46ab      	mov	fp, r5
 80013a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 80013a4:	4861      	ldr	r0, [pc, #388]	; (800152c <chRegFindThreadByWorkingArea+0x26c>)
 80013a6:	f7ff fee3 	bl	8001170 <chSysHalt>
 * @api
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 80013aa:	4861      	ldr	r0, [pc, #388]	; (8001530 <chRegFindThreadByWorkingArea+0x270>)
 80013ac:	f7ff fee0 	bl	8001170 <chSysHalt>
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 80013b0:	4698      	mov	r8, r3
 80013b2:	e7be      	b.n	8001332 <chRegFindThreadByWorkingArea+0x72>

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
 80013b4:	6939      	ldr	r1, [r7, #16]
 80013b6:	697a      	ldr	r2, [r7, #20]
 80013b8:	6111      	str	r1, [r2, #16]
 80013ba:	6939      	ldr	r1, [r7, #16]
 80013bc:	614a      	str	r2, [r1, #20]
 80013be:	6363      	str	r3, [r4, #52]	; 0x34
 80013c0:	6823      	ldr	r3, [r4, #0]
 80013c2:	42a3      	cmp	r3, r4
 80013c4:	d004      	beq.n	80013d0 <chRegFindThreadByWorkingArea+0x110>
 80013c6:	69a2      	ldr	r2, [r4, #24]
 80013c8:	689b      	ldr	r3, [r3, #8]
 80013ca:	6892      	ldr	r2, [r2, #8]
 80013cc:	429a      	cmp	r2, r3
 80013ce:	d320      	bcc.n	8001412 <chRegFindThreadByWorkingArea+0x152>
 80013d0:	b662      	cpsie	i
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 80013d2:	464b      	mov	r3, r9
 80013d4:	5cfa      	ldrb	r2, [r7, r3]
 80013d6:	2303      	movs	r3, #3
 80013d8:	4013      	ands	r3, r2
 80013da:	2b01      	cmp	r3, #1
 80013dc:	d01c      	beq.n	8001418 <chRegFindThreadByWorkingArea+0x158>
 80013de:	2b02      	cmp	r3, #2
 80013e0:	d1d2      	bne.n	8001388 <chRegFindThreadByWorkingArea+0xc8>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 80013e2:	6c3a      	ldr	r2, [r7, #64]	; 0x40
 80013e4:	69f9      	ldr	r1, [r7, #28]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80013e6:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80013e8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80013ea:	2b00      	cmp	r3, #0
 80013ec:	d000      	beq.n	80013f0 <chRegFindThreadByWorkingArea+0x130>
 80013ee:	e792      	b.n	8001316 <chRegFindThreadByWorkingArea+0x56>
 80013f0:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80013f2:	2b00      	cmp	r3, #0
 80013f4:	d000      	beq.n	80013f8 <chRegFindThreadByWorkingArea+0x138>
 80013f6:	e78e      	b.n	8001316 <chRegFindThreadByWorkingArea+0x56>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80013f8:	465b      	mov	r3, fp
 80013fa:	6363      	str	r3, [r4, #52]	; 0x34
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) &&
 80013fc:	2a00      	cmp	r2, #0
 80013fe:	d005      	beq.n	800140c <chRegFindThreadByWorkingArea+0x14c>
 8001400:	2900      	cmp	r1, #0
 8001402:	d003      	beq.n	800140c <chRegFindThreadByWorkingArea+0x14c>
 8001404:	6893      	ldr	r3, [r2, #8]
 8001406:	3b01      	subs	r3, #1
 8001408:	400b      	ands	r3, r1
 800140a:	d06f      	beq.n	80014ec <chRegFindThreadByWorkingArea+0x22c>
 800140c:	4849      	ldr	r0, [pc, #292]	; (8001534 <chRegFindThreadByWorkingArea+0x274>)
 800140e:	f7ff feaf 	bl	8001170 <chSysHalt>
 8001412:	4849      	ldr	r0, [pc, #292]	; (8001538 <chRegFindThreadByWorkingArea+0x278>)
 8001414:	f7ff feac 	bl	8001170 <chSysHalt>
 8001418:	69fa      	ldr	r2, [r7, #28]
 */
void chHeapFree(void *p) {
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 800141a:	2a00      	cmp	r2, #0
 800141c:	d002      	beq.n	8001424 <chRegFindThreadByWorkingArea+0x164>
 800141e:	2107      	movs	r1, #7
 8001420:	420a      	tst	r2, r1
 8001422:	d002      	beq.n	800142a <chRegFindThreadByWorkingArea+0x16a>
 8001424:	4845      	ldr	r0, [pc, #276]	; (800153c <chRegFindThreadByWorkingArea+0x27c>)
 8001426:	f7ff fea3 	bl	8001170 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 800142a:	3a08      	subs	r2, #8
 800142c:	1c17      	adds	r7, r2, #0
 800142e:	6812      	ldr	r2, [r2, #0]
 8001430:	4692      	mov	sl, r2
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001432:	687a      	ldr	r2, [r7, #4]
 8001434:	3207      	adds	r2, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8001436:	08d2      	lsrs	r2, r2, #3
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8001438:	607a      	str	r2, [r7, #4]
 800143a:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800143c:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800143e:	2a00      	cmp	r2, #0
 8001440:	d000      	beq.n	8001444 <chRegFindThreadByWorkingArea+0x184>
 8001442:	e768      	b.n	8001316 <chRegFindThreadByWorkingArea+0x56>
 8001444:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001446:	2a00      	cmp	r2, #0
 8001448:	d000      	beq.n	800144c <chRegFindThreadByWorkingArea+0x18c>
 800144a:	e764      	b.n	8001316 <chRegFindThreadByWorkingArea+0x56>
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800144c:	320c      	adds	r2, #12
 800144e:	4452      	add	r2, sl
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8001450:	1c10      	adds	r0, r2, #0
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 8001452:	6363      	str	r3, [r4, #52]	; 0x34
 8001454:	9201      	str	r2, [sp, #4]
 8001456:	f001 fa1b 	bl	8002890 <chMtxLockS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800145a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800145c:	2b00      	cmp	r3, #0
 800145e:	d156      	bne.n	800150e <chRegFindThreadByWorkingArea+0x24e>
 8001460:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001462:	2a00      	cmp	r2, #0
 8001464:	dd53      	ble.n	800150e <chRegFindThreadByWorkingArea+0x24e>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8001466:	6363      	str	r3, [r4, #52]	; 0x34
 8001468:	6823      	ldr	r3, [r4, #0]
 800146a:	42a3      	cmp	r3, r4
 800146c:	d004      	beq.n	8001478 <chRegFindThreadByWorkingArea+0x1b8>
 800146e:	69a2      	ldr	r2, [r4, #24]
 8001470:	689b      	ldr	r3, [r3, #8]
 8001472:	6892      	ldr	r2, [r2, #8]
 8001474:	429a      	cmp	r2, r3
 8001476:	d34d      	bcc.n	8001514 <chRegFindThreadByWorkingArea+0x254>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8001478:	4651      	mov	r1, sl
 800147a:	3104      	adds	r1, #4
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800147c:	b662      	cpsie	i
 800147e:	1c0b      	adds	r3, r1, #0

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8001480:	429f      	cmp	r7, r3
 8001482:	d305      	bcc.n	8001490 <chRegFindThreadByWorkingArea+0x1d0>
 8001484:	685a      	ldr	r2, [r3, #4]
 8001486:	3201      	adds	r2, #1
 8001488:	00d2      	lsls	r2, r2, #3
 800148a:	189a      	adds	r2, r3, r2
 800148c:	4297      	cmp	r7, r2
 800148e:	d3c9      	bcc.n	8001424 <chRegFindThreadByWorkingArea+0x164>

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8001490:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8001492:	4299      	cmp	r1, r3
 8001494:	d001      	beq.n	800149a <chRegFindThreadByWorkingArea+0x1da>
 8001496:	429f      	cmp	r7, r3
 8001498:	d903      	bls.n	80014a2 <chRegFindThreadByWorkingArea+0x1e2>
 800149a:	2a00      	cmp	r2, #0
 800149c:	d005      	beq.n	80014aa <chRegFindThreadByWorkingArea+0x1ea>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 800149e:	4297      	cmp	r7, r2
 80014a0:	d303      	bcc.n	80014aa <chRegFindThreadByWorkingArea+0x1ea>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 80014a2:	1c13      	adds	r3, r2, #0
 80014a4:	e7ec      	b.n	8001480 <chRegFindThreadByWorkingArea+0x1c0>
      return ctp;
    }
    ctp = chRegNextThread(ctp);
  } while (ctp != NULL);

  return NULL;
 80014a6:	4640      	mov	r0, r8
 80014a8:	e775      	b.n	8001396 <chRegFindThreadByWorkingArea+0xd6>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80014aa:	6879      	ldr	r1, [r7, #4]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 80014ac:	603a      	str	r2, [r7, #0]
      H_NEXT(qp) = hp;
 80014ae:	601f      	str	r7, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80014b0:	1c4a      	adds	r2, r1, #1
 80014b2:	00d2      	lsls	r2, r2, #3
 80014b4:	6838      	ldr	r0, [r7, #0]
 80014b6:	18ba      	adds	r2, r7, r2
 80014b8:	4282      	cmp	r2, r0
 80014ba:	d106      	bne.n	80014ca <chRegFindThreadByWorkingArea+0x20a>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80014bc:	6850      	ldr	r0, [r2, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80014be:	6812      	ldr	r2, [r2, #0]
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 80014c0:	4684      	mov	ip, r0
 80014c2:	4461      	add	r1, ip
 80014c4:	3101      	adds	r1, #1
 80014c6:	6079      	str	r1, [r7, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 80014c8:	603a      	str	r2, [r7, #0]
      }
      if ((H_LIMIT(qp) == hp)) {
 80014ca:	685a      	ldr	r2, [r3, #4]
 80014cc:	1c51      	adds	r1, r2, #1
 80014ce:	00c9      	lsls	r1, r1, #3
 80014d0:	1859      	adds	r1, r3, r1
 80014d2:	428f      	cmp	r7, r1
 80014d4:	d106      	bne.n	80014e4 <chRegFindThreadByWorkingArea+0x224>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 80014d6:	6879      	ldr	r1, [r7, #4]
 80014d8:	468c      	mov	ip, r1
 80014da:	4462      	add	r2, ip
 80014dc:	3201      	adds	r2, #1
 80014de:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 80014e0:	683a      	ldr	r2, [r7, #0]
 80014e2:	601a      	str	r2, [r3, #0]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 80014e4:	9801      	ldr	r0, [sp, #4]
 80014e6:	f001 f913 	bl	8002710 <chMtxUnlock>
 80014ea:	e74d      	b.n	8001388 <chRegFindThreadByWorkingArea+0xc8>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 80014ec:	6810      	ldr	r0, [r2, #0]
 80014ee:	6008      	str	r0, [r1, #0]
  mp->next = php;
 80014f0:	6011      	str	r1, [r2, #0]
 80014f2:	6363      	str	r3, [r4, #52]	; 0x34
 80014f4:	6823      	ldr	r3, [r4, #0]
 80014f6:	42a3      	cmp	r3, r4
 80014f8:	d100      	bne.n	80014fc <chRegFindThreadByWorkingArea+0x23c>
 80014fa:	e744      	b.n	8001386 <chRegFindThreadByWorkingArea+0xc6>
 80014fc:	69a2      	ldr	r2, [r4, #24]
 80014fe:	689b      	ldr	r3, [r3, #8]
 8001500:	6892      	ldr	r2, [r2, #8]
 8001502:	429a      	cmp	r2, r3
 8001504:	d300      	bcc.n	8001508 <chRegFindThreadByWorkingArea+0x248>
 8001506:	e73e      	b.n	8001386 <chRegFindThreadByWorkingArea+0xc6>
 8001508:	480d      	ldr	r0, [pc, #52]	; (8001540 <chRegFindThreadByWorkingArea+0x280>)
 800150a:	f7ff fe31 	bl	8001170 <chSysHalt>
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 800150e:	480d      	ldr	r0, [pc, #52]	; (8001544 <chRegFindThreadByWorkingArea+0x284>)
 8001510:	f7ff fe2e 	bl	8001170 <chSysHalt>
 8001514:	480c      	ldr	r0, [pc, #48]	; (8001548 <chRegFindThreadByWorkingArea+0x288>)
 8001516:	f7ff fe2b 	bl	8001170 <chSysHalt>
 800151a:	46c0      	nop			; (mov r8, r8)
 800151c:	20000700 	.word	0x20000700
 8001520:	080036c8 	.word	0x080036c8
 8001524:	080037d4 	.word	0x080037d4
 8001528:	00ff00ff 	.word	0x00ff00ff
 800152c:	080037c4 	.word	0x080037c4
 8001530:	0800379c 	.word	0x0800379c
 8001534:	080037ac 	.word	0x080037ac
 8001538:	08003618 	.word	0x08003618
 800153c:	080037b8 	.word	0x080037b8
 8001540:	080037f0 	.word	0x080037f0
 8001544:	080036f0 	.word	0x080036f0
 8001548:	080036f8 	.word	0x080036f8
 800154c:	00000000 	.word	0x00000000

08001550 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001550:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001552:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001554:	4c39      	ldr	r4, [pc, #228]	; (800163c <chThdExit+0xec>)
 8001556:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001558:	2b00      	cmp	r3, #0
 800155a:	d102      	bne.n	8001562 <chThdExit+0x12>
 800155c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800155e:	2b00      	cmp	r3, #0
 8001560:	d002      	beq.n	8001568 <chThdExit+0x18>
    chSysHalt("SV#4");
 8001562:	4837      	ldr	r0, [pc, #220]	; (8001640 <chThdExit+0xf0>)
 8001564:	f7ff fe04 	bl	8001170 <chSysHalt>
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8001568:	69a5      	ldr	r5, [r4, #24]
  }
  _dbg_enter_lock();
 800156a:	2301      	movs	r3, #1
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800156c:	1c2e      	adds	r6, r5, #0
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 800156e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8001570:	3628      	adds	r6, #40	; 0x28
 8001572:	6363      	str	r3, [r4, #52]	; 0x34
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8001574:	6268      	str	r0, [r5, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 8001576:	42b2      	cmp	r2, r6
 8001578:	d024      	beq.n	80015c4 <chThdExit+0x74>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 800157a:	6813      	ldr	r3, [r2, #0]
 800157c:	62ab      	str	r3, [r5, #40]	; 0x28
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800157e:	2320      	movs	r3, #32
 8001580:	5cd1      	ldrb	r1, [r2, r3]
 8001582:	2900      	cmp	r1, #0
 8001584:	d01b      	beq.n	80015be <chThdExit+0x6e>
 8001586:	290f      	cmp	r1, #15
 8001588:	d019      	beq.n	80015be <chThdExit+0x6e>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800158a:	1c18      	adds	r0, r3, #0
 800158c:	2300      	movs	r3, #0
 800158e:	469c      	mov	ip, r3
 8001590:	4663      	mov	r3, ip
 8001592:	5413      	strb	r3, [r2, r0]
  cp = (thread_t *)&ch.rlist.queue;
 8001594:	1c23      	adds	r3, r4, #0
 8001596:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8001598:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800159a:	689f      	ldr	r7, [r3, #8]
 800159c:	428f      	cmp	r7, r1
 800159e:	d2fb      	bcs.n	8001598 <chThdExit+0x48>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80015a0:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80015a2:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 80015a4:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 80015a6:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 80015a8:	605a      	str	r2, [r3, #4]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80015aa:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 80015ac:	42b2      	cmp	r2, r6
 80015ae:	d009      	beq.n	80015c4 <chThdExit+0x74>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 80015b0:	6813      	ldr	r3, [r2, #0]
 80015b2:	62ab      	str	r3, [r5, #40]	; 0x28
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80015b4:	5c13      	ldrb	r3, [r2, r0]
 80015b6:	2b00      	cmp	r3, #0
 80015b8:	d001      	beq.n	80015be <chThdExit+0x6e>
 80015ba:	2b0f      	cmp	r3, #15
 80015bc:	d1e8      	bne.n	8001590 <chThdExit+0x40>
 80015be:	4821      	ldr	r0, [pc, #132]	; (8001644 <chThdExit+0xf4>)
 80015c0:	f7ff fdd6 	bl	8001170 <chSysHalt>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80015c4:	2322      	movs	r3, #34	; 0x22
 80015c6:	5ceb      	ldrb	r3, [r5, r3]
 80015c8:	2b00      	cmp	r3, #0
 80015ca:	d108      	bne.n	80015de <chThdExit+0x8e>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 80015cc:	2321      	movs	r3, #33	; 0x21
 80015ce:	5ceb      	ldrb	r3, [r5, r3]

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80015d0:	079b      	lsls	r3, r3, #30
 80015d2:	d104      	bne.n	80015de <chThdExit+0x8e>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 80015d4:	692a      	ldr	r2, [r5, #16]
 80015d6:	696b      	ldr	r3, [r5, #20]
 80015d8:	611a      	str	r2, [r3, #16]
 80015da:	692a      	ldr	r2, [r5, #16]
 80015dc:	6153      	str	r3, [r2, #20]
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 80015de:	2220      	movs	r2, #32
 80015e0:	230f      	movs	r3, #15
 80015e2:	54ab      	strb	r3, [r5, r2]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80015e4:	6823      	ldr	r3, [r4, #0]

  tqp->next             = tp->queue.next;
 80015e6:	6819      	ldr	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80015e8:	604c      	str	r4, [r1, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80015ea:	6021      	str	r1, [r4, #0]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80015ec:	2101      	movs	r1, #1
 80015ee:	5499      	strb	r1, [r3, r2]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80015f0:	8f20      	ldrh	r0, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80015f2:	61a3      	str	r3, [r4, #24]
 80015f4:	4208      	tst	r0, r1
 80015f6:	d00c      	beq.n	8001612 <chThdExit+0xc2>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80015f8:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80015fc:	69ea      	ldr	r2, [r5, #28]
 80015fe:	3b24      	subs	r3, #36	; 0x24
 8001600:	429a      	cmp	r2, r3
 8001602:	d818      	bhi.n	8001636 <chThdExit+0xe6>
 8001604:	69a0      	ldr	r0, [r4, #24]
 8001606:	1c29      	adds	r1, r5, #0
 8001608:	f7fe fdc6 	bl	8000198 <_port_switch>

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 800160c:	480e      	ldr	r0, [pc, #56]	; (8001648 <chThdExit+0xf8>)
 800160e:	f7ff fdaf 	bl	8001170 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8001612:	2707      	movs	r7, #7
 8001614:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8001616:	7806      	ldrb	r6, [r0, #0]
 8001618:	43be      	bics	r6, r7
 800161a:	4331      	orrs	r1, r6
 800161c:	7001      	strb	r1, [r0, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800161e:	5ca9      	ldrb	r1, [r5, r2]
 8001620:	7802      	ldrb	r2, [r0, #0]
 8001622:	00c9      	lsls	r1, r1, #3
 8001624:	403a      	ands	r2, r7
 8001626:	430a      	orrs	r2, r1
 8001628:	7002      	strb	r2, [r0, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800162a:	6083      	str	r3, [r0, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800162c:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800162e:	60c3      	str	r3, [r0, #12]
    trace_next();
 8001630:	f7ff fd86 	bl	8001140 <trace_next.lto_priv.45>
 8001634:	e7e0      	b.n	80015f8 <chThdExit+0xa8>
 8001636:	4805      	ldr	r0, [pc, #20]	; (800164c <chThdExit+0xfc>)
 8001638:	f7ff fd9a 	bl	8001170 <chSysHalt>
 800163c:	20000700 	.word	0x20000700
 8001640:	080036c8 	.word	0x080036c8
 8001644:	08003978 	.word	0x08003978
 8001648:	080037fc 	.word	0x080037fc
 800164c:	080036d8 	.word	0x080036d8

08001650 <chSchDoReschedule>:
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8001650:	2001      	movs	r0, #1
 8001652:	2120      	movs	r1, #32
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8001654:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *otp = currp;
 8001656:	4c29      	ldr	r4, [pc, #164]	; (80016fc <chSchDoReschedule+0xac>)
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8001658:	6822      	ldr	r2, [r4, #0]
 800165a:	69a5      	ldr	r5, [r4, #24]

  tqp->next             = tp->queue.next;
 800165c:	6813      	ldr	r3, [r2, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800165e:	605c      	str	r4, [r3, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8001660:	5450      	strb	r0, [r2, r1]
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001662:	6b20      	ldr	r0, [r4, #48]	; 0x30
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8001664:	6023      	str	r3, [r4, #0]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001666:	61a2      	str	r2, [r4, #24]
 8001668:	2800      	cmp	r0, #0
 800166a:	db27      	blt.n	80016bc <chSchDoReschedule+0x6c>
 800166c:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800166e:	2800      	cmp	r0, #0
 8001670:	dd24      	ble.n	80016bc <chSchDoReschedule+0x6c>
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 8001672:	2d00      	cmp	r5, #0
 8001674:	d01f      	beq.n	80016b6 <chSchDoReschedule+0x66>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001676:	5c68      	ldrb	r0, [r5, r1]
 8001678:	2800      	cmp	r0, #0
 800167a:	d01c      	beq.n	80016b6 <chSchDoReschedule+0x66>
 800167c:	280f      	cmp	r0, #15
 800167e:	d01a      	beq.n	80016b6 <chSchDoReschedule+0x66>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001680:	2000      	movs	r0, #0
 8001682:	5468      	strb	r0, [r5, r1]
 8001684:	68a9      	ldr	r1, [r5, #8]
 8001686:	e000      	b.n	800168a <chSchDoReschedule+0x3a>
 8001688:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 800168a:	6898      	ldr	r0, [r3, #8]
 800168c:	4288      	cmp	r0, r1
 800168e:	d8fb      	bhi.n	8001688 <chSchDoReschedule+0x38>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001690:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8001692:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8001694:	6069      	str	r1, [r5, #4]
  tp->queue.prev->queue.next = tp;
 8001696:	600d      	str	r5, [r1, #0]
  cp->queue.prev             = tp;
 8001698:	605d      	str	r5, [r3, #4]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800169a:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800169c:	07db      	lsls	r3, r3, #31
 800169e:	d513      	bpl.n	80016c8 <chSchDoReschedule+0x78>
 80016a0:	f3ef 8309 	mrs	r3, PSP
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80016a4:	69ea      	ldr	r2, [r5, #28]
 80016a6:	3b24      	subs	r3, #36	; 0x24
 80016a8:	429a      	cmp	r2, r3
 80016aa:	d80a      	bhi.n	80016c2 <chSchDoReschedule+0x72>
 80016ac:	1c29      	adds	r1, r5, #0
 80016ae:	69a0      	ldr	r0, [r4, #24]
 80016b0:	f7fe fd72 	bl	8000198 <_port_switch>
}
 80016b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
 80016b6:	4812      	ldr	r0, [pc, #72]	; (8001700 <chSchDoReschedule+0xb0>)
 80016b8:	f7ff fd5a 	bl	8001170 <chSysHalt>
    chSysHalt("SV#10");
 80016bc:	4811      	ldr	r0, [pc, #68]	; (8001704 <chSchDoReschedule+0xb4>)
 80016be:	f7ff fd57 	bl	8001170 <chSysHalt>
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80016c2:	4811      	ldr	r0, [pc, #68]	; (8001708 <chSchDoReschedule+0xb8>)
 80016c4:	f7ff fd54 	bl	8001170 <chSysHalt>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80016c8:	2707      	movs	r7, #7
 80016ca:	2601      	movs	r6, #1
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80016cc:	2120      	movs	r1, #32
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80016ce:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80016d0:	7818      	ldrb	r0, [r3, #0]
 80016d2:	43b8      	bics	r0, r7
 80016d4:	4330      	orrs	r0, r6
 80016d6:	7018      	strb	r0, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80016d8:	5c68      	ldrb	r0, [r5, r1]
 80016da:	7819      	ldrb	r1, [r3, #0]
 80016dc:	00c0      	lsls	r0, r0, #3
 80016de:	4039      	ands	r1, r7
 80016e0:	4301      	orrs	r1, r0
 80016e2:	7019      	strb	r1, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80016e4:	609a      	str	r2, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80016e6:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80016e8:	60da      	str	r2, [r3, #12]
    trace_next();
 80016ea:	f7ff fd29 	bl	8001140 <trace_next.lto_priv.45>
 80016ee:	f3ef 8309 	mrs	r3, PSP
 80016f2:	69ea      	ldr	r2, [r5, #28]
 80016f4:	3b24      	subs	r3, #36	; 0x24
 80016f6:	429a      	cmp	r2, r3
 80016f8:	d9d8      	bls.n	80016ac <chSchDoReschedule+0x5c>
 80016fa:	e7e2      	b.n	80016c2 <chSchDoReschedule+0x72>
 80016fc:	20000700 	.word	0x20000700
 8001700:	08003964 	.word	0x08003964
 8001704:	080036e8 	.word	0x080036e8
 8001708:	080036d8 	.word	0x080036d8
 800170c:	00000000 	.word	0x00000000

08001710 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8001710:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001712:	4647      	mov	r7, r8
 8001714:	b480      	push	{r7}
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001716:	4c9d      	ldr	r4, [pc, #628]	; (800198c <chSchGoSleepTimeoutS+0x27c>)
 8001718:	b086      	sub	sp, #24
 800171a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800171c:	2b00      	cmp	r3, #0
 800171e:	d000      	beq.n	8001722 <chSchGoSleepTimeoutS+0x12>
 8001720:	e09d      	b.n	800185e <chSchGoSleepTimeoutS+0x14e>
 8001722:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001724:	2b00      	cmp	r3, #0
 8001726:	dc00      	bgt.n	800172a <chSchGoSleepTimeoutS+0x1a>
 8001728:	e099      	b.n	800185e <chSchGoSleepTimeoutS+0x14e>

  chDbgCheckClassS();

  if (TIME_INFINITE != timeout) {
 800172a:	1c4b      	adds	r3, r1, #1
 800172c:	d100      	bne.n	8001730 <chSchGoSleepTimeoutS+0x20>
 800172e:	e09c      	b.n	800186a <chSchGoSleepTimeoutS+0x15a>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
 8001730:	69a3      	ldr	r3, [r4, #24]
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8001732:	2900      	cmp	r1, #0
 8001734:	d100      	bne.n	8001738 <chSchGoSleepTimeoutS+0x28>
 8001736:	e095      	b.n	8001864 <chSchGoSleepTimeoutS+0x154>

  vtp->par = par;
 8001738:	ad01      	add	r5, sp, #4
 800173a:	612b      	str	r3, [r5, #16]
  vtp->func = vtfunc;
 800173c:	4b94      	ldr	r3, [pc, #592]	; (8001990 <chSchGoSleepTimeoutS+0x280>)
 800173e:	60eb      	str	r3, [r5, #12]
 8001740:	4b94      	ldr	r3, [pc, #592]	; (8001994 <chSchGoSleepTimeoutS+0x284>)
 8001742:	6a5a      	ldr	r2, [r3, #36]	; 0x24
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001744:	69e3      	ldr	r3, [r4, #28]
 8001746:	b292      	uxth	r2, r2
  {
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001748:	2901      	cmp	r1, #1
 800174a:	d100      	bne.n	800174e <chSchGoSleepTimeoutS+0x3e>
 800174c:	e0ad      	b.n	80018aa <chSchGoSleepTimeoutS+0x19a>
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800174e:	1c26      	adds	r6, r4, #0
 8001750:	361c      	adds	r6, #28
 8001752:	42b3      	cmp	r3, r6
 8001754:	d100      	bne.n	8001758 <chSchGoSleepTimeoutS+0x48>
 8001756:	e0c3      	b.n	80018e0 <chSchGoSleepTimeoutS+0x1d0>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8001758:	8d26      	ldrh	r6, [r4, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 800175a:	1b92      	subs	r2, r2, r6
 800175c:	b292      	uxth	r2, r2
 800175e:	1889      	adds	r1, r1, r2

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8001760:	428a      	cmp	r2, r1
 8001762:	d900      	bls.n	8001766 <chSchGoSleepTimeoutS+0x56>
 8001764:	e099      	b.n	800189a <chSchGoSleepTimeoutS+0x18a>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 8001766:	689a      	ldr	r2, [r3, #8]
 8001768:	4291      	cmp	r1, r2
 800176a:	d213      	bcs.n	8001794 <chSchGoSleepTimeoutS+0x84>
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 800176c:	4f89      	ldr	r7, [pc, #548]	; (8001994 <chSchGoSleepTimeoutS+0x284>)
 800176e:	68ff      	ldr	r7, [r7, #12]
 8001770:	07bf      	lsls	r7, r7, #30
 8001772:	d400      	bmi.n	8001776 <chSchGoSleepTimeoutS+0x66>
 8001774:	e0d5      	b.n	8001922 <chSchGoSleepTimeoutS+0x212>
 8001776:	4f88      	ldr	r7, [pc, #544]	; (8001998 <chSchGoSleepTimeoutS+0x288>)
 8001778:	4688      	mov	r8, r1
 800177a:	42b9      	cmp	r1, r7
 800177c:	d900      	bls.n	8001780 <chSchGoSleepTimeoutS+0x70>
 800177e:	46b8      	mov	r8, r7

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8001780:	4446      	add	r6, r8
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001782:	4f84      	ldr	r7, [pc, #528]	; (8001994 <chSchGoSleepTimeoutS+0x284>)
 8001784:	b2b6      	uxth	r6, r6
 8001786:	637e      	str	r6, [r7, #52]	; 0x34
 8001788:	e004      	b.n	8001794 <chSchGoSleepTimeoutS+0x84>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 800178a:	42ab      	cmp	r3, r5
 800178c:	d06a      	beq.n	8001864 <chSchGoSleepTimeoutS+0x154>

    delta -= p->delta;
    p = p->next;
 800178e:	681b      	ldr	r3, [r3, #0]
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
 8001790:	1a89      	subs	r1, r1, r2
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8001792:	689a      	ldr	r2, [r3, #8]
 8001794:	4291      	cmp	r1, r2
 8001796:	d8f8      	bhi.n	800178a <chSchGoSleepTimeoutS+0x7a>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8001798:	685a      	ldr	r2, [r3, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800179a:	9301      	str	r3, [sp, #4]
  vtp->prev = vtp->next->prev;
 800179c:	606a      	str	r2, [r5, #4]
  vtp->prev->next = vtp;
 800179e:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
 80017a0:	605d      	str	r5, [r3, #4]
  vtp->delta = delta;
 80017a2:	60a9      	str	r1, [r5, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 80017a4:	689a      	ldr	r2, [r3, #8]
 80017a6:	1a51      	subs	r1, r2, r1
 80017a8:	6099      	str	r1, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 80017aa:	2301      	movs	r3, #1
 80017ac:	425b      	negs	r3, r3
 80017ae:	6263      	str	r3, [r4, #36]	; 0x24
 80017b0:	6b23      	ldr	r3, [r4, #48]	; 0x30
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 80017b2:	69a6      	ldr	r6, [r4, #24]
 80017b4:	2b00      	cmp	r3, #0
 80017b6:	d152      	bne.n	800185e <chSchGoSleepTimeoutS+0x14e>
 80017b8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80017ba:	2b00      	cmp	r3, #0
 80017bc:	dd4f      	ble.n	800185e <chSchGoSleepTimeoutS+0x14e>

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 80017be:	2220      	movs	r2, #32
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80017c0:	6823      	ldr	r3, [r4, #0]
 80017c2:	54b0      	strb	r0, [r6, r2]

  tqp->next             = tp->queue.next;
 80017c4:	6819      	ldr	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80017c6:	604c      	str	r4, [r1, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80017c8:	6021      	str	r1, [r4, #0]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80017ca:	2101      	movs	r1, #1
 80017cc:	5499      	strb	r1, [r3, r2]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80017ce:	8f20      	ldrh	r0, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80017d0:	61a3      	str	r3, [r4, #24]
 80017d2:	4201      	tst	r1, r0
 80017d4:	d114      	bne.n	8001800 <chSchGoSleepTimeoutS+0xf0>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80017d6:	2707      	movs	r7, #7
 80017d8:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80017da:	46bc      	mov	ip, r7
 80017dc:	7808      	ldrb	r0, [r1, #0]
 80017de:	43b8      	bics	r0, r7
 80017e0:	1c07      	adds	r7, r0, #0
 80017e2:	2001      	movs	r0, #1
 80017e4:	4338      	orrs	r0, r7
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80017e6:	4667      	mov	r7, ip
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80017e8:	7008      	strb	r0, [r1, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80017ea:	5cb0      	ldrb	r0, [r6, r2]
 80017ec:	780a      	ldrb	r2, [r1, #0]
 80017ee:	00c0      	lsls	r0, r0, #3
 80017f0:	403a      	ands	r2, r7
 80017f2:	4302      	orrs	r2, r0
 80017f4:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80017f6:	608b      	str	r3, [r1, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80017f8:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80017fa:	60cb      	str	r3, [r1, #12]
    trace_next();
 80017fc:	f7ff fca0 	bl	8001140 <trace_next.lto_priv.45>
 8001800:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001804:	69f2      	ldr	r2, [r6, #28]
 8001806:	3b24      	subs	r3, #36	; 0x24
 8001808:	429a      	cmp	r2, r3
 800180a:	d84b      	bhi.n	80018a4 <chSchGoSleepTimeoutS+0x194>
 800180c:	69a0      	ldr	r0, [r4, #24]
 800180e:	1c31      	adds	r1, r6, #0
 8001810:	f7fe fcc2 	bl	8000198 <_port_switch>
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001814:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001816:	2b00      	cmp	r3, #0
 8001818:	da00      	bge.n	800181c <chSchGoSleepTimeoutS+0x10c>
 800181a:	e07f      	b.n	800191c <chSchGoSleepTimeoutS+0x20c>
 800181c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800181e:	2b00      	cmp	r3, #0
 8001820:	dc00      	bgt.n	8001824 <chSchGoSleepTimeoutS+0x114>
 8001822:	e07b      	b.n	800191c <chSchGoSleepTimeoutS+0x20c>
  if (TIME_INFINITE != timeout) {
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt)) {
 8001824:	9b04      	ldr	r3, [sp, #16]
 8001826:	2b00      	cmp	r3, #0
 8001828:	d013      	beq.n	8001852 <chSchGoSleepTimeoutS+0x142>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 800182a:	69e3      	ldr	r3, [r4, #28]
 800182c:	42ab      	cmp	r3, r5
 800182e:	d100      	bne.n	8001832 <chSchGoSleepTimeoutS+0x122>
 8001830:	e07d      	b.n	800192e <chSchGoSleepTimeoutS+0x21e>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8001832:	686a      	ldr	r2, [r5, #4]
 8001834:	9b01      	ldr	r3, [sp, #4]
 8001836:	6013      	str	r3, [r2, #0]
    vtp->next->prev = vtp->prev;
 8001838:	9b01      	ldr	r3, [sp, #4]
 800183a:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 800183c:	2200      	movs	r2, #0
 800183e:	60ea      	str	r2, [r5, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001840:	1c22      	adds	r2, r4, #0
 8001842:	321c      	adds	r2, #28
 8001844:	4293      	cmp	r3, r2
 8001846:	d004      	beq.n	8001852 <chSchGoSleepTimeoutS+0x142>
      vtp->next->delta += vtp->delta;
 8001848:	6899      	ldr	r1, [r3, #8]
 800184a:	68aa      	ldr	r2, [r5, #8]
 800184c:	468c      	mov	ip, r1
 800184e:	4462      	add	r2, ip
 8001850:	609a      	str	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8001852:	69a3      	ldr	r3, [r4, #24]
 8001854:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
 8001856:	b006      	add	sp, #24
 8001858:	bc04      	pop	{r2}
 800185a:	4690      	mov	r8, r2
 800185c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#11");
 800185e:	484f      	ldr	r0, [pc, #316]	; (800199c <chSchGoSleepTimeoutS+0x28c>)
 8001860:	f7ff fc86 	bl	8001170 <chSysHalt>
                vtfunc_t vtfunc, void *par) {
  virtual_timer_t *p;
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8001864:	484e      	ldr	r0, [pc, #312]	; (80019a0 <chSchGoSleepTimeoutS+0x290>)
 8001866:	f7ff fc83 	bl	8001170 <chSysHalt>
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 800186a:	2620      	movs	r6, #32
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800186c:	6821      	ldr	r1, [r4, #0]
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 800186e:	69a5      	ldr	r5, [r4, #24]

  tqp->next             = tp->queue.next;
 8001870:	680b      	ldr	r3, [r1, #0]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 8001872:	55a8      	strb	r0, [r5, r6]
 8001874:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001876:	605c      	str	r4, [r3, #4]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8001878:	2301      	movs	r3, #1
 800187a:	558b      	strb	r3, [r1, r6]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 800187c:	8f22      	ldrh	r2, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800187e:	61a1      	str	r1, [r4, #24]
 8001880:	4213      	tst	r3, r2
 8001882:	d018      	beq.n	80018b6 <chSchGoSleepTimeoutS+0x1a6>
 8001884:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001888:	69ea      	ldr	r2, [r5, #28]
 800188a:	3b24      	subs	r3, #36	; 0x24
 800188c:	429a      	cmp	r2, r3
 800188e:	d809      	bhi.n	80018a4 <chSchGoSleepTimeoutS+0x194>
 8001890:	69a0      	ldr	r0, [r4, #24]
 8001892:	1c29      	adds	r1, r5, #0
 8001894:	f7fe fc80 	bl	8000198 <_port_switch>
 8001898:	e7db      	b.n	8001852 <chSchGoSleepTimeoutS+0x142>

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 800189a:	689a      	ldr	r2, [r3, #8]
      p = p->next;
 800189c:	681b      	ldr	r3, [r3, #0]

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 800189e:	1a89      	subs	r1, r1, r2
 80018a0:	689a      	ldr	r2, [r3, #8]
 80018a2:	e777      	b.n	8001794 <chSchGoSleepTimeoutS+0x84>
 80018a4:	483f      	ldr	r0, [pc, #252]	; (80019a4 <chSchGoSleepTimeoutS+0x294>)
 80018a6:	f7ff fc63 	bl	8001170 <chSysHalt>
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80018aa:	1c21      	adds	r1, r4, #0
 80018ac:	311c      	adds	r1, #28
 80018ae:	428b      	cmp	r3, r1
 80018b0:	d02b      	beq.n	800190a <chSchGoSleepTimeoutS+0x1fa>
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80018b2:	2102      	movs	r1, #2
 80018b4:	e750      	b.n	8001758 <chSchGoSleepTimeoutS+0x48>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80018b6:	2207      	movs	r2, #7
 80018b8:	2701      	movs	r7, #1
 80018ba:	4694      	mov	ip, r2
 80018bc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 80018be:	7818      	ldrb	r0, [r3, #0]
 80018c0:	4390      	bics	r0, r2
 80018c2:	4338      	orrs	r0, r7
 80018c4:	7018      	strb	r0, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80018c6:	5da8      	ldrb	r0, [r5, r6]
 80018c8:	4666      	mov	r6, ip
 80018ca:	781a      	ldrb	r2, [r3, #0]
 80018cc:	00c0      	lsls	r0, r0, #3
 80018ce:	4032      	ands	r2, r6
 80018d0:	4302      	orrs	r2, r0
 80018d2:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80018d4:	6099      	str	r1, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80018d6:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80018d8:	60da      	str	r2, [r3, #12]
    trace_next();
 80018da:	f7ff fc31 	bl	8001140 <trace_next.lto_priv.45>
 80018de:	e7d1      	b.n	8001884 <chSchGoSleepTimeoutS+0x174>
      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 80018e0:	602b      	str	r3, [r5, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80018e2:	606b      	str	r3, [r5, #4]
      vtp->delta = delay;

#if CH_CFG_INTERVALS_SIZE > CH_CFG_ST_RESOLUTION
      /* The delta could be too large for the physical timer to handle.*/
      if (delay > (sysinterval_t)TIME_MAX_SYSTIME) {
 80018e4:	4b2c      	ldr	r3, [pc, #176]	; (8001998 <chSchGoSleepTimeoutS+0x288>)
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 80018e6:	8522      	strh	r2, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 80018e8:	61e5      	str	r5, [r4, #28]
      ch.vtlist.prev = vtp;
 80018ea:	6225      	str	r5, [r4, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 80018ec:	60a9      	str	r1, [r5, #8]

#if CH_CFG_INTERVALS_SIZE > CH_CFG_ST_RESOLUTION
      /* The delta could be too large for the physical timer to handle.*/
      if (delay > (sysinterval_t)TIME_MAX_SYSTIME) {
 80018ee:	1c1e      	adds	r6, r3, #0
 80018f0:	4299      	cmp	r1, r3
 80018f2:	d911      	bls.n	8001918 <chSchGoSleepTimeoutS+0x208>
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80018f4:	2702      	movs	r7, #2
 80018f6:	4927      	ldr	r1, [pc, #156]	; (8001994 <chSchGoSleepTimeoutS+0x284>)
 80018f8:	68cb      	ldr	r3, [r1, #12]
 80018fa:	403b      	ands	r3, r7
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80018fc:	d114      	bne.n	8001928 <chSchGoSleepTimeoutS+0x218>
 80018fe:	18b2      	adds	r2, r6, r2
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001900:	b292      	uxth	r2, r2
 8001902:	634a      	str	r2, [r1, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8001904:	610b      	str	r3, [r1, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8001906:	60cf      	str	r7, [r1, #12]
 8001908:	e752      	b.n	80017b0 <chSchGoSleepTimeoutS+0xa0>
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 800190a:	2102      	movs	r1, #2
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 800190c:	8522      	strh	r2, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
 800190e:	61e5      	str	r5, [r4, #28]
      ch.vtlist.prev = vtp;
 8001910:	6225      	str	r5, [r4, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8001912:	602b      	str	r3, [r5, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8001914:	606b      	str	r3, [r5, #4]
      vtp->delta = delay;
 8001916:	60a9      	str	r1, [r5, #8]
 8001918:	b28e      	uxth	r6, r1
 800191a:	e7eb      	b.n	80018f4 <chSchGoSleepTimeoutS+0x1e4>
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#10");
 800191c:	4822      	ldr	r0, [pc, #136]	; (80019a8 <chSchGoSleepTimeoutS+0x298>)
 800191e:	f7ff fc27 	bl	8001170 <chSysHalt>
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8001922:	4822      	ldr	r0, [pc, #136]	; (80019ac <chSchGoSleepTimeoutS+0x29c>)
 8001924:	f7ff fc24 	bl	8001170 <chSysHalt>
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8001928:	4821      	ldr	r0, [pc, #132]	; (80019b0 <chSchGoSleepTimeoutS+0x2a0>)
 800192a:	f7ff fc21 	bl	8001170 <chSysHalt>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 800192e:	2300      	movs	r3, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8001930:	6829      	ldr	r1, [r5, #0]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8001932:	4a20      	ldr	r2, [pc, #128]	; (80019b4 <chSchGoSleepTimeoutS+0x2a4>)

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8001934:	61e1      	str	r1, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8001936:	604a      	str	r2, [r1, #4]
  vtp->func = NULL;
 8001938:	60eb      	str	r3, [r5, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800193a:	4291      	cmp	r1, r2
 800193c:	d022      	beq.n	8001984 <chSchGoSleepTimeoutS+0x274>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800193e:	68ab      	ldr	r3, [r5, #8]
 8001940:	688a      	ldr	r2, [r1, #8]
 8001942:	189a      	adds	r2, r3, r2
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001944:	4b13      	ldr	r3, [pc, #76]	; (8001994 <chSchGoSleepTimeoutS+0x284>)
 8001946:	608a      	str	r2, [r1, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8001948:	8d20      	ldrh	r0, [r4, #40]	; 0x28
 800194a:	6a59      	ldr	r1, [r3, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 800194c:	1a09      	subs	r1, r1, r0
 800194e:	b289      	uxth	r1, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8001950:	428a      	cmp	r2, r1
 8001952:	d800      	bhi.n	8001956 <chSchGoSleepTimeoutS+0x246>
 8001954:	e77d      	b.n	8001852 <chSchGoSleepTimeoutS+0x142>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8001956:	1a53      	subs	r3, r2, r1

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001958:	2b01      	cmp	r3, #1
 800195a:	d90c      	bls.n	8001976 <chSchGoSleepTimeoutS+0x266>
 800195c:	1e13      	subs	r3, r2, #0
 800195e:	4a0e      	ldr	r2, [pc, #56]	; (8001998 <chSchGoSleepTimeoutS+0x288>)
 8001960:	4293      	cmp	r3, r2
 8001962:	d900      	bls.n	8001966 <chSchGoSleepTimeoutS+0x256>
 8001964:	1c13      	adds	r3, r2, #0
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001966:	4a0b      	ldr	r2, [pc, #44]	; (8001994 <chSchGoSleepTimeoutS+0x284>)
 8001968:	68d1      	ldr	r1, [r2, #12]
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800196a:	0789      	lsls	r1, r1, #30
 800196c:	d5d9      	bpl.n	8001922 <chSchGoSleepTimeoutS+0x212>

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 800196e:	18c3      	adds	r3, r0, r3
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001970:	b29b      	uxth	r3, r3
 8001972:	6353      	str	r3, [r2, #52]	; 0x34
 8001974:	e76d      	b.n	8001852 <chSchGoSleepTimeoutS+0x142>
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
 8001976:	4a08      	ldr	r2, [pc, #32]	; (8001998 <chSchGoSleepTimeoutS+0x288>)
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8001978:	1c8b      	adds	r3, r1, #2
 800197a:	4293      	cmp	r3, r2
 800197c:	d9f3      	bls.n	8001966 <chSchGoSleepTimeoutS+0x256>
 800197e:	480e      	ldr	r0, [pc, #56]	; (80019b8 <chSchGoSleepTimeoutS+0x2a8>)
 8001980:	f7ff fbf6 	bl	8001170 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001984:	4a03      	ldr	r2, [pc, #12]	; (8001994 <chSchGoSleepTimeoutS+0x284>)
 8001986:	60d3      	str	r3, [r2, #12]
 8001988:	e763      	b.n	8001852 <chSchGoSleepTimeoutS+0x142>
 800198a:	46c0      	nop			; (mov r8, r8)
 800198c:	20000700 	.word	0x20000700
 8001990:	080019c1 	.word	0x080019c1
 8001994:	40000400 	.word	0x40000400
 8001998:	0000ffff 	.word	0x0000ffff
 800199c:	080036d0 	.word	0x080036d0
 80019a0:	08003758 	.word	0x08003758
 80019a4:	080036d8 	.word	0x080036d8
 80019a8:	080036e8 	.word	0x080036e8
 80019ac:	08003714 	.word	0x08003714
 80019b0:	08003690 	.word	0x08003690
 80019b4:	2000071c 	.word	0x2000071c
 80019b8:	08003624 	.word	0x08003624
 80019bc:	00000000 	.word	0x00000000

080019c0 <wakeup.lto_priv.56>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80019c0:	b538      	push	{r3, r4, r5, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80019c2:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80019c4:	4b27      	ldr	r3, [pc, #156]	; (8001a64 <wakeup.lto_priv.56+0xa4>)
 80019c6:	6b19      	ldr	r1, [r3, #48]	; 0x30
 80019c8:	2900      	cmp	r1, #0
 80019ca:	dd02      	ble.n	80019d2 <wakeup.lto_priv.56+0x12>
 80019cc:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80019ce:	2a00      	cmp	r2, #0
 80019d0:	d002      	beq.n	80019d8 <wakeup.lto_priv.56+0x18>
    chSysHalt("SV#6");
 80019d2:	4825      	ldr	r0, [pc, #148]	; (8001a68 <wakeup.lto_priv.56+0xa8>)
 80019d4:	f7ff fbcc 	bl	8001170 <chSysHalt>
  }
  _dbg_enter_lock();
 80019d8:	2201      	movs	r2, #1
 80019da:	635a      	str	r2, [r3, #52]	; 0x34
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 80019dc:	321f      	adds	r2, #31
 80019de:	5c82      	ldrb	r2, [r0, r2]
 80019e0:	2a07      	cmp	r2, #7
 80019e2:	d831      	bhi.n	8001a48 <wakeup.lto_priv.56+0x88>
 80019e4:	4c21      	ldr	r4, [pc, #132]	; (8001a6c <wakeup.lto_priv.56+0xac>)
 80019e6:	0092      	lsls	r2, r2, #2
 80019e8:	58a2      	ldr	r2, [r4, r2]
 80019ea:	4697      	mov	pc, r2
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 80019ec:	6a41      	ldr	r1, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 80019ee:	688a      	ldr	r2, [r1, #8]
 80019f0:	3201      	adds	r2, #1
 80019f2:	608a      	str	r2, [r1, #8]
 80019f4:	6b19      	ldr	r1, [r3, #48]	; 0x30
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80019f6:	6842      	ldr	r2, [r0, #4]
 80019f8:	6804      	ldr	r4, [r0, #0]
 80019fa:	6014      	str	r4, [r2, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80019fc:	6804      	ldr	r4, [r0, #0]
 80019fe:	6062      	str	r2, [r4, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8001a00:	2201      	movs	r2, #1
 8001a02:	4252      	negs	r2, r2
 8001a04:	6242      	str	r2, [r0, #36]	; 0x24
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001a06:	2900      	cmp	r1, #0
 8001a08:	db22      	blt.n	8001a50 <wakeup.lto_priv.56+0x90>
 8001a0a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001a0c:	2a00      	cmp	r2, #0
 8001a0e:	dd1f      	ble.n	8001a50 <wakeup.lto_priv.56+0x90>
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001a10:	2420      	movs	r4, #32
 8001a12:	5d02      	ldrb	r2, [r0, r4]
 8001a14:	2a00      	cmp	r2, #0
 8001a16:	d01e      	beq.n	8001a56 <wakeup.lto_priv.56+0x96>
 8001a18:	2a0f      	cmp	r2, #15
 8001a1a:	d01c      	beq.n	8001a56 <wakeup.lto_priv.56+0x96>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001a1c:	2200      	movs	r2, #0
 8001a1e:	5502      	strb	r2, [r0, r4]
  cp = (thread_t *)&ch.rlist.queue;
 8001a20:	1c1a      	adds	r2, r3, #0
 8001a22:	6884      	ldr	r4, [r0, #8]
  do {
    cp = cp->queue.next;
 8001a24:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8001a26:	6895      	ldr	r5, [r2, #8]
 8001a28:	42ac      	cmp	r4, r5
 8001a2a:	d9fb      	bls.n	8001a24 <wakeup.lto_priv.56+0x64>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8001a2c:	6854      	ldr	r4, [r2, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8001a2e:	6002      	str	r2, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8001a30:	6044      	str	r4, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8001a32:	6020      	str	r0, [r4, #0]
  cp->queue.prev             = tp;
 8001a34:	6050      	str	r0, [r2, #4]
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001a36:	2900      	cmp	r1, #0
 8001a38:	d010      	beq.n	8001a5c <wakeup.lto_priv.56+0x9c>
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8001a3a:	2200      	movs	r2, #0
 8001a3c:	635a      	str	r2, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001a3e:	b662      	cpsie	i
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001a40:	bd38      	pop	{r3, r4, r5, pc}
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8001a42:	2400      	movs	r4, #0
 8001a44:	6a42      	ldr	r2, [r0, #36]	; 0x24
 8001a46:	6014      	str	r4, [r2, #0]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8001a48:	2201      	movs	r2, #1
 8001a4a:	4252      	negs	r2, r2
 8001a4c:	6242      	str	r2, [r0, #36]	; 0x24
 8001a4e:	e7dc      	b.n	8001a0a <wakeup.lto_priv.56+0x4a>
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#10");
 8001a50:	4807      	ldr	r0, [pc, #28]	; (8001a70 <wakeup.lto_priv.56+0xb0>)
 8001a52:	f7ff fb8d 	bl	8001170 <chSysHalt>
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001a56:	4807      	ldr	r0, [pc, #28]	; (8001a74 <wakeup.lto_priv.56+0xb4>)
 8001a58:	f7ff fb8a 	bl	8001170 <chSysHalt>
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
 8001a5c:	4806      	ldr	r0, [pc, #24]	; (8001a78 <wakeup.lto_priv.56+0xb8>)
 8001a5e:	f7ff fb87 	bl	8001170 <chSysHalt>
 8001a62:	46c0      	nop			; (mov r8, r8)
 8001a64:	20000700 	.word	0x20000700
 8001a68:	080037e0 	.word	0x080037e0
 8001a6c:	0800377c 	.word	0x0800377c
 8001a70:	080036e8 	.word	0x080036e8
 8001a74:	08003978 	.word	0x08003978
 8001a78:	080037e8 	.word	0x080037e8
 8001a7c:	00000000 	.word	0x00000000

08001a80 <_idle_thread.lto_priv.61>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001a80:	e7fe      	b.n	8001a80 <_idle_thread.lto_priv.61>
 8001a82:	46c0      	nop			; (mov r8, r8)
	...

08001a90 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 8001a90:	20bc      	movs	r0, #188	; 0xbc
 8001a92:	4a47      	ldr	r2, [pc, #284]	; (8001bb0 <__early_init+0x120>)
 8001a94:	03c0      	lsls	r0, r0, #15
 8001a96:	6a91      	ldr	r1, [r2, #40]	; 0x28
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 8001a98:	b530      	push	{r4, r5, lr}

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 8001a9a:	4301      	orrs	r1, r0
 8001a9c:	6291      	str	r1, [r2, #40]	; 0x28
 8001a9e:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8001aa0:	4944      	ldr	r1, [pc, #272]	; (8001bb4 <__early_init+0x124>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8001aa2:	4c45      	ldr	r4, [pc, #276]	; (8001bb8 <__early_init+0x128>)

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
 8001aa4:	4019      	ands	r1, r3
 8001aa6:	6291      	str	r1, [r2, #40]	; 0x28
 8001aa8:	6a93      	ldr	r3, [r2, #40]	; 0x28
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 8001aaa:	6953      	ldr	r3, [r2, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001aac:	2180      	movs	r1, #128	; 0x80
static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB(STM32_GPIO_EN_MASK);
  rccEnableAHB(STM32_GPIO_EN_MASK, true);
 8001aae:	4303      	orrs	r3, r0
 8001ab0:	6153      	str	r3, [r2, #20]
 8001ab2:	6953      	ldr	r3, [r2, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001ab4:	2390      	movs	r3, #144	; 0x90
  gpiop->OSPEEDR = config->ospeedr;
 8001ab6:	2001      	movs	r0, #1
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001ab8:	05db      	lsls	r3, r3, #23
 8001aba:	00c9      	lsls	r1, r1, #3
 8001abc:	6059      	str	r1, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8001abe:	493f      	ldr	r1, [pc, #252]	; (8001bbc <__early_init+0x12c>)
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8001ac0:	4240      	negs	r0, r0
 8001ac2:	6098      	str	r0, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8001ac4:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 8001ac6:	493e      	ldr	r1, [pc, #248]	; (8001bc0 <__early_init+0x130>)
  gpiop->AFRL    = config->afrl;
 8001ac8:	2588      	movs	r5, #136	; 0x88
static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8001aca:	6159      	str	r1, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8001acc:	2188      	movs	r1, #136	; 0x88
 8001ace:	0149      	lsls	r1, r1, #5
 8001ad0:	6219      	str	r1, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8001ad2:	2100      	movs	r1, #0
 8001ad4:	6259      	str	r1, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001ad6:	601c      	str	r4, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001ad8:	24c0      	movs	r4, #192	; 0xc0
 8001ada:	4b3a      	ldr	r3, [pc, #232]	; (8001bc4 <__early_init+0x134>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8001adc:	056d      	lsls	r5, r5, #21
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001ade:	605c      	str	r4, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8001ae0:	4c39      	ldr	r4, [pc, #228]	; (8001bc8 <__early_init+0x138>)
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8001ae2:	6098      	str	r0, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8001ae4:	60dc      	str	r4, [r3, #12]
  gpiop->ODR     = config->odr;
 8001ae6:	4c39      	ldr	r4, [pc, #228]	; (8001bcc <__early_init+0x13c>)
 8001ae8:	615c      	str	r4, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8001aea:	621d      	str	r5, [r3, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8001aec:	4d38      	ldr	r5, [pc, #224]	; (8001bd0 <__early_init+0x140>)
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8001aee:	6259      	str	r1, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001af0:	601d      	str	r5, [r3, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001af2:	4b38      	ldr	r3, [pc, #224]	; (8001bd4 <__early_init+0x144>)
 8001af4:	6059      	str	r1, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001af6:	6098      	str	r0, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8001af8:	4837      	ldr	r0, [pc, #220]	; (8001bd8 <__early_init+0x148>)
 8001afa:	60d8      	str	r0, [r3, #12]
  gpiop->ODR     = config->odr;
 8001afc:	615c      	str	r4, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8001afe:	6219      	str	r1, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8001b00:	6259      	str	r1, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001b02:	6019      	str	r1, [r3, #0]
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001b04:	2301      	movs	r3, #1
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001b06:	2002      	movs	r0, #2
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001b08:	6811      	ldr	r1, [r2, #0]
 8001b0a:	430b      	orrs	r3, r1
 8001b0c:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001b0e:	6811      	ldr	r1, [r2, #0]
 8001b10:	4b27      	ldr	r3, [pc, #156]	; (8001bb0 <__early_init+0x120>)
 8001b12:	4208      	tst	r0, r1
 8001b14:	d0fb      	beq.n	8001b0e <__early_init+0x7e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8001b16:	2103      	movs	r1, #3
 8001b18:	685a      	ldr	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001b1a:	200c      	movs	r0, #12
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8001b1c:	438a      	bics	r2, r1
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001b1e:	1c19      	adds	r1, r3, #0
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8001b20:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001b22:	684b      	ldr	r3, [r1, #4]
 8001b24:	4a22      	ldr	r2, [pc, #136]	; (8001bb0 <__early_init+0x120>)
 8001b26:	4003      	ands	r3, r0
 8001b28:	d1fb      	bne.n	8001b22 <__early_init+0x92>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001b2a:	20f9      	movs	r0, #249	; 0xf9
 8001b2c:	6811      	ldr	r1, [r2, #0]
 8001b2e:	4001      	ands	r1, r0
 8001b30:	6011      	str	r1, [r2, #0]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8001b32:	2180      	movs	r1, #128	; 0x80
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 8001b34:	2080      	movs	r0, #128	; 0x80
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001b36:	6053      	str	r3, [r2, #4]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8001b38:	6813      	ldr	r3, [r2, #0]
 8001b3a:	0249      	lsls	r1, r1, #9
 8001b3c:	430b      	orrs	r3, r1
 8001b3e:	6013      	str	r3, [r2, #0]
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 8001b40:	0280      	lsls	r0, r0, #10
 8001b42:	6811      	ldr	r1, [r2, #0]
 8001b44:	4b1a      	ldr	r3, [pc, #104]	; (8001bb0 <__early_init+0x120>)
 8001b46:	4201      	tst	r1, r0
 8001b48:	d0fb      	beq.n	8001b42 <__early_init+0xb2>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8001b4a:	2201      	movs	r2, #1
 8001b4c:	6b59      	ldr	r1, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8001b4e:	2002      	movs	r0, #2
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_HSI14_ENABLED
  /* HSI14 activation.*/
  RCC->CR2 |= RCC_CR2_HSI14ON;
 8001b50:	430a      	orrs	r2, r1
 8001b52:	635a      	str	r2, [r3, #52]	; 0x34
  while (!(RCC->CR2 & RCC_CR2_HSI14RDY))
 8001b54:	1c1a      	adds	r2, r3, #0
 8001b56:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8001b58:	4b15      	ldr	r3, [pc, #84]	; (8001bb0 <__early_init+0x120>)
 8001b5a:	4208      	tst	r0, r1
 8001b5c:	d0fb      	beq.n	8001b56 <__early_init+0xc6>
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001b5e:	2201      	movs	r2, #1
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001b60:	2002      	movs	r0, #2
    ;                                       /* Waits until HSI48 is stable. */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001b62:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8001b64:	430a      	orrs	r2, r1
 8001b66:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001b68:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001b6a:	4911      	ldr	r1, [pc, #68]	; (8001bb0 <__early_init+0x120>)
 8001b6c:	4210      	tst	r0, r2
 8001b6e:	d0fb      	beq.n	8001b68 <__early_init+0xd8>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  /* CFGR2 must be configured first since CFGR value could change CFGR2 */
  RCC->CFGR2 = STM32_PREDIV;
 8001b70:	2302      	movs	r3, #2
 8001b72:	62cb      	str	r3, [r1, #44]	; 0x2c
  RCC->CFGR  = STM32_PLLNODIV | STM32_MCOPRE | STM32_MCOSEL | STM32_PLLMUL |
 8001b74:	23a0      	movs	r3, #160	; 0xa0
 8001b76:	02db      	lsls	r3, r3, #11
 8001b78:	604b      	str	r3, [r1, #4]
               STM32_PLLSRC   | STM32_PPRE   | STM32_HPRE |
               ((STM32_PREDIV & STM32_PLLXTPRE_MASK) << STM32_PLLXTPRE_OFFSET);
#if STM32_CECSW == STM32_CECSW_OFF
  RCC->CFGR3 = STM32_USBSW  | STM32_I2C1SW | STM32_USART1SW;
 8001b7a:	2311      	movs	r3, #17
 8001b7c:	630b      	str	r3, [r1, #48]	; 0x30
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8001b7e:	2101      	movs	r1, #1
  while (!(RCC->CR & RCC_CR_PLLRDY))
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001b80:	4a16      	ldr	r2, [pc, #88]	; (8001bdc <__early_init+0x14c>)
 8001b82:	3b01      	subs	r3, #1
 8001b84:	6013      	str	r3, [r2, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 8001b86:	6813      	ldr	r3, [r2, #0]
 8001b88:	4219      	tst	r1, r3
 8001b8a:	d1fc      	bne.n	8001b86 <__early_init+0xf6>
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001b8c:	2301      	movs	r3, #1
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001b8e:	200c      	movs	r0, #12
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001b90:	4a07      	ldr	r2, [pc, #28]	; (8001bb0 <__early_init+0x120>)
 8001b92:	6851      	ldr	r1, [r2, #4]
 8001b94:	430b      	orrs	r3, r1
 8001b96:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001b98:	6853      	ldr	r3, [r2, #4]
 8001b9a:	4905      	ldr	r1, [pc, #20]	; (8001bb0 <__early_init+0x120>)
 8001b9c:	4003      	ands	r3, r0
 8001b9e:	2b04      	cmp	r3, #4
 8001ba0:	d1fa      	bne.n	8001b98 <__early_init+0x108>
    ;                                       /* Waits selection complete.    */
#endif

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8001ba2:	698a      	ldr	r2, [r1, #24]
 8001ba4:	3b03      	subs	r3, #3
 8001ba6:	4313      	orrs	r3, r2
 8001ba8:	618b      	str	r3, [r1, #24]
 8001baa:	698b      	ldr	r3, [r1, #24]
 */
void __early_init(void) {

  stm32_gpio_init();
  stm32_clock_init();
}
 8001bac:	bd30      	pop	{r4, r5, pc}
 8001bae:	46c0      	nop			; (mov r8, r8)
 8001bb0:	40021000 	.word	0x40021000
 8001bb4:	ffa1ffff 	.word	0xffa1ffff
 8001bb8:	282054ac 	.word	0x282054ac
 8001bbc:	65555555 	.word	0x65555555
 8001bc0:	0000ff1f 	.word	0x0000ff1f
 8001bc4:	48000400 	.word	0x48000400
 8001bc8:	55555555 	.word	0x55555555
 8001bcc:	0000ffff 	.word	0x0000ffff
 8001bd0:	0000a005 	.word	0x0000a005
 8001bd4:	48000800 	.word	0x48000800
 8001bd8:	05555555 	.word	0x05555555
 8001bdc:	40022000 	.word	0x40022000

08001be0 <Vector80>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001be0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001be2:	4645      	mov	r5, r8
 8001be4:	4657      	mov	r7, sl
 8001be6:	464e      	mov	r6, r9
 8001be8:	b4e0      	push	{r5, r6, r7}
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001bea:	4c66      	ldr	r4, [pc, #408]	; (8001d84 <Vector80+0x1a4>)

  OSAL_IRQ_PROLOGUE();
 8001bec:	4675      	mov	r5, lr
 8001bee:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8001bf0:	079b      	lsls	r3, r3, #30
 8001bf2:	d40d      	bmi.n	8001c10 <Vector80+0x30>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001bf4:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001bf6:	2007      	movs	r0, #7
 8001bf8:	2202      	movs	r2, #2
 8001bfa:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001bfc:	780b      	ldrb	r3, [r1, #0]
 8001bfe:	4383      	bics	r3, r0
 8001c00:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8001c02:	4003      	ands	r3, r0
 8001c04:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8001c06:	4b60      	ldr	r3, [pc, #384]	; (8001d88 <Vector80+0x1a8>)
 8001c08:	608b      	str	r3, [r1, #8]
    trace_next();
 8001c0a:	f7ff fa99 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c0e:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c10:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001c12:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001c14:	2b00      	cmp	r3, #0
 8001c16:	db02      	blt.n	8001c1e <Vector80+0x3e>
 8001c18:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001c1a:	2a00      	cmp	r2, #0
 8001c1c:	d002      	beq.n	8001c24 <Vector80+0x44>
    chSysHalt("SV#8");
 8001c1e:	485b      	ldr	r0, [pc, #364]	; (8001d8c <Vector80+0x1ac>)
 8001c20:	f7ff faa6 	bl	8001170 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8001c24:	3301      	adds	r3, #1
 8001c26:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c28:	b662      	cpsie	i

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8001c2a:	4b59      	ldr	r3, [pc, #356]	; (8001d90 <Vector80+0x1b0>)
 8001c2c:	6919      	ldr	r1, [r3, #16]
 8001c2e:	0789      	lsls	r1, r1, #30
 8001c30:	d409      	bmi.n	8001c46 <Vector80+0x66>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c32:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001c34:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001c36:	2b00      	cmp	r3, #0
 8001c38:	dd02      	ble.n	8001c40 <Vector80+0x60>
 8001c3a:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001c3c:	2a00      	cmp	r2, #0
 8001c3e:	d00d      	beq.n	8001c5c <Vector80+0x7c>
    chSysHalt("SV#9");
 8001c40:	4854      	ldr	r0, [pc, #336]	; (8001d94 <Vector80+0x1b4>)
 8001c42:	f7ff fa95 	bl	8001170 <chSysHalt>
    STM32_ST_TIM->SR = 0U;
 8001c46:	611a      	str	r2, [r3, #16]
 8001c48:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001c4a:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001c4c:	2a00      	cmp	r2, #0
 8001c4e:	dd02      	ble.n	8001c56 <Vector80+0x76>
 8001c50:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001c52:	2a00      	cmp	r2, #0
 8001c54:	d032      	beq.n	8001cbc <Vector80+0xdc>
    chSysHalt("SV#6");
 8001c56:	4850      	ldr	r0, [pc, #320]	; (8001d98 <Vector80+0x1b8>)
 8001c58:	f7ff fa8a 	bl	8001170 <chSysHalt>

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 8001c5c:	3b01      	subs	r3, #1
 8001c5e:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001c60:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001c62:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8001c64:	079b      	lsls	r3, r3, #30
 8001c66:	d517      	bpl.n	8001c98 <Vector80+0xb8>
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8001c68:	350f      	adds	r5, #15
 8001c6a:	d010      	beq.n	8001c8e <Vector80+0xae>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c6c:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001c6e:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8001c72:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8001c74:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001c78:	2280      	movs	r2, #128	; 0x80
 8001c7a:	0452      	lsls	r2, r2, #17
 8001c7c:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8001c7e:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8001c80:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001c82:	6889      	ldr	r1, [r1, #8]
 8001c84:	6892      	ldr	r2, [r2, #8]
 8001c86:	4291      	cmp	r1, r2
 8001c88:	d815      	bhi.n	8001cb6 <Vector80+0xd6>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001c8a:	4a44      	ldr	r2, [pc, #272]	; (8001d9c <Vector80+0x1bc>)
 8001c8c:	619a      	str	r2, [r3, #24]
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8001c8e:	bc1c      	pop	{r2, r3, r4}
 8001c90:	4690      	mov	r8, r2
 8001c92:	4699      	mov	r9, r3
 8001c94:	46a2      	mov	sl, r4
 8001c96:	bdf0      	pop	{r4, r5, r6, r7, pc}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001c98:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001c9a:	2007      	movs	r0, #7
 8001c9c:	2203      	movs	r2, #3
 8001c9e:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001ca0:	780b      	ldrb	r3, [r1, #0]
 8001ca2:	4383      	bics	r3, r0
 8001ca4:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8001ca6:	4003      	ands	r3, r0
 8001ca8:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8001caa:	4b37      	ldr	r3, [pc, #220]	; (8001d88 <Vector80+0x1a8>)
 8001cac:	608b      	str	r3, [r1, #8]
    trace_next();
 8001cae:	f7ff fa47 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001cb2:	b662      	cpsie	i
 8001cb4:	e7d8      	b.n	8001c68 <Vector80+0x88>

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001cb6:	4a3a      	ldr	r2, [pc, #232]	; (8001da0 <Vector80+0x1c0>)
 8001cb8:	619a      	str	r2, [r3, #24]
 8001cba:	e7e8      	b.n	8001c8e <Vector80+0xae>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001cbc:	1c1e      	adds	r6, r3, #0

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001cbe:	231c      	movs	r3, #28
 8001cc0:	4698      	mov	r8, r3
      ch.vtlist.next = vtp->next;
      fn = vtp->func;
      vtp->func = NULL;
 8001cc2:	2700      	movs	r7, #0
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8001cc4:	3201      	adds	r2, #1
 8001cc6:	6362      	str	r2, [r4, #52]	; 0x34
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 8001cc8:	69e2      	ldr	r2, [r4, #28]

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001cca:	44a0      	add	r8, r4
 8001ccc:	6a71      	ldr	r1, [r6, #36]	; 0x24
  vtp = ch.vtlist.next;
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 8001cce:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8001cd0:	b289      	uxth	r1, r1
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8001cd2:	1ac8      	subs	r0, r1, r3
 8001cd4:	b280      	uxth	r0, r0
 8001cd6:	4681      	mov	r9, r0

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 8001cd8:	6890      	ldr	r0, [r2, #8]
 8001cda:	4682      	mov	sl, r0
 8001cdc:	4581      	cmp	r9, r0
 8001cde:	d321      	bcc.n	8001d24 <Vector80+0x144>

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001ce0:	4641      	mov	r1, r8
    /* Consuming all timers between "vtp->lasttime" and now.*/
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
 8001ce2:	4453      	add	r3, sl
 8001ce4:	8523      	strh	r3, [r4, #40]	; 0x28
      nowdelta -= vtp->delta;

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8001ce6:	6813      	ldr	r3, [r2, #0]
 8001ce8:	6059      	str	r1, [r3, #4]
      ch.vtlist.next = vtp->next;
 8001cea:	61e3      	str	r3, [r4, #28]
      fn = vtp->func;
 8001cec:	68d1      	ldr	r1, [r2, #12]
      vtp->func = NULL;
 8001cee:	60d7      	str	r7, [r2, #12]

      /* If the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8001cf0:	4543      	cmp	r3, r8
 8001cf2:	d03d      	beq.n	8001d70 <Vector80+0x190>
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8001cf4:	6367      	str	r7, [r4, #52]	; 0x34
 8001cf6:	b662      	cpsie	i
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 8001cf8:	6910      	ldr	r0, [r2, #16]
 8001cfa:	4788      	blx	r1
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001cfc:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001cfe:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001d00:	2b00      	cmp	r3, #0
 8001d02:	dda8      	ble.n	8001c56 <Vector80+0x76>
 8001d04:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001d06:	2b00      	cmp	r3, #0
 8001d08:	d1a5      	bne.n	8001c56 <Vector80+0x76>
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
      nowdelta -= vtp->delta;
 8001d0a:	4652      	mov	r2, sl
 8001d0c:	464b      	mov	r3, r9
 8001d0e:	1a9b      	subs	r3, r3, r2
 8001d10:	4699      	mov	r9, r3
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8001d12:	2301      	movs	r3, #1
      chSysUnlockFromISR();
      fn(vtp->par);
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 8001d14:	69e2      	ldr	r2, [r4, #28]
 8001d16:	6363      	str	r3, [r4, #52]	; 0x34
    }
    while (vtp->delta <= nowdelta);
 8001d18:	6893      	ldr	r3, [r2, #8]
 8001d1a:	469a      	mov	sl, r3
 8001d1c:	4599      	cmp	r9, r3
 8001d1e:	d3d5      	bcc.n	8001ccc <Vector80+0xec>
 8001d20:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 8001d22:	e7dd      	b.n	8001ce0 <Vector80+0x100>
  }

  /* If the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8001d24:	1c20      	adds	r0, r4, #0
 8001d26:	301c      	adds	r0, #28
 8001d28:	4282      	cmp	r2, r0
 8001d2a:	d01d      	beq.n	8001d68 <Vector80+0x188>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
  ch.vtlist.next->delta -= nowdelta;
 8001d2c:	464e      	mov	r6, r9
 8001d2e:	6890      	ldr	r0, [r2, #8]
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 8001d30:	444b      	add	r3, r9
 8001d32:	b29b      	uxth	r3, r3
  ch.vtlist.next->delta -= nowdelta;
 8001d34:	1b80      	subs	r0, r0, r6
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 8001d36:	8523      	strh	r3, [r4, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 8001d38:	6090      	str	r0, [r2, #8]
 8001d3a:	1aca      	subs	r2, r1, r3
 8001d3c:	b292      	uxth	r2, r2

  /* Recalculating the next alarm time.*/
  delta = vtp->delta - chTimeDiffX(ch.vtlist.lasttime, now);
 8001d3e:	1a82      	subs	r2, r0, r2
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001d40:	2a01      	cmp	r2, #1
 8001d42:	d91a      	bls.n	8001d7a <Vector80+0x19a>
 8001d44:	4817      	ldr	r0, [pc, #92]	; (8001da4 <Vector80+0x1c4>)
 8001d46:	4282      	cmp	r2, r0
 8001d48:	d900      	bls.n	8001d4c <Vector80+0x16c>
 8001d4a:	1c02      	adds	r2, r0, #0
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001d4c:	4810      	ldr	r0, [pc, #64]	; (8001d90 <Vector80+0x1b0>)
 8001d4e:	68c6      	ldr	r6, [r0, #12]
 8001d50:	07b6      	lsls	r6, r6, #30
 8001d52:	d50f      	bpl.n	8001d74 <Vector80+0x194>

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8001d54:	188a      	adds	r2, r1, r2
 8001d56:	b292      	uxth	r2, r2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8001d58:	6342      	str	r2, [r0, #52]	; 0x34
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001d5a:	6a41      	ldr	r1, [r0, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8001d5c:	1ac9      	subs	r1, r1, r3
 8001d5e:	1ad3      	subs	r3, r2, r3
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 8001d60:	b29b      	uxth	r3, r3
 8001d62:	b28a      	uxth	r2, r1
 8001d64:	429a      	cmp	r2, r3
 8001d66:	d80a      	bhi.n	8001d7e <Vector80+0x19e>
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8001d68:	2300      	movs	r3, #0
 8001d6a:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001d6c:	b662      	cpsie	i
 8001d6e:	e760      	b.n	8001c32 <Vector80+0x52>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8001d70:	60f7      	str	r7, [r6, #12]
 8001d72:	e7bf      	b.n	8001cf4 <Vector80+0x114>
 8001d74:	480c      	ldr	r0, [pc, #48]	; (8001da8 <Vector80+0x1c8>)
 8001d76:	f7ff f9fb 	bl	8001170 <chSysHalt>
  ch.vtlist.next->delta -= nowdelta;

  /* Recalculating the next alarm time.*/
  delta = vtp->delta - chTimeDiffX(ch.vtlist.lasttime, now);
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8001d7a:	2202      	movs	r2, #2
 8001d7c:	e7e6      	b.n	8001d4c <Vector80+0x16c>
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 8001d7e:	480b      	ldr	r0, [pc, #44]	; (8001dac <Vector80+0x1cc>)
 8001d80:	f7ff f9f6 	bl	8001170 <chSysHalt>
 8001d84:	20000700 	.word	0x20000700
 8001d88:	08003814 	.word	0x08003814
 8001d8c:	0800382c 	.word	0x0800382c
 8001d90:	40000400 	.word	0x40000400
 8001d94:	08003834 	.word	0x08003834
 8001d98:	080037e0 	.word	0x080037e0
 8001d9c:	080001d4 	.word	0x080001d4
 8001da0:	080001c9 	.word	0x080001c9
 8001da4:	0000ffff 	.word	0x0000ffff
 8001da8:	08003714 	.word	0x08003714
 8001dac:	08003808 	.word	0x08003808

08001db0 <Vector9C>:
/**
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_GLOBAL_HANDLER) {
 8001db0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001db2:	464f      	mov	r7, r9
 8001db4:	4646      	mov	r6, r8
 8001db6:	b4c0      	push	{r6, r7}
  uint32_t isr = I2CD1.i2c->ISR;
 8001db8:	4dba      	ldr	r5, [pc, #744]	; (80020a4 <Vector9C+0x2f4>)
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001dba:	4cbb      	ldr	r4, [pc, #748]	; (80020a8 <Vector9C+0x2f8>)
 8001dbc:	6b2b      	ldr	r3, [r5, #48]	; 0x30

  OSAL_IRQ_PROLOGUE();
 8001dbe:	4677      	mov	r7, lr
 * @brief   I2C1 event interrupt handler.
 *
 * @notapi
 */
OSAL_IRQ_HANDLER(STM32_I2C1_GLOBAL_HANDLER) {
  uint32_t isr = I2CD1.i2c->ISR;
 8001dc0:	699e      	ldr	r6, [r3, #24]
 8001dc2:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8001dc4:	079b      	lsls	r3, r3, #30
 8001dc6:	d40d      	bmi.n	8001de4 <Vector9C+0x34>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001dc8:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001dca:	2007      	movs	r0, #7
 8001dcc:	2202      	movs	r2, #2
 8001dce:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001dd0:	780b      	ldrb	r3, [r1, #0]
 8001dd2:	4383      	bics	r3, r0
 8001dd4:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8001dd6:	4003      	ands	r3, r0
 8001dd8:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8001dda:	4bb4      	ldr	r3, [pc, #720]	; (80020ac <Vector9C+0x2fc>)
 8001ddc:	608b      	str	r3, [r1, #8]
    trace_next();
 8001dde:	f7ff f9af 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001de2:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001de4:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001de6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001de8:	2b00      	cmp	r3, #0
 8001dea:	db02      	blt.n	8001df2 <Vector9C+0x42>
 8001dec:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001dee:	2a00      	cmp	r2, #0
 8001df0:	d002      	beq.n	8001df8 <Vector9C+0x48>
    chSysHalt("SV#8");
 8001df2:	48af      	ldr	r0, [pc, #700]	; (80020b0 <Vector9C+0x300>)
 8001df4:	f7ff f9bc 	bl	8001170 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8001df8:	3301      	adds	r3, #1
 8001dfa:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001dfc:	b662      	cpsie	i
  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;

  if (isr & I2C_ERROR_MASK)
 8001dfe:	22fc      	movs	r2, #252	; 0xfc
  uint32_t isr = I2CD1.i2c->ISR;

  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;
 8001e00:	6b2b      	ldr	r3, [r5, #48]	; 0x30

  if (isr & I2C_ERROR_MASK)
 8001e02:	0192      	lsls	r2, r2, #6
  uint32_t isr = I2CD1.i2c->ISR;

  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr;
 8001e04:	61de      	str	r6, [r3, #28]

  if (isr & I2C_ERROR_MASK)
 8001e06:	4216      	tst	r6, r2
 8001e08:	d163      	bne.n	8001ed2 <Vector9C+0x122>
    i2c_lld_serve_error_interrupt(&I2CD1, isr);
  else if (isr & I2C_INT_MASK)
 8001e0a:	22fe      	movs	r2, #254	; 0xfe
 8001e0c:	4232      	tst	r2, r6
 8001e0e:	d109      	bne.n	8001e24 <Vector9C+0x74>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001e10:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001e12:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001e14:	2b00      	cmp	r3, #0
 8001e16:	dd02      	ble.n	8001e1e <Vector9C+0x6e>
 8001e18:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001e1a:	2a00      	cmp	r2, #0
 8001e1c:	d02d      	beq.n	8001e7a <Vector9C+0xca>
    chSysHalt("SV#9");
 8001e1e:	48a5      	ldr	r0, [pc, #660]	; (80020b4 <Vector9C+0x304>)
 8001e20:	f7ff f9a6 	bl	8001170 <chSysHalt>
 */
static void i2c_lld_serve_interrupt(I2CDriver *i2cp, uint32_t isr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
 8001e24:	06f2      	lsls	r2, r6, #27
 8001e26:	d500      	bpl.n	8001e2a <Vector9C+0x7a>
 8001e28:	e0cb      	b.n	8001fc2 <Vector9C+0x212>
    }
  }
#endif

  /* Partial transfer handling, restarting the transfer and returning.*/
  if ((isr & I2C_ISR_TCR) != 0U) {
 8001e2a:	0632      	lsls	r2, r6, #24
 8001e2c:	d500      	bpl.n	8001e30 <Vector9C+0x80>
 8001e2e:	e09e      	b.n	8001f6e <Vector9C+0x1be>
    }
    return;
  }

  /* The following condition is true if a transfer phase has been completed.*/
  if ((isr & I2C_ISR_TC) != 0U) {
 8001e30:	0672      	lsls	r2, r6, #25
 8001e32:	d5ed      	bpl.n	8001e10 <Vector9C+0x60>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8001e34:	782a      	ldrb	r2, [r5, #0]
 8001e36:	2a03      	cmp	r2, #3
 8001e38:	d100      	bne.n	8001e3c <Vector9C+0x8c>
 8001e3a:	e147      	b.n	80020cc <Vector9C+0x31c>
    }
    else {
      /* End of the receive phase.*/
#if STM32_I2C_USE_DMA == TRUE
      /* Disabling RX DMA channel.*/
      dmaStreamDisable(i2cp->dmarx);
 8001e3c:	260f      	movs	r6, #15
 8001e3e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8001e40:	6850      	ldr	r0, [r2, #4]
 8001e42:	6801      	ldr	r1, [r0, #0]
 8001e44:	43b1      	bics	r1, r6
 8001e46:	6001      	str	r1, [r0, #0]
 8001e48:	7b50      	ldrb	r0, [r2, #13]
 8001e4a:	6811      	ldr	r1, [r2, #0]
 8001e4c:	220e      	movs	r2, #14
 8001e4e:	4082      	lsls	r2, r0
 8001e50:	604a      	str	r2, [r1, #4]
#endif
    }

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001e52:	2180      	movs	r1, #128	; 0x80
 8001e54:	685a      	ldr	r2, [r3, #4]
 8001e56:	01c9      	lsls	r1, r1, #7
 8001e58:	430a      	orrs	r2, r1

    /* Make sure no more 'Transfer Complete' interrupts.*/
    dp->CR1 &= ~I2C_CR1_TCIE;
 8001e5a:	2140      	movs	r1, #64	; 0x40
      dmaStreamDisable(i2cp->dmarx);
#endif
    }

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001e5c:	605a      	str	r2, [r3, #4]

    /* Make sure no more 'Transfer Complete' interrupts.*/
    dp->CR1 &= ~I2C_CR1_TCIE;
 8001e5e:	681a      	ldr	r2, [r3, #0]
 8001e60:	438a      	bics	r2, r1
 8001e62:	601a      	str	r2, [r3, #0]
 8001e64:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001e66:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001e68:	2b00      	cmp	r3, #0
 8001e6a:	dd03      	ble.n	8001e74 <Vector9C+0xc4>
 8001e6c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001e6e:	2b00      	cmp	r3, #0
 8001e70:	d100      	bne.n	8001e74 <Vector9C+0xc4>
 8001e72:	e103      	b.n	800207c <Vector9C+0x2cc>
    chSysHalt("SV#6");
 8001e74:	4890      	ldr	r0, [pc, #576]	; (80020b8 <Vector9C+0x308>)
 8001e76:	f7ff f97b 	bl	8001170 <chSysHalt>

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 8001e7a:	3b01      	subs	r3, #1
 8001e7c:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001e7e:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001e80:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8001e82:	079b      	lsls	r3, r3, #30
 8001e84:	d40d      	bmi.n	8001ea2 <Vector9C+0xf2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001e86:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001e88:	2007      	movs	r0, #7
 8001e8a:	2203      	movs	r2, #3
 8001e8c:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8001e8e:	780b      	ldrb	r3, [r1, #0]
 8001e90:	4383      	bics	r3, r0
 8001e92:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8001e94:	4003      	ands	r3, r0
 8001e96:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8001e98:	4b84      	ldr	r3, [pc, #528]	; (80020ac <Vector9C+0x2fc>)
 8001e9a:	608b      	str	r3, [r1, #8]
    trace_next();
 8001e9c:	f7ff f950 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001ea0:	b662      	cpsie	i
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8001ea2:	370f      	adds	r7, #15
 8001ea4:	d011      	beq.n	8001eca <Vector9C+0x11a>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001ea6:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001ea8:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8001eac:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8001eae:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8001eb2:	2280      	movs	r2, #128	; 0x80
 8001eb4:	0452      	lsls	r2, r2, #17
 8001eb6:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8001eb8:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8001eba:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001ebc:	6889      	ldr	r1, [r1, #8]
 8001ebe:	6892      	ldr	r2, [r2, #8]
 8001ec0:	4291      	cmp	r1, r2
 8001ec2:	d900      	bls.n	8001ec6 <Vector9C+0x116>
 8001ec4:	e070      	b.n	8001fa8 <Vector9C+0x1f8>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8001ec6:	4a7d      	ldr	r2, [pc, #500]	; (80020bc <Vector9C+0x30c>)
 8001ec8:	619a      	str	r2, [r3, #24]
    i2c_lld_serve_error_interrupt(&I2CD1, isr);
  else if (isr & I2C_INT_MASK)
    i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8001eca:	bc0c      	pop	{r2, r3}
 8001ecc:	4690      	mov	r8, r2
 8001ece:	4699      	mov	r9, r3
 8001ed0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

#if STM32_I2C_USE_DMA == TRUE
  /* Clears DMA interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8001ed2:	200f      	movs	r0, #15
 8001ed4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8001ed6:	6859      	ldr	r1, [r3, #4]
 8001ed8:	680a      	ldr	r2, [r1, #0]
 8001eda:	4382      	bics	r2, r0
 8001edc:	600a      	str	r2, [r1, #0]
 8001ede:	681a      	ldr	r2, [r3, #0]
 8001ee0:	4694      	mov	ip, r2
 8001ee2:	7b5a      	ldrb	r2, [r3, #13]
 8001ee4:	230e      	movs	r3, #14
 8001ee6:	1c19      	adds	r1, r3, #0
 8001ee8:	4091      	lsls	r1, r2
 8001eea:	1c0a      	adds	r2, r1, #0
 8001eec:	4661      	mov	r1, ip
 8001eee:	604a      	str	r2, [r1, #4]
  dmaStreamDisable(i2cp->dmarx);
 8001ef0:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8001ef2:	6851      	ldr	r1, [r2, #4]
 8001ef4:	468c      	mov	ip, r1
 8001ef6:	6809      	ldr	r1, [r1, #0]
 8001ef8:	4381      	bics	r1, r0
 8001efa:	4660      	mov	r0, ip
 8001efc:	6001      	str	r1, [r0, #0]
 8001efe:	6811      	ldr	r1, [r2, #0]
 8001f00:	7b52      	ldrb	r2, [r2, #13]
 8001f02:	4093      	lsls	r3, r2
 8001f04:	604b      	str	r3, [r1, #4]
#else
  /* Disabling RX and TX interrupts.*/
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
#endif

  if (isr & I2C_ISR_BERR)
 8001f06:	05f3      	lsls	r3, r6, #23
 8001f08:	d449      	bmi.n	8001f9e <Vector9C+0x1ee>
 8001f0a:	68ab      	ldr	r3, [r5, #8]
    i2cp->errors |= I2C_BUS_ERROR;

  if (isr & I2C_ISR_ARLO)
 8001f0c:	05b2      	lsls	r2, r6, #22
 8001f0e:	d502      	bpl.n	8001f16 <Vector9C+0x166>
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8001f10:	2202      	movs	r2, #2
 8001f12:	4313      	orrs	r3, r2
 8001f14:	60ab      	str	r3, [r5, #8]

  if (isr & I2C_ISR_OVR)
 8001f16:	0572      	lsls	r2, r6, #21
 8001f18:	d549      	bpl.n	8001fae <Vector9C+0x1fe>
    i2cp->errors |= I2C_OVERRUN;
 8001f1a:	2208      	movs	r2, #8
 8001f1c:	4313      	orrs	r3, r2
 8001f1e:	60ab      	str	r3, [r5, #8]

  if (isr & I2C_ISR_TIMEOUT)
 8001f20:	04f2      	lsls	r2, r6, #19
 8001f22:	d446      	bmi.n	8001fb2 <Vector9C+0x202>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8001f24:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8001f26:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001f28:	2b00      	cmp	r3, #0
 8001f2a:	dda3      	ble.n	8001e74 <Vector9C+0xc4>
 8001f2c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001f2e:	2b00      	cmp	r3, #0
 8001f30:	d1a0      	bne.n	8001e74 <Vector9C+0xc4>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8001f32:	2201      	movs	r2, #1
 8001f34:	6362      	str	r2, [r4, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8001f36:	69ea      	ldr	r2, [r5, #28]
 8001f38:	2a00      	cmp	r2, #0
 8001f3a:	d014      	beq.n	8001f66 <Vector9C+0x1b6>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8001f3c:	2120      	movs	r1, #32
 8001f3e:	5c50      	ldrb	r0, [r2, r1]
 8001f40:	2803      	cmp	r0, #3
 8001f42:	d000      	beq.n	8001f46 <Vector9C+0x196>
 8001f44:	e097      	b.n	8002076 <Vector9C+0x2c6>

    *trp = NULL;
    tp->u.rdymsg = msg;
 8001f46:	2002      	movs	r0, #2
 8001f48:	4240      	negs	r0, r0
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8001f4a:	61eb      	str	r3, [r5, #28]
    tp->u.rdymsg = msg;
 8001f4c:	6250      	str	r0, [r2, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8001f4e:	5453      	strb	r3, [r2, r1]
  cp = (thread_t *)&ch.rlist.queue;
 8001f50:	1c23      	adds	r3, r4, #0
 8001f52:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8001f54:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001f56:	6898      	ldr	r0, [r3, #8]
 8001f58:	4288      	cmp	r0, r1
 8001f5a:	d2fb      	bcs.n	8001f54 <Vector9C+0x1a4>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8001f5c:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8001f5e:	6859      	ldr	r1, [r3, #4]
 8001f60:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8001f62:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8001f64:	605a      	str	r2, [r3, #4]
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8001f66:	2300      	movs	r3, #0
 8001f68:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8001f6a:	b662      	cpsie	i
 8001f6c:	e750      	b.n	8001e10 <Vector9C+0x60>
  }
#endif

  /* Partial transfer handling, restarting the transfer and returning.*/
  if ((isr & I2C_ISR_TCR) != 0U) {
    if (i2cp->state == I2C_ACTIVE_TX) {
 8001f6e:	782a      	ldrb	r2, [r5, #0]
 8001f70:	2a03      	cmp	r2, #3
 8001f72:	d06f      	beq.n	8002054 <Vector9C+0x2a4>
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 8001f74:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8001f76:	6852      	ldr	r2, [r2, #4]
 8001f78:	6852      	ldr	r2, [r2, #4]
  if (n > 255U) {
 8001f7a:	2aff      	cmp	r2, #255	; 0xff
 8001f7c:	d865      	bhi.n	800204a <Vector9C+0x29a>
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 8001f7e:	2000      	movs	r0, #0
 8001f80:	0416      	lsls	r6, r2, #16
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001f82:	6869      	ldr	r1, [r5, #4]
 8001f84:	685a      	ldr	r2, [r3, #4]
 8001f86:	688d      	ldr	r5, [r1, #8]
 8001f88:	2180      	movs	r1, #128	; 0x80
 8001f8a:	00c9      	lsls	r1, r1, #3
 8001f8c:	430d      	orrs	r5, r1
 8001f8e:	494c      	ldr	r1, [pc, #304]	; (80020c0 <Vector9C+0x310>)
 8001f90:	4011      	ands	r1, r2
 8001f92:	1c2a      	adds	r2, r5, #0
 8001f94:	430a      	orrs	r2, r1
 8001f96:	4302      	orrs	r2, r0
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8001f98:	4332      	orrs	r2, r6
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8001f9a:	605a      	str	r2, [r3, #4]
 8001f9c:	e738      	b.n	8001e10 <Vector9C+0x60>
  /* Disabling RX and TX interrupts.*/
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
#endif

  if (isr & I2C_ISR_BERR)
    i2cp->errors |= I2C_BUS_ERROR;
 8001f9e:	2301      	movs	r3, #1
 8001fa0:	68aa      	ldr	r2, [r5, #8]
 8001fa2:	4313      	orrs	r3, r2
 8001fa4:	60ab      	str	r3, [r5, #8]
 8001fa6:	e7b1      	b.n	8001f0c <Vector9C+0x15c>

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001fa8:	4a46      	ldr	r2, [pc, #280]	; (80020c4 <Vector9C+0x314>)
 8001faa:	619a      	str	r2, [r3, #24]
 8001fac:	e78d      	b.n	8001eca <Vector9C+0x11a>
    i2cp->errors |= I2C_ARBITRATION_LOST;

  if (isr & I2C_ISR_OVR)
    i2cp->errors |= I2C_OVERRUN;

  if (isr & I2C_ISR_TIMEOUT)
 8001fae:	04f2      	lsls	r2, r6, #19
 8001fb0:	d503      	bpl.n	8001fba <Vector9C+0x20a>
    i2cp->errors |= I2C_TIMEOUT;
 8001fb2:	2220      	movs	r2, #32
 8001fb4:	4313      	orrs	r3, r2
 8001fb6:	60ab      	str	r3, [r5, #8]
 8001fb8:	e7b4      	b.n	8001f24 <Vector9C+0x174>

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8001fba:	2b00      	cmp	r3, #0
 8001fbc:	d100      	bne.n	8001fc0 <Vector9C+0x210>
 8001fbe:	e727      	b.n	8001e10 <Vector9C+0x60>
 8001fc0:	e7b0      	b.n	8001f24 <Vector9C+0x174>

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
#if STM32_I2C_USE_DMA == TRUE
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
 8001fc2:	260f      	movs	r6, #15
 8001fc4:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8001fc6:	6850      	ldr	r0, [r2, #4]
 8001fc8:	6801      	ldr	r1, [r0, #0]
 8001fca:	43b1      	bics	r1, r6
 8001fcc:	6001      	str	r1, [r0, #0]
 8001fce:	6811      	ldr	r1, [r2, #0]
 8001fd0:	468c      	mov	ip, r1
 8001fd2:	7b51      	ldrb	r1, [r2, #13]
 8001fd4:	220e      	movs	r2, #14
 8001fd6:	1c10      	adds	r0, r2, #0
 8001fd8:	4088      	lsls	r0, r1
 8001fda:	1c01      	adds	r1, r0, #0
 8001fdc:	4660      	mov	r0, ip
 8001fde:	6041      	str	r1, [r0, #4]
    dmaStreamDisable(i2cp->dmarx);
 8001fe0:	6aa9      	ldr	r1, [r5, #40]	; 0x28
 8001fe2:	6848      	ldr	r0, [r1, #4]
 8001fe4:	4684      	mov	ip, r0
 8001fe6:	6800      	ldr	r0, [r0, #0]
 8001fe8:	43b0      	bics	r0, r6
 8001fea:	4666      	mov	r6, ip
 8001fec:	6030      	str	r0, [r6, #0]
 8001fee:	6808      	ldr	r0, [r1, #0]
 8001ff0:	7b49      	ldrb	r1, [r1, #13]
 8001ff2:	408a      	lsls	r2, r1
 8001ff4:	6042      	str	r2, [r0, #4]
#endif

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;
 8001ff6:	2204      	movs	r2, #4
 8001ff8:	68a9      	ldr	r1, [r5, #8]
 8001ffa:	430a      	orrs	r2, r1

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001ffc:	2180      	movs	r1, #128	; 0x80
    dmaStreamDisable(i2cp->dmatx);
    dmaStreamDisable(i2cp->dmarx);
#endif

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;
 8001ffe:	60aa      	str	r2, [r5, #8]

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8002000:	685a      	ldr	r2, [r3, #4]
 8002002:	01c9      	lsls	r1, r1, #7
 8002004:	430a      	orrs	r2, r1

    /* Make sure no more interrupts.*/
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
 8002006:	2146      	movs	r1, #70	; 0x46

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8002008:	605a      	str	r2, [r3, #4]

    /* Make sure no more interrupts.*/
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
 800200a:	681a      	ldr	r2, [r3, #0]
 800200c:	438a      	bics	r2, r1
 800200e:	601a      	str	r2, [r3, #0]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002010:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002012:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002014:	2b00      	cmp	r3, #0
 8002016:	dc00      	bgt.n	800201a <Vector9C+0x26a>
 8002018:	e72c      	b.n	8001e74 <Vector9C+0xc4>
 800201a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800201c:	2b00      	cmp	r3, #0
 800201e:	d000      	beq.n	8002022 <Vector9C+0x272>
 8002020:	e728      	b.n	8001e74 <Vector9C+0xc4>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8002022:	2201      	movs	r2, #1
 8002024:	6362      	str	r2, [r4, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8002026:	69ea      	ldr	r2, [r5, #28]
 8002028:	2a00      	cmp	r2, #0
 800202a:	d09c      	beq.n	8001f66 <Vector9C+0x1b6>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 800202c:	3926      	subs	r1, #38	; 0x26
 800202e:	5c50      	ldrb	r0, [r2, r1]
 8002030:	2803      	cmp	r0, #3
 8002032:	d120      	bne.n	8002076 <Vector9C+0x2c6>

    *trp = NULL;
    tp->u.rdymsg = msg;
 8002034:	3805      	subs	r0, #5
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8002036:	61eb      	str	r3, [r5, #28]
    tp->u.rdymsg = msg;
 8002038:	6250      	str	r0, [r2, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800203a:	5453      	strb	r3, [r2, r1]
  cp = (thread_t *)&ch.rlist.queue;
 800203c:	1c23      	adds	r3, r4, #0
 800203e:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8002040:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8002042:	6898      	ldr	r0, [r3, #8]
 8002044:	4288      	cmp	r0, r1
 8002046:	d2fb      	bcs.n	8002040 <Vector9C+0x290>
 8002048:	e788      	b.n	8001f5c <Vector9C+0x1ac>
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
 800204a:	26ff      	movs	r6, #255	; 0xff
    n = 255U;
    reload = I2C_CR2_RELOAD;
 800204c:	2080      	movs	r0, #128	; 0x80
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
 800204e:	0436      	lsls	r6, r6, #16
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8002050:	0440      	lsls	r0, r0, #17
 8002052:	e796      	b.n	8001f82 <Vector9C+0x1d2>
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 8002054:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8002056:	6852      	ldr	r2, [r2, #4]
 8002058:	6852      	ldr	r2, [r2, #4]
  if (n > 255U) {
 800205a:	2aff      	cmp	r2, #255	; 0xff
 800205c:	d86a      	bhi.n	8002134 <Vector9C+0x384>
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 800205e:	2000      	movs	r0, #0
 8002060:	0411      	lsls	r1, r2, #16
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8002062:	686d      	ldr	r5, [r5, #4]
 8002064:	685e      	ldr	r6, [r3, #4]
 8002066:	4a16      	ldr	r2, [pc, #88]	; (80020c0 <Vector9C+0x310>)
 8002068:	68ad      	ldr	r5, [r5, #8]
 800206a:	4032      	ands	r2, r6
 800206c:	432a      	orrs	r2, r5
 800206e:	4302      	orrs	r2, r0
            (n << 16U) | reload;
 8002070:	430a      	orrs	r2, r1
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8002072:	605a      	str	r2, [r3, #4]
 8002074:	e6cc      	b.n	8001e10 <Vector9C+0x60>
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002076:	4814      	ldr	r0, [pc, #80]	; (80020c8 <Vector9C+0x318>)
 8002078:	f7ff f87a 	bl	8001170 <chSysHalt>
 800207c:	2201      	movs	r2, #1
 800207e:	6362      	str	r2, [r4, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8002080:	69ea      	ldr	r2, [r5, #28]
 8002082:	2a00      	cmp	r2, #0
 8002084:	d100      	bne.n	8002088 <Vector9C+0x2d8>
 8002086:	e76e      	b.n	8001f66 <Vector9C+0x1b6>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002088:	3920      	subs	r1, #32
 800208a:	5c50      	ldrb	r0, [r2, r1]
 800208c:	2803      	cmp	r0, #3
 800208e:	d1f2      	bne.n	8002076 <Vector9C+0x2c6>

    *trp = NULL;
    tp->u.rdymsg = msg;
 8002090:	6253      	str	r3, [r2, #36]	; 0x24
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8002092:	61eb      	str	r3, [r5, #28]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002094:	5453      	strb	r3, [r2, r1]
  cp = (thread_t *)&ch.rlist.queue;
 8002096:	1c23      	adds	r3, r4, #0
 8002098:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 800209a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800209c:	6898      	ldr	r0, [r3, #8]
 800209e:	4288      	cmp	r0, r1
 80020a0:	d2fb      	bcs.n	800209a <Vector9C+0x2ea>
 80020a2:	e75b      	b.n	8001f5c <Vector9C+0x1ac>
 80020a4:	20000f84 	.word	0x20000f84
 80020a8:	20000700 	.word	0x20000700
 80020ac:	0800385c 	.word	0x0800385c
 80020b0:	0800382c 	.word	0x0800382c
 80020b4:	08003834 	.word	0x08003834
 80020b8:	080037e0 	.word	0x080037e0
 80020bc:	080001d4 	.word	0x080001d4
 80020c0:	fe00ffff 	.word	0xfe00ffff
 80020c4:	080001c9 	.word	0x080001c9
 80020c8:	0800384c 	.word	0x0800384c
    if (i2cp->state == I2C_ACTIVE_TX) {
      /* End of the transmit phase.*/

#if STM32_I2C_USE_DMA == TRUE
      /* Disabling TX DMA channel.*/
      dmaStreamDisable(i2cp->dmatx);
 80020cc:	260f      	movs	r6, #15
 80020ce:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80020d0:	6850      	ldr	r0, [r2, #4]
 80020d2:	6801      	ldr	r1, [r0, #0]
 80020d4:	43b1      	bics	r1, r6
 80020d6:	6001      	str	r1, [r0, #0]
 80020d8:	7b50      	ldrb	r0, [r2, #13]
 80020da:	6811      	ldr	r1, [r2, #0]
 80020dc:	220e      	movs	r2, #14
 80020de:	4082      	lsls	r2, r0
 80020e0:	604a      	str	r2, [r1, #4]
#endif

      /* Starting receive phase if necessary.*/
      if (i2c_lld_get_rxbytes(i2cp) > 0U) {
 80020e2:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 80020e4:	6852      	ldr	r2, [r2, #4]
 80020e6:	6851      	ldr	r1, [r2, #4]
 80020e8:	2900      	cmp	r1, #0
 80020ea:	d100      	bne.n	80020ee <Vector9C+0x33e>
 80020ec:	e6b1      	b.n	8001e52 <Vector9C+0xa2>
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 80020ee:	6851      	ldr	r1, [r2, #4]
  if (n > 255U) {
 80020f0:	29ff      	cmp	r1, #255	; 0xff
 80020f2:	d824      	bhi.n	800213e <Vector9C+0x38e>
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 80020f4:	2000      	movs	r0, #0
 80020f6:	4684      	mov	ip, r0
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80020f8:	6858      	ldr	r0, [r3, #4]
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 80020fa:	0409      	lsls	r1, r1, #16
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80020fc:	4680      	mov	r8, r0
 80020fe:	6868      	ldr	r0, [r5, #4]
 8002100:	6886      	ldr	r6, [r0, #8]
 8002102:	2080      	movs	r0, #128	; 0x80
 8002104:	00c0      	lsls	r0, r0, #3
 8002106:	4330      	orrs	r0, r6
 8002108:	4681      	mov	r9, r0
 800210a:	4640      	mov	r0, r8
 800210c:	4e0e      	ldr	r6, [pc, #56]	; (8002148 <Vector9C+0x398>)
 800210e:	4006      	ands	r6, r0
 8002110:	4648      	mov	r0, r9
 8002112:	4330      	orrs	r0, r6
 8002114:	4666      	mov	r6, ip
 8002116:	4330      	orrs	r0, r6
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8002118:	4301      	orrs	r1, r0
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 800211a:	6059      	str	r1, [r3, #4]
        /* Setting up the peripheral.*/
        i2c_lld_setup_rx_transfer(i2cp);

#if STM32_I2C_USE_DMA == TRUE
        /* Enabling RX DMA.*/
        dmaStreamEnable(i2cp->dmarx);
 800211c:	2101      	movs	r1, #1
 800211e:	6810      	ldr	r0, [r2, #0]
 8002120:	4301      	orrs	r1, r0
 8002122:	6011      	str	r1, [r2, #0]
        /* RX interrupt enabled.*/
        dp->CR1 |= I2C_CR1_RXIE;
#endif

        /* Starts the read operation.*/
        dp->CR2 |= I2C_CR2_START;
 8002124:	2180      	movs	r1, #128	; 0x80
 8002126:	685a      	ldr	r2, [r3, #4]
 8002128:	0189      	lsls	r1, r1, #6
 800212a:	430a      	orrs	r2, r1
 800212c:	605a      	str	r2, [r3, #4]

        /* State change.*/
        i2cp->state = I2C_ACTIVE_RX;
 800212e:	2304      	movs	r3, #4
 8002130:	702b      	strb	r3, [r5, #0]
 8002132:	e66d      	b.n	8001e10 <Vector9C+0x60>
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
 8002134:	21ff      	movs	r1, #255	; 0xff
    n = 255U;
    reload = I2C_CR2_RELOAD;
 8002136:	2080      	movs	r0, #128	; 0x80
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
 8002138:	0409      	lsls	r1, r1, #16
    n = 255U;
    reload = I2C_CR2_RELOAD;
 800213a:	0440      	lsls	r0, r0, #17
 800213c:	e791      	b.n	8002062 <Vector9C+0x2b2>

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
 800213e:	2080      	movs	r0, #128	; 0x80
 8002140:	0440      	lsls	r0, r0, #17
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
    n = 255U;
 8002142:	21ff      	movs	r1, #255	; 0xff
    reload = I2C_CR2_RELOAD;
 8002144:	4684      	mov	ip, r0
 8002146:	e7d7      	b.n	80020f8 <Vector9C+0x348>
 8002148:	fe00ffff 	.word	0xfe00ffff
 800214c:	00000000 	.word	0x00000000

08002150 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8002150:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002152:	4644      	mov	r4, r8
 8002154:	4656      	mov	r6, sl
 8002156:	464d      	mov	r5, r9
 8002158:	465f      	mov	r7, fp
 800215a:	b4f0      	push	{r4, r5, r6, r7}
 800215c:	b083      	sub	sp, #12
 800215e:	1c04      	adds	r4, r0, #0
 8002160:	1c0e      	adds	r6, r1, #0
 8002162:	4690      	mov	r8, r2
 8002164:	4699      	mov	r9, r3
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 8002166:	f7ff f87b 	bl	8001260 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 800216a:	2c04      	cmp	r4, #4
 800216c:	d80e      	bhi.n	800218c <dmaStreamAllocI+0x3c>
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
 800216e:	2201      	movs	r2, #1
 8002170:	1c17      	adds	r7, r2, #0
 8002172:	40a7      	lsls	r7, r4
    if ((dma.allocated_mask & mask) == 0U) {
 8002174:	4d23      	ldr	r5, [pc, #140]	; (8002204 <dmaStreamAllocI+0xb4>)
 8002176:	682b      	ldr	r3, [r5, #0]
 8002178:	423b      	tst	r3, r7
 800217a:	d00a      	beq.n	8002192 <dmaStreamAllocI+0x42>

      return dmastp;
    }
  }

  return NULL;
 800217c:	2000      	movs	r0, #0
}
 800217e:	b003      	add	sp, #12
 8002180:	bc3c      	pop	{r2, r3, r4, r5}
 8002182:	4690      	mov	r8, r2
 8002184:	4699      	mov	r9, r3
 8002186:	46a2      	mov	sl, r4
 8002188:	46ab      	mov	fp, r5
 800218a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    endid   = STM32_DMA_STREAMS - 1U;
  }
#endif
#endif
  else {
    osalDbgCheck(false);
 800218c:	481e      	ldr	r0, [pc, #120]	; (8002208 <dmaStreamAllocI+0xb8>)
 800218e:	f7fe ffef 	bl	8001170 <chSysHalt>
  }

  for (i = startid; i <= endid; i++) {
    uint32_t mask = (1U << i);
    if ((dma.allocated_mask & mask) == 0U) {
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8002192:	481e      	ldr	r0, [pc, #120]	; (800220c <dmaStreamAllocI+0xbc>)
 8002194:	0121      	lsls	r1, r4, #4
 8002196:	4683      	mov	fp, r0
 8002198:	9101      	str	r1, [sp, #4]
 800219a:	4459      	add	r1, fp
 800219c:	468a      	mov	sl, r1

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 800219e:	4641      	mov	r1, r8
 80021a0:	3401      	adds	r4, #1
 80021a2:	00e4      	lsls	r4, r4, #3
 80021a4:	5161      	str	r1, [r4, r5]
      dma.streams[i].param = param;
 80021a6:	4649      	mov	r1, r9
      dma.allocated_mask  |= mask;
 80021a8:	433b      	orrs	r3, r7
 80021aa:	602b      	str	r3, [r5, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
        rccEnableDMA1(true);
 80021ac:	4b18      	ldr	r3, [pc, #96]	; (8002210 <dmaStreamAllocI+0xc0>)
    if ((dma.allocated_mask & mask) == 0U) {
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
      dma.streams[i].param = param;
 80021ae:	192c      	adds	r4, r5, r4
 80021b0:	6061      	str	r1, [r4, #4]
      dma.allocated_mask  |= mask;

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
        rccEnableDMA1(true);
 80021b2:	6959      	ldr	r1, [r3, #20]
 80021b4:	430a      	orrs	r2, r1
 80021b6:	615a      	str	r2, [r3, #20]
 80021b8:	695b      	ldr	r3, [r3, #20]
      }
#endif

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
 80021ba:	4643      	mov	r3, r8
 80021bc:	2b00      	cmp	r3, #0
 80021be:	d009      	beq.n	80021d4 <dmaStreamAllocI+0x84>
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
 80021c0:	4652      	mov	r2, sl
 80021c2:	4653      	mov	r3, sl
 80021c4:	6869      	ldr	r1, [r5, #4]
 80021c6:	6892      	ldr	r2, [r2, #8]
 80021c8:	3308      	adds	r3, #8
 80021ca:	4211      	tst	r1, r2
 80021cc:	d015      	beq.n	80021fa <dmaStreamAllocI+0xaa>
          nvicEnableVector(dmastp->vector, priority);
        }
        dma.isr_mask |= mask;
 80021ce:	686b      	ldr	r3, [r5, #4]
 80021d0:	431f      	orrs	r7, r3
 80021d2:	606f      	str	r7, [r5, #4]
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
 80021d4:	9c01      	ldr	r4, [sp, #4]
 80021d6:	200f      	movs	r0, #15
 80021d8:	1c23      	adds	r3, r4, #0
 80021da:	445b      	add	r3, fp
 80021dc:	1c19      	adds	r1, r3, #0
 80021de:	685b      	ldr	r3, [r3, #4]
 80021e0:	7b49      	ldrb	r1, [r1, #13]
 80021e2:	681a      	ldr	r2, [r3, #0]
 80021e4:	4382      	bics	r2, r0
 80021e6:	601a      	str	r2, [r3, #0]
 80021e8:	220e      	movs	r2, #14
 80021ea:	4658      	mov	r0, fp
 80021ec:	408a      	lsls	r2, r1
 80021ee:	5900      	ldr	r0, [r0, r4]
 80021f0:	6042      	str	r2, [r0, #4]
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80021f2:	2200      	movs	r2, #0

      return dmastp;
 80021f4:	4650      	mov	r0, sl
        dma.isr_mask |= mask;
      }

      /* Putting the stream in a known state.*/
      dmaStreamDisable(dmastp);
      dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 80021f6:	601a      	str	r2, [r3, #0]
 80021f8:	e7c1      	b.n	800217e <dmaStreamAllocI+0x2e>

      /* Enables the associated IRQ vector if not already enabled and if a
         callback is defined.*/
      if (func != NULL) {
        if ((dma.isr_mask & dmastp->cmask) == 0U) {
          nvicEnableVector(dmastp->vector, priority);
 80021fa:	79d8      	ldrb	r0, [r3, #7]
 80021fc:	1c31      	adds	r1, r6, #0
 80021fe:	f000 ff27 	bl	8003050 <nvicEnableVector>
 8002202:	e7e4      	b.n	80021ce <dmaStreamAllocI+0x7e>
 8002204:	2000046c 	.word	0x2000046c
 8002208:	0800383c 	.word	0x0800383c
 800220c:	08003630 	.word	0x08003630
 8002210:	40021000 	.word	0x40021000
	...

08002220 <Vector64>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8002220:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002222:	4c32      	ldr	r4, [pc, #200]	; (80022ec <Vector64+0xcc>)

  OSAL_IRQ_PROLOGUE();
 8002224:	4675      	mov	r5, lr
 8002226:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8002228:	079b      	lsls	r3, r3, #30
 800222a:	d40d      	bmi.n	8002248 <Vector64+0x28>
 800222c:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 800222e:	2007      	movs	r0, #7
 8002230:	2202      	movs	r2, #2
 8002232:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002234:	780b      	ldrb	r3, [r1, #0]
 8002236:	4383      	bics	r3, r0
 8002238:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 800223a:	4003      	ands	r3, r0
 800223c:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 800223e:	4b2c      	ldr	r3, [pc, #176]	; (80022f0 <Vector64+0xd0>)
 8002240:	608b      	str	r3, [r1, #8]
    trace_next();
 8002242:	f7fe ff7d 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002246:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002248:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800224a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800224c:	2b00      	cmp	r3, #0
 800224e:	db02      	blt.n	8002256 <Vector64+0x36>
 8002250:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002252:	2a00      	cmp	r2, #0
 8002254:	d002      	beq.n	800225c <Vector64+0x3c>
    chSysHalt("SV#8");
 8002256:	4827      	ldr	r0, [pc, #156]	; (80022f4 <Vector64+0xd4>)
 8002258:	f7fe ff8a 	bl	8001170 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 800225c:	3301      	adds	r3, #1
 800225e:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002260:	b662      	cpsie	i
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t idx = (dmastp)->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8002262:	210e      	movs	r1, #14
 8002264:	4a24      	ldr	r2, [pc, #144]	; (80022f8 <Vector64+0xd8>)
 8002266:	6813      	ldr	r3, [r2, #0]
 8002268:	4019      	ands	r1, r3
  if (flags & dmastp->channel->CCR) {
 800226a:	4b24      	ldr	r3, [pc, #144]	; (80022fc <Vector64+0xdc>)
 800226c:	681b      	ldr	r3, [r3, #0]
 800226e:	420b      	tst	r3, r1
 8002270:	d006      	beq.n	8002280 <Vector64+0x60>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8002272:	6051      	str	r1, [r2, #4]
    if (dma.streams[idx].func) {
 8002274:	4a22      	ldr	r2, [pc, #136]	; (8002300 <Vector64+0xe0>)
 8002276:	6893      	ldr	r3, [r2, #8]
 8002278:	2b00      	cmp	r3, #0
 800227a:	d001      	beq.n	8002280 <Vector64+0x60>
      dma.streams[idx].func(dma.streams[idx].param, flags);
 800227c:	68d0      	ldr	r0, [r2, #12]
 800227e:	4798      	blx	r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002280:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002282:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002284:	2b00      	cmp	r3, #0
 8002286:	dd02      	ble.n	800228e <Vector64+0x6e>
 8002288:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800228a:	2a00      	cmp	r2, #0
 800228c:	d002      	beq.n	8002294 <Vector64+0x74>
    chSysHalt("SV#9");
 800228e:	481d      	ldr	r0, [pc, #116]	; (8002304 <Vector64+0xe4>)
 8002290:	f7fe ff6e 	bl	8001170 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 8002294:	3b01      	subs	r3, #1
 8002296:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002298:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800229a:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800229c:	079b      	lsls	r3, r3, #30
 800229e:	d40d      	bmi.n	80022bc <Vector64+0x9c>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80022a0:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80022a2:	2007      	movs	r0, #7
 80022a4:	2203      	movs	r2, #3
 80022a6:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80022a8:	780b      	ldrb	r3, [r1, #0]
 80022aa:	4383      	bics	r3, r0
 80022ac:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 80022ae:	4003      	ands	r3, r0
 80022b0:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 80022b2:	4b0f      	ldr	r3, [pc, #60]	; (80022f0 <Vector64+0xd0>)
 80022b4:	608b      	str	r3, [r1, #8]
    trace_next();
 80022b6:	f7fe ff43 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80022ba:	b662      	cpsie	i
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 80022bc:	350f      	adds	r5, #15
 80022be:	d010      	beq.n	80022e2 <Vector64+0xc2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80022c0:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80022c2:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80022c6:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80022c8:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80022cc:	2280      	movs	r2, #128	; 0x80
 80022ce:	0452      	lsls	r2, r2, #17
 80022d0:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80022d2:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 80022d4:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80022d6:	6889      	ldr	r1, [r1, #8]
 80022d8:	6892      	ldr	r2, [r2, #8]
 80022da:	4291      	cmp	r1, r2
 80022dc:	d802      	bhi.n	80022e4 <Vector64+0xc4>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80022de:	4a0a      	ldr	r2, [pc, #40]	; (8002308 <Vector64+0xe8>)
 80022e0:	619a      	str	r2, [r3, #24]
  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);

  OSAL_IRQ_EPILOGUE();
}
 80022e2:	bd38      	pop	{r3, r4, r5, pc}

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80022e4:	4a09      	ldr	r2, [pc, #36]	; (800230c <Vector64+0xec>)
 80022e6:	619a      	str	r2, [r3, #24]
 80022e8:	e7fb      	b.n	80022e2 <Vector64+0xc2>
 80022ea:	46c0      	nop			; (mov r8, r8)
 80022ec:	20000700 	.word	0x20000700
 80022f0:	08003820 	.word	0x08003820
 80022f4:	0800382c 	.word	0x0800382c
 80022f8:	40020000 	.word	0x40020000
 80022fc:	40020008 	.word	0x40020008
 8002300:	2000046c 	.word	0x2000046c
 8002304:	08003834 	.word	0x08003834
 8002308:	080001d4 	.word	0x080001d4
 800230c:	080001c9 	.word	0x080001c9

08002310 <chCoreAllocAlignedI.lto_priv.60>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002310:	4b12      	ldr	r3, [pc, #72]	; (800235c <chCoreAllocAlignedI.lto_priv.60+0x4c>)
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8002312:	b570      	push	{r4, r5, r6, lr}
 8002314:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002316:	2a00      	cmp	r2, #0
 8002318:	db1b      	blt.n	8002352 <chCoreAllocAlignedI.lto_priv.60+0x42>
 800231a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800231c:	2b00      	cmp	r3, #0
 800231e:	dd18      	ble.n	8002352 <chCoreAllocAlignedI.lto_priv.60+0x42>
                                    unsigned align,
                                    size_t offset) {
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8002320:	2900      	cmp	r1, #0
 8002322:	d013      	beq.n	800234c <chCoreAllocAlignedI.lto_priv.60+0x3c>
 8002324:	1e4b      	subs	r3, r1, #1
 8002326:	4219      	tst	r1, r3
 8002328:	d110      	bne.n	800234c <chCoreAllocAlignedI.lto_priv.60+0x3c>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800232a:	4a0d      	ldr	r2, [pc, #52]	; (8002360 <chCoreAllocAlignedI.lto_priv.60+0x50>)
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 800232c:	424c      	negs	r4, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800232e:	6815      	ldr	r5, [r2, #0]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8002330:	1818      	adds	r0, r3, r0
 8002332:	1e6e      	subs	r6, r5, #1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002334:	1871      	adds	r1, r6, r1
 8002336:	4021      	ands	r1, r4
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8002338:	4020      	ands	r0, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800233a:	6853      	ldr	r3, [r2, #4]
  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;
 800233c:	1808      	adds	r0, r1, r0

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 800233e:	4298      	cmp	r0, r3
 8002340:	d80a      	bhi.n	8002358 <chCoreAllocAlignedI.lto_priv.60+0x48>
 8002342:	4285      	cmp	r5, r0
 8002344:	d808      	bhi.n	8002358 <chCoreAllocAlignedI.lto_priv.60+0x48>
    return NULL;
  }

  ch_memcore.nextmem = next;
 8002346:	6010      	str	r0, [r2, #0]

  return p;
 8002348:	1c08      	adds	r0, r1, #0

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
 800234a:	bd70      	pop	{r4, r5, r6, pc}
                                    unsigned align,
                                    size_t offset) {
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800234c:	4805      	ldr	r0, [pc, #20]	; (8002364 <chCoreAllocAlignedI.lto_priv.60+0x54>)
 800234e:	f7fe ff0f 	bl	8001170 <chSysHalt>
    chSysHalt("SV#10");
 8002352:	4805      	ldr	r0, [pc, #20]	; (8002368 <chCoreAllocAlignedI.lto_priv.60+0x58>)
 8002354:	f7fe ff0c 	bl	8001170 <chSysHalt>
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
    return NULL;
 8002358:	2000      	movs	r0, #0
 800235a:	e7f6      	b.n	800234a <chCoreAllocAlignedI.lto_priv.60+0x3a>
 800235c:	20000700 	.word	0x20000700
 8002360:	20000464 	.word	0x20000464
 8002364:	08003894 	.word	0x08003894
 8002368:	080036e8 	.word	0x080036e8
 800236c:	00000000 	.word	0x00000000

08002370 <chCoreAllocAlignedWithOffset>:
 *
 * @api
 */
void *chCoreAllocAlignedWithOffset(size_t size,
                                   unsigned align,
                                   size_t offset) {
 8002370:	b570      	push	{r4, r5, r6, lr}
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002372:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002374:	4b1a      	ldr	r3, [pc, #104]	; (80023e0 <chCoreAllocAlignedWithOffset+0x70>)
 8002376:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 8002378:	2c00      	cmp	r4, #0
 800237a:	d102      	bne.n	8002382 <chCoreAllocAlignedWithOffset+0x12>
 800237c:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 800237e:	2c00      	cmp	r4, #0
 8002380:	d002      	beq.n	8002388 <chCoreAllocAlignedWithOffset+0x18>
    chSysHalt("SV#4");
 8002382:	4818      	ldr	r0, [pc, #96]	; (80023e4 <chCoreAllocAlignedWithOffset+0x74>)
 8002384:	f7fe fef4 	bl	8001170 <chSysHalt>
  }
  _dbg_enter_lock();
 8002388:	2401      	movs	r4, #1
 800238a:	635c      	str	r4, [r3, #52]	; 0x34
                                    unsigned align,
                                    size_t offset) {
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 800238c:	2900      	cmp	r1, #0
 800238e:	d01e      	beq.n	80023ce <chCoreAllocAlignedWithOffset+0x5e>
 8002390:	1e4c      	subs	r4, r1, #1
 8002392:	4221      	tst	r1, r4
 8002394:	d11b      	bne.n	80023ce <chCoreAllocAlignedWithOffset+0x5e>

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 8002396:	4d14      	ldr	r5, [pc, #80]	; (80023e8 <chCoreAllocAlignedWithOffset+0x78>)
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8002398:	4249      	negs	r1, r1
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800239a:	682e      	ldr	r6, [r5, #0]
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 800239c:	1820      	adds	r0, r4, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
 800239e:	18b2      	adds	r2, r6, r2
 80023a0:	1912      	adds	r2, r2, r4
 80023a2:	400a      	ands	r2, r1
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80023a4:	4001      	ands	r1, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 80023a6:	6868      	ldr	r0, [r5, #4]
  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;
 80023a8:	1851      	adds	r1, r2, r1

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
 80023aa:	4281      	cmp	r1, r0
 80023ac:	d812      	bhi.n	80023d4 <chCoreAllocAlignedWithOffset+0x64>
 80023ae:	428e      	cmp	r6, r1
 80023b0:	d810      	bhi.n	80023d4 <chCoreAllocAlignedWithOffset+0x64>
    return NULL;
  }

  ch_memcore.nextmem = next;
 80023b2:	6029      	str	r1, [r5, #0]
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80023b4:	2100      	movs	r1, #0
 80023b6:	6359      	str	r1, [r3, #52]	; 0x34
 80023b8:	6819      	ldr	r1, [r3, #0]
 80023ba:	4299      	cmp	r1, r3
 80023bc:	d004      	beq.n	80023c8 <chCoreAllocAlignedWithOffset+0x58>
 80023be:	699b      	ldr	r3, [r3, #24]
 80023c0:	6898      	ldr	r0, [r3, #8]
 80023c2:	688b      	ldr	r3, [r1, #8]
 80023c4:	4298      	cmp	r0, r3
 80023c6:	d307      	bcc.n	80023d8 <chCoreAllocAlignedWithOffset+0x68>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80023c8:	b662      	cpsie	i
  chSysLock();
  p = chCoreAllocAlignedWithOffsetI(size, align, offset);
  chSysUnlock();

  return p;
}
 80023ca:	1c10      	adds	r0, r2, #0
 80023cc:	bd70      	pop	{r4, r5, r6, pc}
                                    unsigned align,
                                    size_t offset) {
  uint8_t *p, *next;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 80023ce:	4807      	ldr	r0, [pc, #28]	; (80023ec <chCoreAllocAlignedWithOffset+0x7c>)
 80023d0:	f7fe fece 	bl	8001170 <chSysHalt>
  p = (uint8_t *)MEM_ALIGN_NEXT(ch_memcore.nextmem + offset, align);
  next = p + size;

  /* Considering also the case where there is numeric overflow.*/
  if ((next > ch_memcore.endmem) || (next < ch_memcore.nextmem)) {
    return NULL;
 80023d4:	2200      	movs	r2, #0
 80023d6:	e7ed      	b.n	80023b4 <chCoreAllocAlignedWithOffset+0x44>
 80023d8:	4805      	ldr	r0, [pc, #20]	; (80023f0 <chCoreAllocAlignedWithOffset+0x80>)
 80023da:	f7fe fec9 	bl	8001170 <chSysHalt>
 80023de:	46c0      	nop			; (mov r8, r8)
 80023e0:	20000700 	.word	0x20000700
 80023e4:	080036c8 	.word	0x080036c8
 80023e8:	20000464 	.word	0x20000464
 80023ec:	08003894 	.word	0x08003894
 80023f0:	08003888 	.word	0x08003888
	...

08002400 <Thread1.lto_priv.46>:

/*
 * LEDs batLED thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8002400:	b5f0      	push	{r4, r5, r6, r7, lr}
 8002402:	4644      	mov	r4, r8
 8002404:	465f      	mov	r7, fp
 8002406:	4656      	mov	r6, sl
 8002408:	464d      	mov	r5, r9
 800240a:	b4f0      	push	{r4, r5, r6, r7}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 800240c:	4ca7      	ldr	r4, [pc, #668]	; (80026ac <Thread1.lto_priv.46+0x2ac>)
 800240e:	4aa8      	ldr	r2, [pc, #672]	; (80026b0 <Thread1.lto_priv.46+0x2b0>)
 8002410:	69a3      	ldr	r3, [r4, #24]
 8002412:	b089      	sub	sp, #36	; 0x24
 8002414:	619a      	str	r2, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002416:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002418:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800241a:	2b00      	cmp	r3, #0
 800241c:	d102      	bne.n	8002424 <Thread1.lto_priv.46+0x24>
 800241e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002420:	2b00      	cmp	r3, #0
 8002422:	d002      	beq.n	800242a <Thread1.lto_priv.46+0x2a>
    chSysHalt("SV#4");
 8002424:	48a3      	ldr	r0, [pc, #652]	; (80026b4 <Thread1.lto_priv.46+0x2b4>)
 8002426:	f7fe fea3 	bl	8001170 <chSysHalt>
 800242a:	4ba3      	ldr	r3, [pc, #652]	; (80026b8 <Thread1.lto_priv.46+0x2b8>)
  }
  _dbg_enter_lock();
 800242c:	2601      	movs	r6, #1
 800242e:	4698      	mov	r8, r3
  /* Calculate new delta for the following entry.*/
  p->delta -= delta;

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 8002430:	2301      	movs	r3, #1
 8002432:	425b      	negs	r3, r3
 8002434:	469a      	mov	sl, r3
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8002436:	3303      	adds	r3, #3
 8002438:	4699      	mov	r9, r3
 800243a:	4fa0      	ldr	r7, [pc, #640]	; (80026bc <Thread1.lto_priv.46+0x2bc>)
 800243c:	ad03      	add	r5, sp, #12
  sysinterval_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 800243e:	69a3      	ldr	r3, [r4, #24]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8002440:	499f      	ldr	r1, [pc, #636]	; (80026c0 <Thread1.lto_priv.46+0x2c0>)
 8002442:	612b      	str	r3, [r5, #16]
  vtp->func = vtfunc;
 8002444:	4643      	mov	r3, r8
 8002446:	6366      	str	r6, [r4, #52]	; 0x34
 8002448:	60eb      	str	r3, [r5, #12]
 800244a:	6a4a      	ldr	r2, [r1, #36]	; 0x24
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800244c:	69e3      	ldr	r3, [r4, #28]
 800244e:	b292      	uxth	r2, r2
 8002450:	42bb      	cmp	r3, r7
 8002452:	d100      	bne.n	8002456 <Thread1.lto_priv.46+0x56>
 8002454:	e0d1      	b.n	80025fa <Thread1.lto_priv.46+0x1fa>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8002456:	8d20      	ldrh	r0, [r4, #40]	; 0x28
 8002458:	1a12      	subs	r2, r2, r0
 800245a:	4684      	mov	ip, r0
 800245c:	4899      	ldr	r0, [pc, #612]	; (80026c4 <Thread1.lto_priv.46+0x2c4>)
 800245e:	b292      	uxth	r2, r2
 8002460:	1810      	adds	r0, r2, r0

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8002462:	4282      	cmp	r2, r0
 8002464:	d900      	bls.n	8002468 <Thread1.lto_priv.46+0x68>
 8002466:	e0be      	b.n	80025e6 <Thread1.lto_priv.46+0x1e6>
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 8002468:	689a      	ldr	r2, [r3, #8]
 800246a:	4290      	cmp	r0, r2
 800246c:	d213      	bcs.n	8002496 <Thread1.lto_priv.46+0x96>
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 800246e:	68ca      	ldr	r2, [r1, #12]
 8002470:	4649      	mov	r1, r9
 8002472:	420a      	tst	r2, r1
 8002474:	d100      	bne.n	8002478 <Thread1.lto_priv.46+0x78>
 8002476:	e0da      	b.n	800262e <Thread1.lto_priv.46+0x22e>
 8002478:	4993      	ldr	r1, [pc, #588]	; (80026c8 <Thread1.lto_priv.46+0x2c8>)
 800247a:	1e02      	subs	r2, r0, #0
 800247c:	428a      	cmp	r2, r1
 800247e:	d900      	bls.n	8002482 <Thread1.lto_priv.46+0x82>
 8002480:	1c0a      	adds	r2, r1, #0

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8002482:	4462      	add	r2, ip
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002484:	498e      	ldr	r1, [pc, #568]	; (80026c0 <Thread1.lto_priv.46+0x2c0>)
 8002486:	b292      	uxth	r2, r2
 8002488:	634a      	str	r2, [r1, #52]	; 0x34
 800248a:	e004      	b.n	8002496 <Thread1.lto_priv.46+0x96>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 800248c:	42ab      	cmp	r3, r5
 800248e:	d100      	bne.n	8002492 <Thread1.lto_priv.46+0x92>
 8002490:	e0ad      	b.n	80025ee <Thread1.lto_priv.46+0x1ee>

    delta -= p->delta;
    p = p->next;
 8002492:	681b      	ldr	r3, [r3, #0]
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");

    delta -= p->delta;
 8002494:	1a80      	subs	r0, r0, r2
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 8002496:	689a      	ldr	r2, [r3, #8]
 8002498:	4290      	cmp	r0, r2
 800249a:	d8f7      	bhi.n	800248c <Thread1.lto_priv.46+0x8c>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 800249c:	685a      	ldr	r2, [r3, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 800249e:	602b      	str	r3, [r5, #0]
  vtp->prev = vtp->next->prev;
 80024a0:	606a      	str	r2, [r5, #4]
  vtp->prev->next = vtp;
 80024a2:	6015      	str	r5, [r2, #0]
  p->prev = vtp;
 80024a4:	605d      	str	r5, [r3, #4]
  vtp->delta = delta;
 80024a6:	60a8      	str	r0, [r5, #8]

  /* Calculate new delta for the following entry.*/
  p->delta -= delta;
 80024a8:	689a      	ldr	r2, [r3, #8]
 80024aa:	1a12      	subs	r2, r2, r0
 80024ac:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  ch.vtlist.delta = (sysinterval_t)-1;
 80024ae:	4653      	mov	r3, sl
 80024b0:	6263      	str	r3, [r4, #36]	; 0x24
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 80024b2:	69a3      	ldr	r3, [r4, #24]
 80024b4:	469b      	mov	fp, r3
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80024b6:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80024b8:	2b00      	cmp	r3, #0
 80024ba:	d000      	beq.n	80024be <Thread1.lto_priv.46+0xbe>
 80024bc:	e09a      	b.n	80025f4 <Thread1.lto_priv.46+0x1f4>
 80024be:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80024c0:	2b00      	cmp	r3, #0
 80024c2:	dc00      	bgt.n	80024c6 <Thread1.lto_priv.46+0xc6>
 80024c4:	e096      	b.n	80025f4 <Thread1.lto_priv.46+0x1f4>

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 80024c6:	2220      	movs	r2, #32
 80024c8:	2308      	movs	r3, #8
 80024ca:	4659      	mov	r1, fp
 80024cc:	548b      	strb	r3, [r1, r2]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80024ce:	6823      	ldr	r3, [r4, #0]

  tqp->next             = tp->queue.next;
 80024d0:	6819      	ldr	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80024d2:	604c      	str	r4, [r1, #4]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80024d4:	549e      	strb	r6, [r3, r2]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80024d6:	6021      	str	r1, [r4, #0]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80024d8:	8f21      	ldrh	r1, [r4, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80024da:	61a3      	str	r3, [r4, #24]
 80024dc:	4231      	tst	r1, r6
 80024de:	d119      	bne.n	8002514 <Thread1.lto_priv.46+0x114>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80024e0:	2007      	movs	r0, #7
 80024e2:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 80024e4:	4684      	mov	ip, r0
 80024e6:	9101      	str	r1, [sp, #4]
 80024e8:	7809      	ldrb	r1, [r1, #0]
 80024ea:	4381      	bics	r1, r0
 80024ec:	1c08      	adds	r0, r1, #0
 80024ee:	9901      	ldr	r1, [sp, #4]
 80024f0:	4330      	orrs	r0, r6
 80024f2:	7008      	strb	r0, [r1, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80024f4:	4658      	mov	r0, fp
 80024f6:	5c82      	ldrb	r2, [r0, r2]
 80024f8:	4660      	mov	r0, ip
 80024fa:	00d1      	lsls	r1, r2, #3
 80024fc:	9a01      	ldr	r2, [sp, #4]
 80024fe:	7812      	ldrb	r2, [r2, #0]
 8002500:	4002      	ands	r2, r0
 8002502:	430a      	orrs	r2, r1
 8002504:	9901      	ldr	r1, [sp, #4]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8002506:	608b      	str	r3, [r1, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002508:	465b      	mov	r3, fp

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800250a:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800250c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800250e:	60cb      	str	r3, [r1, #12]
    trace_next();
 8002510:	f7fe fe16 	bl	8001140 <trace_next.lto_priv.45>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002514:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002518:	465a      	mov	r2, fp
 800251a:	69d2      	ldr	r2, [r2, #28]
 800251c:	3b24      	subs	r3, #36	; 0x24
 800251e:	429a      	cmp	r2, r3
 8002520:	d900      	bls.n	8002524 <Thread1.lto_priv.46+0x124>
 8002522:	e07e      	b.n	8002622 <Thread1.lto_priv.46+0x222>
 8002524:	69a0      	ldr	r0, [r4, #24]
 8002526:	4659      	mov	r1, fp
 8002528:	f7fd fe36 	bl	8000198 <_port_switch>
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800252c:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800252e:	2b00      	cmp	r3, #0
 8002530:	db7a      	blt.n	8002628 <Thread1.lto_priv.46+0x228>
 8002532:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002534:	2a00      	cmp	r2, #0
 8002536:	dd77      	ble.n	8002628 <Thread1.lto_priv.46+0x228>
  if (TIME_INFINITE != timeout) {
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, wakeup, currp);
    chSchGoSleepS(newstate);
    if (chVTIsArmedI(&vt)) {
 8002538:	9a06      	ldr	r2, [sp, #24]
 800253a:	2a00      	cmp	r2, #0
 800253c:	d011      	beq.n	8002562 <Thread1.lto_priv.46+0x162>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 800253e:	69e2      	ldr	r2, [r4, #28]
 8002540:	42aa      	cmp	r2, r5
 8002542:	d100      	bne.n	8002546 <Thread1.lto_priv.46+0x146>
 8002544:	e07f      	b.n	8002646 <Thread1.lto_priv.46+0x246>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8002546:	6869      	ldr	r1, [r5, #4]
 8002548:	682a      	ldr	r2, [r5, #0]
 800254a:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 800254c:	682a      	ldr	r2, [r5, #0]
 800254e:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 8002550:	2100      	movs	r1, #0
 8002552:	60e9      	str	r1, [r5, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8002554:	42ba      	cmp	r2, r7
 8002556:	d004      	beq.n	8002562 <Thread1.lto_priv.46+0x162>
      vtp->next->delta += vtp->delta;
 8002558:	68a8      	ldr	r0, [r5, #8]
 800255a:	6891      	ldr	r1, [r2, #8]
 800255c:	4684      	mov	ip, r0
 800255e:	4461      	add	r1, ip
 8002560:	6091      	str	r1, [r2, #8]
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002562:	2b00      	cmp	r3, #0
 8002564:	d169      	bne.n	800263a <Thread1.lto_priv.46+0x23a>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 8002566:	6363      	str	r3, [r4, #52]	; 0x34
 8002568:	6823      	ldr	r3, [r4, #0]
 800256a:	42a3      	cmp	r3, r4
 800256c:	d004      	beq.n	8002578 <Thread1.lto_priv.46+0x178>
 800256e:	69a2      	ldr	r2, [r4, #24]
 8002570:	689b      	ldr	r3, [r3, #8]
 8002572:	6892      	ldr	r2, [r2, #8]
 8002574:	429a      	cmp	r2, r3
 8002576:	d363      	bcc.n	8002640 <Thread1.lto_priv.46+0x240>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002578:	b662      	cpsie	i

  (void)arg;
  chRegSetThreadName("batLED");
  while (true) {
    chThdSleepMilliseconds(500);
    palSetPad(GPIOA, GPIOA_LED1);
 800257a:	2390      	movs	r3, #144	; 0x90
 800257c:	2220      	movs	r2, #32
 800257e:	05db      	lsls	r3, r3, #23
 8002580:	831a      	strh	r2, [r3, #24]
    palSetPad(GPIOB, GPIOB_LED5);
 8002582:	464a      	mov	r2, r9
 8002584:	4b51      	ldr	r3, [pc, #324]	; (80026cc <Thread1.lto_priv.46+0x2cc>)
 8002586:	831a      	strh	r2, [r3, #24]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002588:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800258a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 800258c:	2b00      	cmp	r3, #0
 800258e:	d000      	beq.n	8002592 <Thread1.lto_priv.46+0x192>
 8002590:	e748      	b.n	8002424 <Thread1.lto_priv.46+0x24>
 8002592:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002594:	2b00      	cmp	r3, #0
 8002596:	d000      	beq.n	800259a <Thread1.lto_priv.46+0x19a>
 8002598:	e744      	b.n	8002424 <Thread1.lto_priv.46+0x24>
 800259a:	2008      	movs	r0, #8
 800259c:	4949      	ldr	r1, [pc, #292]	; (80026c4 <Thread1.lto_priv.46+0x2c4>)
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 800259e:	6366      	str	r6, [r4, #52]	; 0x34
 80025a0:	f7ff f8b6 	bl	8001710 <chSchGoSleepTimeoutS>
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80025a4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80025a6:	2b00      	cmp	r3, #0
 80025a8:	d147      	bne.n	800263a <Thread1.lto_priv.46+0x23a>
 80025aa:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80025ac:	2a00      	cmp	r2, #0
 80025ae:	dd44      	ble.n	800263a <Thread1.lto_priv.46+0x23a>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80025b0:	6363      	str	r3, [r4, #52]	; 0x34
 80025b2:	6823      	ldr	r3, [r4, #0]
 80025b4:	42a3      	cmp	r3, r4
 80025b6:	d004      	beq.n	80025c2 <Thread1.lto_priv.46+0x1c2>
 80025b8:	69a2      	ldr	r2, [r4, #24]
 80025ba:	689b      	ldr	r3, [r3, #8]
 80025bc:	6892      	ldr	r2, [r2, #8]
 80025be:	429a      	cmp	r2, r3
 80025c0:	d33e      	bcc.n	8002640 <Thread1.lto_priv.46+0x240>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80025c2:	b662      	cpsie	i
    chThdSleepMilliseconds(500);
    palClearPad(GPIOA, GPIOA_LED1);
 80025c4:	2390      	movs	r3, #144	; 0x90
 80025c6:	2220      	movs	r2, #32
 80025c8:	05db      	lsls	r3, r3, #23
 80025ca:	835a      	strh	r2, [r3, #26]
    palClearPad(GPIOB, GPIOB_LED5);
 80025cc:	464a      	mov	r2, r9
 80025ce:	4b3f      	ldr	r3, [pc, #252]	; (80026cc <Thread1.lto_priv.46+0x2cc>)
 80025d0:	835a      	strh	r2, [r3, #26]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80025d2:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80025d4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 80025d6:	2b00      	cmp	r3, #0
 80025d8:	d000      	beq.n	80025dc <Thread1.lto_priv.46+0x1dc>
 80025da:	e723      	b.n	8002424 <Thread1.lto_priv.46+0x24>
 80025dc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80025de:	2b00      	cmp	r3, #0
 80025e0:	d000      	beq.n	80025e4 <Thread1.lto_priv.46+0x1e4>
 80025e2:	e71f      	b.n	8002424 <Thread1.lto_priv.46+0x24>
 80025e4:	e72b      	b.n	800243e <Thread1.lto_priv.46+0x3e>

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 80025e6:	689a      	ldr	r2, [r3, #8]
      p = p->next;
 80025e8:	681b      	ldr	r3, [r3, #0]

    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 80025ea:	1a80      	subs	r0, r0, r2
 80025ec:	e753      	b.n	8002496 <Thread1.lto_priv.46+0x96>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(p != vtp, "timer already armed");
 80025ee:	4838      	ldr	r0, [pc, #224]	; (80026d0 <Thread1.lto_priv.46+0x2d0>)
 80025f0:	f7fe fdbe 	bl	8001170 <chSysHalt>
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#11");
 80025f4:	4837      	ldr	r0, [pc, #220]	; (80026d4 <Thread1.lto_priv.46+0x2d4>)
 80025f6:	f7fe fdbb 	bl	8001170 <chSysHalt>
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80025fa:	4648      	mov	r0, r9
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 80025fc:	4b31      	ldr	r3, [pc, #196]	; (80026c4 <Thread1.lto_priv.46+0x2c4>)
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 80025fe:	8522      	strh	r2, [r4, #40]	; 0x28
      ch.vtlist.next = vtp;
      ch.vtlist.prev = vtp;
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;
 8002600:	60ab      	str	r3, [r5, #8]
 8002602:	68cb      	ldr	r3, [r1, #12]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
      ch.vtlist.next = vtp;
 8002604:	61e5      	str	r5, [r4, #28]
      ch.vtlist.prev = vtp;
 8002606:	6225      	str	r5, [r4, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8002608:	602f      	str	r7, [r5, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 800260a:	606f      	str	r7, [r5, #4]
 800260c:	4003      	ands	r3, r0
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 800260e:	d111      	bne.n	8002634 <Thread1.lto_priv.46+0x234>
 8002610:	482c      	ldr	r0, [pc, #176]	; (80026c4 <Thread1.lto_priv.46+0x2c4>)
 8002612:	4684      	mov	ip, r0
 8002614:	4462      	add	r2, ip
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002616:	b292      	uxth	r2, r2
 8002618:	634a      	str	r2, [r1, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800261a:	610b      	str	r3, [r1, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800261c:	464b      	mov	r3, r9
 800261e:	60cb      	str	r3, [r1, #12]
 8002620:	e747      	b.n	80024b2 <Thread1.lto_priv.46+0xb2>
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002622:	482d      	ldr	r0, [pc, #180]	; (80026d8 <Thread1.lto_priv.46+0x2d8>)
 8002624:	f7fe fda4 	bl	8001170 <chSysHalt>
 * @api
 */
void chDbgCheckClassI(void) {

  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#10");
 8002628:	482c      	ldr	r0, [pc, #176]	; (80026dc <Thread1.lto_priv.46+0x2dc>)
 800262a:	f7fe fda1 	bl	8001170 <chSysHalt>
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 800262e:	482c      	ldr	r0, [pc, #176]	; (80026e0 <Thread1.lto_priv.46+0x2e0>)
 8002630:	f7fe fd9e 	bl	8001170 <chSysHalt>
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8002634:	482b      	ldr	r0, [pc, #172]	; (80026e4 <Thread1.lto_priv.46+0x2e4>)
 8002636:	f7fe fd9b 	bl	8001170 <chSysHalt>
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 800263a:	482b      	ldr	r0, [pc, #172]	; (80026e8 <Thread1.lto_priv.46+0x2e8>)
 800263c:	f7fe fd98 	bl	8001170 <chSysHalt>
 8002640:	482a      	ldr	r0, [pc, #168]	; (80026ec <Thread1.lto_priv.46+0x2ec>)
 8002642:	f7fe fd95 	bl	8001170 <chSysHalt>
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8002646:	2100      	movs	r1, #0

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8002648:	682a      	ldr	r2, [r5, #0]
 800264a:	61e2      	str	r2, [r4, #28]
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 800264c:	6057      	str	r7, [r2, #4]
  vtp->func = NULL;
 800264e:	60e9      	str	r1, [r5, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8002650:	42ba      	cmp	r2, r7
 8002652:	d028      	beq.n	80026a6 <Thread1.lto_priv.46+0x2a6>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8002654:	6890      	ldr	r0, [r2, #8]
 8002656:	68a9      	ldr	r1, [r5, #8]
 8002658:	4684      	mov	ip, r0
 800265a:	4461      	add	r1, ip
 800265c:	6091      	str	r1, [r2, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 800265e:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8002660:	4694      	mov	ip, r2
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8002662:	4a17      	ldr	r2, [pc, #92]	; (80026c0 <Thread1.lto_priv.46+0x2c0>)
 8002664:	6a50      	ldr	r0, [r2, #36]	; 0x24
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002666:	4662      	mov	r2, ip
 8002668:	1a80      	subs	r0, r0, r2
 800266a:	b280      	uxth	r0, r0

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 800266c:	4281      	cmp	r1, r0
 800266e:	d800      	bhi.n	8002672 <Thread1.lto_priv.46+0x272>
 8002670:	e777      	b.n	8002562 <Thread1.lto_priv.46+0x162>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8002672:	1a0a      	subs	r2, r1, r0

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8002674:	2a01      	cmp	r2, #1
 8002676:	d90f      	bls.n	8002698 <Thread1.lto_priv.46+0x298>
 8002678:	1e0a      	subs	r2, r1, #0
 800267a:	4913      	ldr	r1, [pc, #76]	; (80026c8 <Thread1.lto_priv.46+0x2c8>)
 800267c:	428a      	cmp	r2, r1
 800267e:	d900      	bls.n	8002682 <Thread1.lto_priv.46+0x282>
 8002680:	1c0a      	adds	r2, r1, #0

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8002682:	4462      	add	r2, ip
 8002684:	b292      	uxth	r2, r2
 8002686:	4694      	mov	ip, r2
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8002688:	464a      	mov	r2, r9
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 800268a:	490d      	ldr	r1, [pc, #52]	; (80026c0 <Thread1.lto_priv.46+0x2c0>)
 800268c:	68c8      	ldr	r0, [r1, #12]
 800268e:	4210      	tst	r0, r2
 8002690:	d0cd      	beq.n	800262e <Thread1.lto_priv.46+0x22e>
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8002692:	4662      	mov	r2, ip
 8002694:	634a      	str	r2, [r1, #52]	; 0x34
 8002696:	e764      	b.n	8002562 <Thread1.lto_priv.46+0x162>
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
 8002698:	490b      	ldr	r1, [pc, #44]	; (80026c8 <Thread1.lto_priv.46+0x2c8>)
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800269a:	1c82      	adds	r2, r0, #2
 800269c:	428a      	cmp	r2, r1
 800269e:	d9f0      	bls.n	8002682 <Thread1.lto_priv.46+0x282>
 80026a0:	4813      	ldr	r0, [pc, #76]	; (80026f0 <Thread1.lto_priv.46+0x2f0>)
 80026a2:	f7fe fd65 	bl	8001170 <chSysHalt>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80026a6:	4a06      	ldr	r2, [pc, #24]	; (80026c0 <Thread1.lto_priv.46+0x2c0>)
 80026a8:	60d1      	str	r1, [r2, #12]
 80026aa:	e75a      	b.n	8002562 <Thread1.lto_priv.46+0x162>
 80026ac:	20000700 	.word	0x20000700
 80026b0:	08003874 	.word	0x08003874
 80026b4:	080036c8 	.word	0x080036c8
 80026b8:	080019c1 	.word	0x080019c1
 80026bc:	2000071c 	.word	0x2000071c
 80026c0:	40000400 	.word	0x40000400
 80026c4:	00001388 	.word	0x00001388
 80026c8:	0000ffff 	.word	0x0000ffff
 80026cc:	48000400 	.word	0x48000400
 80026d0:	08003758 	.word	0x08003758
 80026d4:	080036d0 	.word	0x080036d0
 80026d8:	080036d8 	.word	0x080036d8
 80026dc:	080036e8 	.word	0x080036e8
 80026e0:	08003714 	.word	0x08003714
 80026e4:	08003690 	.word	0x08003690
 80026e8:	080036f0 	.word	0x080036f0
 80026ec:	08003618 	.word	0x08003618
 80026f0:	08003624 	.word	0x08003624
	...

08002700 <NMI_Handler>:
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002700:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  struct port_extctx *ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8002704:	3320      	adds	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002706:	f383 8809 	msr	PSP, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800270a:	b662      	cpsie	i
  /* Writing back the modified PSP value.*/
  __set_PSP((uint32_t)ctxp);

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
}
 800270c:	4770      	bx	lr
 800270e:	46c0      	nop			; (mov r8, r8)

08002710 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002710:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8002712:	4c54      	ldr	r4, [pc, #336]	; (8002864 <chMtxUnlock+0x154>)
 8002714:	69a3      	ldr	r3, [r4, #24]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8002716:	2800      	cmp	r0, #0
 8002718:	d011      	beq.n	800273e <chMtxUnlock+0x2e>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800271a:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800271c:	6b22      	ldr	r2, [r4, #48]	; 0x30
 800271e:	2a00      	cmp	r2, #0
 8002720:	d102      	bne.n	8002728 <chMtxUnlock+0x18>
 8002722:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002724:	2a00      	cmp	r2, #0
 8002726:	d002      	beq.n	800272e <chMtxUnlock+0x1e>
    chSysHalt("SV#4");
 8002728:	484f      	ldr	r0, [pc, #316]	; (8002868 <chMtxUnlock+0x158>)
 800272a:	f7fe fd21 	bl	8001170 <chSysHalt>
  }
  _dbg_enter_lock();
 800272e:	2101      	movs	r1, #1
 8002730:	6361      	str	r1, [r4, #52]	; 0x34

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8002732:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8002734:	2900      	cmp	r1, #0
 8002736:	d002      	beq.n	800273e <chMtxUnlock+0x2e>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8002738:	688d      	ldr	r5, [r1, #8]
 800273a:	429d      	cmp	r5, r3
 800273c:	d002      	beq.n	8002744 <chMtxUnlock+0x34>
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 800273e:	484b      	ldr	r0, [pc, #300]	; (800286c <chMtxUnlock+0x15c>)
 8002740:	f7fe fd16 	bl	8001170 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8002744:	4288      	cmp	r0, r1
 8002746:	d1fa      	bne.n	800273e <chMtxUnlock+0x2e>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8002748:	68c3      	ldr	r3, [r0, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800274a:	6801      	ldr	r1, [r0, #0]
 800274c:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800274e:	4288      	cmp	r0, r1
 8002750:	d033      	beq.n	80027ba <chMtxUnlock+0xaa>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8002752:	6bee      	ldr	r6, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8002754:	2b00      	cmp	r3, #0
 8002756:	d009      	beq.n	800276c <chMtxUnlock+0x5c>
 8002758:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800275a:	4293      	cmp	r3, r2
 800275c:	d003      	beq.n	8002766 <chMtxUnlock+0x56>
            (lmp->queue.next->prio > newprio)) {
 800275e:	6892      	ldr	r2, [r2, #8]
 8002760:	4296      	cmp	r6, r2
 8002762:	d200      	bcs.n	8002766 <chMtxUnlock+0x56>
 8002764:	1c16      	adds	r6, r2, #0
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8002766:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8002768:	2b00      	cmp	r3, #0
 800276a:	d1f5      	bne.n	8002758 <chMtxUnlock+0x48>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800276c:	680b      	ldr	r3, [r1, #0]
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800276e:	60ae      	str	r6, [r5, #8]
 8002770:	6003      	str	r3, [r0, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002772:	6058      	str	r0, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8002774:	6b8b      	ldr	r3, [r1, #56]	; 0x38
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8002776:	6081      	str	r1, [r0, #8]
      mp->next = tp->mtxlist;
 8002778:	60c3      	str	r3, [r0, #12]
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800277a:	2320      	movs	r3, #32
      tp->mtxlist = mp;
 800277c:	6388      	str	r0, [r1, #56]	; 0x38
 800277e:	5cca      	ldrb	r2, [r1, r3]
 8002780:	2a00      	cmp	r2, #0
 8002782:	d02a      	beq.n	80027da <chMtxUnlock+0xca>
 8002784:	2a0f      	cmp	r2, #15
 8002786:	d028      	beq.n	80027da <chMtxUnlock+0xca>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002788:	2200      	movs	r2, #0
 800278a:	54ca      	strb	r2, [r1, r3]
  cp = (thread_t *)&ch.rlist.queue;
 800278c:	1c23      	adds	r3, r4, #0
 800278e:	688a      	ldr	r2, [r1, #8]
  do {
    cp = cp->queue.next;
 8002790:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8002792:	6898      	ldr	r0, [r3, #8]
 8002794:	4290      	cmp	r0, r2
 8002796:	d2fb      	bcs.n	8002790 <chMtxUnlock+0x80>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8002798:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800279a:	600b      	str	r3, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 800279c:	604a      	str	r2, [r1, #4]
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 800279e:	69a5      	ldr	r5, [r4, #24]
  tp->queue.prev->queue.next = tp;
 80027a0:	6011      	str	r1, [r2, #0]
 80027a2:	6822      	ldr	r2, [r4, #0]
  cp->queue.prev             = tp;
 80027a4:	6059      	str	r1, [r3, #4]
 80027a6:	68a9      	ldr	r1, [r5, #8]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 80027a8:	6893      	ldr	r3, [r2, #8]
 80027aa:	428b      	cmp	r3, r1
 80027ac:	d81b      	bhi.n	80027e6 <chMtxUnlock+0xd6>
 80027ae:	6b23      	ldr	r3, [r4, #48]	; 0x30
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80027b0:	2b00      	cmp	r3, #0
 80027b2:	d003      	beq.n	80027bc <chMtxUnlock+0xac>
    chSysHalt("SV#5");
 80027b4:	482e      	ldr	r0, [pc, #184]	; (8002870 <chMtxUnlock+0x160>)
 80027b6:	f7fe fcdb 	bl	8001170 <chSysHalt>
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->owner = NULL;
 80027ba:	6082      	str	r2, [r0, #8]
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 80027bc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80027be:	2b00      	cmp	r3, #0
 80027c0:	ddf8      	ble.n	80027b4 <chMtxUnlock+0xa4>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80027c2:	2300      	movs	r3, #0
 80027c4:	6363      	str	r3, [r4, #52]	; 0x34
 80027c6:	6823      	ldr	r3, [r4, #0]
 80027c8:	42a3      	cmp	r3, r4
 80027ca:	d004      	beq.n	80027d6 <chMtxUnlock+0xc6>
 80027cc:	69a2      	ldr	r2, [r4, #24]
 80027ce:	689b      	ldr	r3, [r3, #8]
 80027d0:	6892      	ldr	r2, [r2, #8]
 80027d2:	429a      	cmp	r2, r3
 80027d4:	d304      	bcc.n	80027e0 <chMtxUnlock+0xd0>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80027d6:	b662      	cpsie	i
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
 80027d8:	bd70      	pop	{r4, r5, r6, pc}
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80027da:	4826      	ldr	r0, [pc, #152]	; (8002874 <chMtxUnlock+0x164>)
 80027dc:	f7fe fcc8 	bl	8001170 <chSysHalt>
 80027e0:	4825      	ldr	r0, [pc, #148]	; (8002878 <chMtxUnlock+0x168>)
 80027e2:	f7fe fcc5 	bl	8001170 <chSysHalt>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80027e6:	6813      	ldr	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80027e8:	2001      	movs	r0, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80027ea:	605c      	str	r4, [r3, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80027ec:	6023      	str	r3, [r4, #0]
 80027ee:	2320      	movs	r3, #32
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80027f0:	61a2      	str	r2, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 80027f2:	54d0      	strb	r0, [r2, r3]
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80027f4:	5ce8      	ldrb	r0, [r5, r3]
 80027f6:	2800      	cmp	r0, #0
 80027f8:	d02e      	beq.n	8002858 <chMtxUnlock+0x148>
 80027fa:	280f      	cmp	r0, #15
 80027fc:	d02c      	beq.n	8002858 <chMtxUnlock+0x148>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80027fe:	2000      	movs	r0, #0
 8002800:	54e8      	strb	r0, [r5, r3]
  cp = (thread_t *)&ch.rlist.queue;
 8002802:	1c23      	adds	r3, r4, #0
  do {
    cp = cp->queue.next;
 8002804:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8002806:	6898      	ldr	r0, [r3, #8]
 8002808:	4281      	cmp	r1, r0
 800280a:	d3fb      	bcc.n	8002804 <chMtxUnlock+0xf4>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800280c:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800280e:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8002810:	6069      	str	r1, [r5, #4]
  tp->queue.prev->queue.next = tp;
 8002812:	600d      	str	r5, [r1, #0]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002814:	2101      	movs	r1, #1
  cp->queue.prev             = tp;
 8002816:	605d      	str	r5, [r3, #4]
 8002818:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 800281a:	420b      	tst	r3, r1
 800281c:	d111      	bne.n	8002842 <chMtxUnlock+0x132>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 800281e:	2607      	movs	r6, #7
 8002820:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8002822:	7818      	ldrb	r0, [r3, #0]
 8002824:	43b0      	bics	r0, r6
 8002826:	4308      	orrs	r0, r1
 8002828:	7018      	strb	r0, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 800282a:	311f      	adds	r1, #31
 800282c:	5c69      	ldrb	r1, [r5, r1]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 800282e:	609a      	str	r2, [r3, #8]

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002830:	00c8      	lsls	r0, r1, #3
 8002832:	7819      	ldrb	r1, [r3, #0]
 8002834:	4031      	ands	r1, r6
 8002836:	4301      	orrs	r1, r0
 8002838:	7019      	strb	r1, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 800283a:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 800283c:	60da      	str	r2, [r3, #12]
    trace_next();
 800283e:	f7fe fc7f 	bl	8001140 <trace_next.lto_priv.45>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002842:	f3ef 8309 	mrs	r3, PSP

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002846:	69ea      	ldr	r2, [r5, #28]
 8002848:	3b24      	subs	r3, #36	; 0x24
 800284a:	429a      	cmp	r2, r3
 800284c:	d807      	bhi.n	800285e <chMtxUnlock+0x14e>
 800284e:	69a0      	ldr	r0, [r4, #24]
 8002850:	1c29      	adds	r1, r5, #0
 8002852:	f7fd fca1 	bl	8000198 <_port_switch>
 8002856:	e7aa      	b.n	80027ae <chMtxUnlock+0x9e>
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8002858:	4808      	ldr	r0, [pc, #32]	; (800287c <chMtxUnlock+0x16c>)
 800285a:	f7fe fc89 	bl	8001170 <chSysHalt>

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800285e:	4808      	ldr	r0, [pc, #32]	; (8002880 <chMtxUnlock+0x170>)
 8002860:	f7fe fc86 	bl	8001170 <chSysHalt>
 8002864:	20000700 	.word	0x20000700
 8002868:	080036c8 	.word	0x080036c8
 800286c:	08003868 	.word	0x08003868
 8002870:	080036f0 	.word	0x080036f0
 8002874:	08003978 	.word	0x08003978
 8002878:	080036f8 	.word	0x080036f8
 800287c:	08003964 	.word	0x08003964
 8002880:	080036d8 	.word	0x080036d8
	...

08002890 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8002890:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8002892:	4e53      	ldr	r6, [pc, #332]	; (80029e0 <chMtxLockS+0x150>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8002894:	1c05      	adds	r5, r0, #0
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002896:	6b33      	ldr	r3, [r6, #48]	; 0x30
  thread_t *ctp = currp;
 8002898:	69b4      	ldr	r4, [r6, #24]
 800289a:	2b00      	cmp	r3, #0
 800289c:	d142      	bne.n	8002924 <chMtxLockS+0x94>
 800289e:	6b73      	ldr	r3, [r6, #52]	; 0x34
 80028a0:	2b00      	cmp	r3, #0
 80028a2:	dd3f      	ble.n	8002924 <chMtxLockS+0x94>

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);
 80028a4:	2800      	cmp	r0, #0
 80028a6:	d03a      	beq.n	800291e <chMtxLockS+0x8e>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 80028a8:	6882      	ldr	r2, [r0, #8]
 80028aa:	2a00      	cmp	r2, #0
 80028ac:	d077      	beq.n	800299e <chMtxLockS+0x10e>
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80028ae:	2320      	movs	r3, #32
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80028b0:	68a1      	ldr	r1, [r4, #8]
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80028b2:	469c      	mov	ip, r3
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80028b4:	6893      	ldr	r3, [r2, #8]
 80028b6:	428b      	cmp	r3, r1
 80028b8:	d208      	bcs.n	80028cc <chMtxLockS+0x3c>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80028ba:	4663      	mov	r3, ip

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 80028bc:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 80028be:	5cd3      	ldrb	r3, [r2, r3]
 80028c0:	2b06      	cmp	r3, #6
 80028c2:	d053      	beq.n	800296c <chMtxLockS+0xdc>
 80028c4:	2b07      	cmp	r3, #7
 80028c6:	d042      	beq.n	800294e <chMtxLockS+0xbe>
 80028c8:	2b00      	cmp	r3, #0
 80028ca:	d02e      	beq.n	800292a <chMtxLockS+0x9a>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80028cc:	1c2b      	adds	r3, r5, #0
 80028ce:	e003      	b.n	80028d8 <chMtxLockS+0x48>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80028d0:	689a      	ldr	r2, [r3, #8]
 80028d2:	68a1      	ldr	r1, [r4, #8]
 80028d4:	428a      	cmp	r2, r1
 80028d6:	d302      	bcc.n	80028de <chMtxLockS+0x4e>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80028d8:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80028da:	429d      	cmp	r5, r3
 80028dc:	d1f8      	bne.n	80028d0 <chMtxLockS+0x40>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80028de:	685a      	ldr	r2, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80028e0:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 80028e2:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 80028e4:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80028e6:	605c      	str	r4, [r3, #4]
  thread_t *otp = currp;

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 80028e8:	2220      	movs	r2, #32
 80028ea:	2306      	movs	r3, #6
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 80028ec:	6265      	str	r5, [r4, #36]	; 0x24
 80028ee:	54a3      	strb	r3, [r4, r2]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80028f0:	6833      	ldr	r3, [r6, #0]

  tqp->next             = tp->queue.next;
 80028f2:	6819      	ldr	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80028f4:	604e      	str	r6, [r1, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80028f6:	6031      	str	r1, [r6, #0]
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80028f8:	2101      	movs	r1, #1
 80028fa:	5499      	strb	r1, [r3, r2]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80028fc:	8f30      	ldrh	r0, [r6, #56]	; 0x38
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80028fe:	61b3      	str	r3, [r6, #24]
 8002900:	4201      	tst	r1, r0
 8002902:	d051      	beq.n	80029a8 <chMtxLockS+0x118>
 8002904:	f3ef 8309 	mrs	r3, PSP
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8002908:	69e2      	ldr	r2, [r4, #28]
 800290a:	3b24      	subs	r3, #36	; 0x24
 800290c:	429a      	cmp	r2, r3
 800290e:	d860      	bhi.n	80029d2 <chMtxLockS+0x142>
 8002910:	69b0      	ldr	r0, [r6, #24]
 8002912:	1c21      	adds	r1, r4, #0
 8002914:	f7fd fc40 	bl	8000198 <_port_switch>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 8002918:	68ab      	ldr	r3, [r5, #8]
 800291a:	42a3      	cmp	r3, r4
 800291c:	d05c      	beq.n	80029d8 <chMtxLockS+0x148>
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);
 800291e:	4831      	ldr	r0, [pc, #196]	; (80029e4 <chMtxLockS+0x154>)
 8002920:	f7fe fc26 	bl	8001170 <chSysHalt>
    chSysHalt("SV#11");
 8002924:	4830      	ldr	r0, [pc, #192]	; (80029e8 <chMtxLockS+0x158>)
 8002926:	f7fe fc23 	bl	8001170 <chSysHalt>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800292a:	6850      	ldr	r0, [r2, #4]
 800292c:	6817      	ldr	r7, [r2, #0]
 800292e:	6007      	str	r7, [r0, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002930:	6817      	ldr	r7, [r2, #0]
 8002932:	6078      	str	r0, [r7, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002934:	2020      	movs	r0, #32
 8002936:	5413      	strb	r3, [r2, r0]
  cp = (thread_t *)&ch.rlist.queue;
 8002938:	1c33      	adds	r3, r6, #0
  do {
    cp = cp->queue.next;
 800293a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800293c:	6898      	ldr	r0, [r3, #8]
 800293e:	4281      	cmp	r1, r0
 8002940:	d9fb      	bls.n	800293a <chMtxLockS+0xaa>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8002942:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8002944:	6859      	ldr	r1, [r3, #4]
 8002946:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8002948:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 800294a:	605a      	str	r2, [r3, #4]
 800294c:	e7be      	b.n	80028cc <chMtxLockS+0x3c>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800294e:	6853      	ldr	r3, [r2, #4]
 8002950:	6810      	ldr	r0, [r2, #0]
 8002952:	6018      	str	r0, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002954:	6810      	ldr	r0, [r2, #0]
 8002956:	6043      	str	r3, [r0, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8002958:	6a50      	ldr	r0, [r2, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800295a:	1c03      	adds	r3, r0, #0
 800295c:	e002      	b.n	8002964 <chMtxLockS+0xd4>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800295e:	689f      	ldr	r7, [r3, #8]
 8002960:	428f      	cmp	r7, r1
 8002962:	d3ee      	bcc.n	8002942 <chMtxLockS+0xb2>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8002964:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002966:	4298      	cmp	r0, r3
 8002968:	d1f9      	bne.n	800295e <chMtxLockS+0xce>
 800296a:	e7ea      	b.n	8002942 <chMtxLockS+0xb2>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800296c:	6853      	ldr	r3, [r2, #4]
 800296e:	6810      	ldr	r0, [r2, #0]
 8002970:	6018      	str	r0, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002972:	6810      	ldr	r0, [r2, #0]
 8002974:	6043      	str	r3, [r0, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8002976:	6a50      	ldr	r0, [r2, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8002978:	1c03      	adds	r3, r0, #0
 800297a:	e002      	b.n	8002982 <chMtxLockS+0xf2>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800297c:	689f      	ldr	r7, [r3, #8]
 800297e:	428f      	cmp	r7, r1
 8002980:	d302      	bcc.n	8002988 <chMtxLockS+0xf8>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8002982:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002984:	4298      	cmp	r0, r3
 8002986:	d1f9      	bne.n	800297c <chMtxLockS+0xec>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8002988:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800298a:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 800298c:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 800298e:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8002990:	605a      	str	r2, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 8002992:	6882      	ldr	r2, [r0, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8002994:	68a1      	ldr	r1, [r4, #8]
 8002996:	6893      	ldr	r3, [r2, #8]
 8002998:	428b      	cmp	r3, r1
 800299a:	d38e      	bcc.n	80028ba <chMtxLockS+0x2a>
 800299c:	e796      	b.n	80028cc <chMtxLockS+0x3c>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 800299e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 80029a0:	6084      	str	r4, [r0, #8]
    mp->next = ctp->mtxlist;
 80029a2:	60c3      	str	r3, [r0, #12]
    ctp->mtxlist = mp;
 80029a4:	63a0      	str	r0, [r4, #56]	; 0x38
  }
}
 80029a6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80029a8:	2707      	movs	r7, #7
 80029aa:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
 80029ac:	46bc      	mov	ip, r7
 80029ae:	7808      	ldrb	r0, [r1, #0]
 80029b0:	43b8      	bics	r0, r7
 80029b2:	2701      	movs	r7, #1
 80029b4:	4338      	orrs	r0, r7
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80029b6:	4667      	mov	r7, ip
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80029b8:	7008      	strb	r0, [r1, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80029ba:	5ca0      	ldrb	r0, [r4, r2]
 80029bc:	780a      	ldrb	r2, [r1, #0]
 80029be:	00c0      	lsls	r0, r0, #3
 80029c0:	403a      	ands	r2, r7
 80029c2:	4302      	orrs	r2, r0
 80029c4:	700a      	strb	r2, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80029c6:	608b      	str	r3, [r1, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80029c8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80029ca:	60cb      	str	r3, [r1, #12]
    trace_next();
 80029cc:	f7fe fbb8 	bl	8001140 <trace_next.lto_priv.45>
 80029d0:	e798      	b.n	8002904 <chMtxLockS+0x74>
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80029d2:	4806      	ldr	r0, [pc, #24]	; (80029ec <chMtxLockS+0x15c>)
 80029d4:	f7fe fbcc 	bl	8001170 <chSysHalt>
      chSchGoSleepS(CH_STATE_WTMTX);

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 80029d8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80029da:	42ab      	cmp	r3, r5
 80029dc:	d19f      	bne.n	800291e <chMtxLockS+0x8e>
 80029de:	e7e2      	b.n	80029a6 <chMtxLockS+0x116>
 80029e0:	20000700 	.word	0x20000700
 80029e4:	0800387c 	.word	0x0800387c
 80029e8:	080036d0 	.word	0x080036d0
 80029ec:	080036d8 	.word	0x080036d8

080029f0 <adc_lld_serve_rx_interrupt.lto_priv.59>:
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 80029f0:	b538      	push	{r3, r4, r5, lr}
 80029f2:	1c04      	adds	r4, r0, #0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80029f4:	070b      	lsls	r3, r1, #28
 80029f6:	d419      	bmi.n	8002a2c <adc_lld_serve_rx_interrupt.lto_priv.59+0x3c>
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 80029f8:	6903      	ldr	r3, [r0, #16]
 80029fa:	2b00      	cmp	r3, #0
 80029fc:	d00e      	beq.n	8002a1c <adc_lld_serve_rx_interrupt.lto_priv.59+0x2c>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 80029fe:	078a      	lsls	r2, r1, #30
 8002a00:	d50d      	bpl.n	8002a1e <adc_lld_serve_rx_interrupt.lto_priv.59+0x2e>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8002a02:	781a      	ldrb	r2, [r3, #0]
 8002a04:	2a00      	cmp	r2, #0
 8002a06:	d051      	beq.n	8002aac <adc_lld_serve_rx_interrupt.lto_priv.59+0xbc>
 8002a08:	685b      	ldr	r3, [r3, #4]
 8002a0a:	2b00      	cmp	r3, #0
 8002a0c:	d006      	beq.n	8002a1c <adc_lld_serve_rx_interrupt.lto_priv.59+0x2c>
 8002a0e:	2204      	movs	r2, #4
 8002a10:	7002      	strb	r2, [r0, #0]
 8002a12:	4798      	blx	r3
 8002a14:	7823      	ldrb	r3, [r4, #0]
 8002a16:	2b04      	cmp	r3, #4
 8002a18:	d100      	bne.n	8002a1c <adc_lld_serve_rx_interrupt.lto_priv.59+0x2c>
 8002a1a:	e091      	b.n	8002b40 <adc_lld_serve_rx_interrupt.lto_priv.59+0x150>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 8002a1c:	bd38      	pop	{r3, r4, r5, pc}
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8002a1e:	074a      	lsls	r2, r1, #29
 8002a20:	d5fc      	bpl.n	8002a1c <adc_lld_serve_rx_interrupt.lto_priv.59+0x2c>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 8002a22:	685b      	ldr	r3, [r3, #4]
 8002a24:	2b00      	cmp	r3, #0
 8002a26:	d0f9      	beq.n	8002a1c <adc_lld_serve_rx_interrupt.lto_priv.59+0x2c>
 8002a28:	4798      	blx	r3
 8002a2a:	e7f7      	b.n	8002a1c <adc_lld_serve_rx_interrupt.lto_priv.59+0x2c>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8002a2c:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8002a2e:	200f      	movs	r0, #15
 8002a30:	6859      	ldr	r1, [r3, #4]
 8002a32:	680a      	ldr	r2, [r1, #0]
 8002a34:	4382      	bics	r2, r0
 8002a36:	600a      	str	r2, [r1, #0]
 8002a38:	7b59      	ldrb	r1, [r3, #13]
 8002a3a:	681a      	ldr	r2, [r3, #0]
 8002a3c:	230e      	movs	r3, #14
 8002a3e:	408b      	lsls	r3, r1
 8002a40:	6053      	str	r3, [r2, #4]
  adc_lld_stop_adc(adcp->adc);
 8002a42:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
 8002a44:	6893      	ldr	r3, [r2, #8]
 8002a46:	075b      	lsls	r3, r3, #29
 8002a48:	d418      	bmi.n	8002a7c <adc_lld_serve_rx_interrupt.lto_priv.59+0x8c>

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8002a4a:	6923      	ldr	r3, [r4, #16]
 8002a4c:	689b      	ldr	r3, [r3, #8]
 8002a4e:	2b00      	cmp	r3, #0
 8002a50:	d072      	beq.n	8002b38 <adc_lld_serve_rx_interrupt.lto_priv.59+0x148>
 8002a52:	2205      	movs	r2, #5
 8002a54:	1c20      	adds	r0, r4, #0
 8002a56:	7022      	strb	r2, [r4, #0]
 8002a58:	2100      	movs	r1, #0
 8002a5a:	4798      	blx	r3
 8002a5c:	7823      	ldrb	r3, [r4, #0]
 8002a5e:	2b05      	cmp	r3, #5
 8002a60:	d021      	beq.n	8002aa6 <adc_lld_serve_rx_interrupt.lto_priv.59+0xb6>
 8002a62:	2300      	movs	r3, #0
 8002a64:	6123      	str	r3, [r4, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002a66:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002a68:	4b45      	ldr	r3, [pc, #276]	; (8002b80 <adc_lld_serve_rx_interrupt.lto_priv.59+0x190>)
 8002a6a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002a6c:	2a00      	cmp	r2, #0
 8002a6e:	dd02      	ble.n	8002a76 <adc_lld_serve_rx_interrupt.lto_priv.59+0x86>
 8002a70:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a72:	2a00      	cmp	r2, #0
 8002a74:	d00b      	beq.n	8002a8e <adc_lld_serve_rx_interrupt.lto_priv.59+0x9e>
    chSysHalt("SV#6");
 8002a76:	4843      	ldr	r0, [pc, #268]	; (8002b84 <adc_lld_serve_rx_interrupt.lto_priv.59+0x194>)
 8002a78:	f7fe fb7a 	bl	8001170 <chSysHalt>
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8002a7c:	2310      	movs	r3, #16
 8002a7e:	6891      	ldr	r1, [r2, #8]
 8002a80:	430b      	orrs	r3, r1
    while (adc->CR & ADC_CR_ADSTP)
 8002a82:	2110      	movs	r1, #16
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8002a84:	6093      	str	r3, [r2, #8]
    while (adc->CR & ADC_CR_ADSTP)
 8002a86:	6893      	ldr	r3, [r2, #8]
 8002a88:	4219      	tst	r1, r3
 8002a8a:	d1fc      	bne.n	8002a86 <adc_lld_serve_rx_interrupt.lto_priv.59+0x96>
 8002a8c:	e7dd      	b.n	8002a4a <adc_lld_serve_rx_interrupt.lto_priv.59+0x5a>
  }
  _dbg_enter_lock();
 8002a8e:	2101      	movs	r1, #1
 8002a90:	6359      	str	r1, [r3, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8002a92:	6961      	ldr	r1, [r4, #20]
 8002a94:	2900      	cmp	r1, #0
 8002a96:	d046      	beq.n	8002b26 <adc_lld_serve_rx_interrupt.lto_priv.59+0x136>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002a98:	2020      	movs	r0, #32
 8002a9a:	5c0d      	ldrb	r5, [r1, r0]
 8002a9c:	2d03      	cmp	r5, #3
 8002a9e:	d052      	beq.n	8002b46 <adc_lld_serve_rx_interrupt.lto_priv.59+0x156>
 8002aa0:	4839      	ldr	r0, [pc, #228]	; (8002b88 <adc_lld_serve_rx_interrupt.lto_priv.59+0x198>)
 8002aa2:	f7fe fb65 	bl	8001170 <chSysHalt>

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8002aa6:	3b03      	subs	r3, #3
 8002aa8:	7023      	strb	r3, [r4, #0]
 8002aaa:	e7da      	b.n	8002a62 <adc_lld_serve_rx_interrupt.lto_priv.59+0x72>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8002aac:	250f      	movs	r5, #15
 8002aae:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
 8002ab0:	6850      	ldr	r0, [r2, #4]
 8002ab2:	6801      	ldr	r1, [r0, #0]
 8002ab4:	43a9      	bics	r1, r5
 8002ab6:	6001      	str	r1, [r0, #0]
 8002ab8:	7b50      	ldrb	r0, [r2, #13]
 8002aba:	6811      	ldr	r1, [r2, #0]
 8002abc:	220e      	movs	r2, #14
 8002abe:	4082      	lsls	r2, r0
 8002ac0:	604a      	str	r2, [r1, #4]
  adc_lld_stop_adc(adcp->adc);
 8002ac2:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
 8002ac4:	688a      	ldr	r2, [r1, #8]
 8002ac6:	0752      	lsls	r2, r2, #29
 8002ac8:	d44e      	bmi.n	8002b68 <adc_lld_serve_rx_interrupt.lto_priv.59+0x178>
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8002aca:	685b      	ldr	r3, [r3, #4]
 8002acc:	2b00      	cmp	r3, #0
 8002ace:	d02e      	beq.n	8002b2e <adc_lld_serve_rx_interrupt.lto_priv.59+0x13e>
 8002ad0:	2204      	movs	r2, #4
 8002ad2:	1c20      	adds	r0, r4, #0
 8002ad4:	7022      	strb	r2, [r4, #0]
 8002ad6:	4798      	blx	r3
 8002ad8:	7823      	ldrb	r3, [r4, #0]
 8002ada:	2b04      	cmp	r3, #4
 8002adc:	d027      	beq.n	8002b2e <adc_lld_serve_rx_interrupt.lto_priv.59+0x13e>
 8002ade:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002ae0:	4b27      	ldr	r3, [pc, #156]	; (8002b80 <adc_lld_serve_rx_interrupt.lto_priv.59+0x190>)
 8002ae2:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8002ae4:	2a00      	cmp	r2, #0
 8002ae6:	ddc6      	ble.n	8002a76 <adc_lld_serve_rx_interrupt.lto_priv.59+0x86>
 8002ae8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002aea:	2a00      	cmp	r2, #0
 8002aec:	d1c3      	bne.n	8002a76 <adc_lld_serve_rx_interrupt.lto_priv.59+0x86>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8002aee:	2101      	movs	r1, #1
 8002af0:	6359      	str	r1, [r3, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8002af2:	6961      	ldr	r1, [r4, #20]
 8002af4:	2900      	cmp	r1, #0
 8002af6:	d016      	beq.n	8002b26 <adc_lld_serve_rx_interrupt.lto_priv.59+0x136>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002af8:	2020      	movs	r0, #32
 8002afa:	5c0d      	ldrb	r5, [r1, r0]
 8002afc:	2d03      	cmp	r5, #3
 8002afe:	d1cf      	bne.n	8002aa0 <adc_lld_serve_rx_interrupt.lto_priv.59+0xb0>

    *trp = NULL;
 8002b00:	6162      	str	r2, [r4, #20]
    tp->u.rdymsg = msg;
 8002b02:	624a      	str	r2, [r1, #36]	; 0x24
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8002b04:	5c0c      	ldrb	r4, [r1, r0]
 8002b06:	2c00      	cmp	r4, #0
 8002b08:	d037      	beq.n	8002b7a <adc_lld_serve_rx_interrupt.lto_priv.59+0x18a>
 8002b0a:	2c0f      	cmp	r4, #15
 8002b0c:	d035      	beq.n	8002b7a <adc_lld_serve_rx_interrupt.lto_priv.59+0x18a>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002b0e:	540a      	strb	r2, [r1, r0]
  cp = (thread_t *)&ch.rlist.queue;
 8002b10:	1c1a      	adds	r2, r3, #0
 8002b12:	6888      	ldr	r0, [r1, #8]
  do {
    cp = cp->queue.next;
 8002b14:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8002b16:	6894      	ldr	r4, [r2, #8]
 8002b18:	4284      	cmp	r4, r0
 8002b1a:	d2fb      	bcs.n	8002b14 <adc_lld_serve_rx_interrupt.lto_priv.59+0x124>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8002b1c:	600a      	str	r2, [r1, #0]
  tp->queue.prev             = cp->queue.prev;
 8002b1e:	6850      	ldr	r0, [r2, #4]
 8002b20:	6048      	str	r0, [r1, #4]
  tp->queue.prev->queue.next = tp;
 8002b22:	6001      	str	r1, [r0, #0]
  cp->queue.prev             = tp;
 8002b24:	6051      	str	r1, [r2, #4]
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8002b26:	2200      	movs	r2, #0
 8002b28:	635a      	str	r2, [r3, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b2a:	b662      	cpsie	i
 8002b2c:	e776      	b.n	8002a1c <adc_lld_serve_rx_interrupt.lto_priv.59+0x2c>
 8002b2e:	2302      	movs	r3, #2
 8002b30:	7023      	strb	r3, [r4, #0]
 8002b32:	2300      	movs	r3, #0
 8002b34:	6123      	str	r3, [r4, #16]
 8002b36:	e7d2      	b.n	8002ade <adc_lld_serve_rx_interrupt.lto_priv.59+0xee>

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8002b38:	2202      	movs	r2, #2
 8002b3a:	6123      	str	r3, [r4, #16]
 8002b3c:	7022      	strb	r2, [r4, #0]
 8002b3e:	e792      	b.n	8002a66 <adc_lld_serve_rx_interrupt.lto_priv.59+0x76>
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8002b40:	3b01      	subs	r3, #1
 8002b42:	7023      	strb	r3, [r4, #0]
 8002b44:	e76a      	b.n	8002a1c <adc_lld_serve_rx_interrupt.lto_priv.59+0x2c>
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8002b46:	6162      	str	r2, [r4, #20]
    tp->u.rdymsg = msg;
 8002b48:	2401      	movs	r4, #1
 8002b4a:	4264      	negs	r4, r4
 8002b4c:	624c      	str	r4, [r1, #36]	; 0x24
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8002b4e:	5c0c      	ldrb	r4, [r1, r0]
 8002b50:	2c00      	cmp	r4, #0
 8002b52:	d012      	beq.n	8002b7a <adc_lld_serve_rx_interrupt.lto_priv.59+0x18a>
 8002b54:	2c0f      	cmp	r4, #15
 8002b56:	d010      	beq.n	8002b7a <adc_lld_serve_rx_interrupt.lto_priv.59+0x18a>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002b58:	540a      	strb	r2, [r1, r0]
  cp = (thread_t *)&ch.rlist.queue;
 8002b5a:	1c1a      	adds	r2, r3, #0
 8002b5c:	6888      	ldr	r0, [r1, #8]
  do {
    cp = cp->queue.next;
 8002b5e:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8002b60:	6894      	ldr	r4, [r2, #8]
 8002b62:	4284      	cmp	r4, r0
 8002b64:	d2fb      	bcs.n	8002b5e <adc_lld_serve_rx_interrupt.lto_priv.59+0x16e>
 8002b66:	e7d9      	b.n	8002b1c <adc_lld_serve_rx_interrupt.lto_priv.59+0x12c>
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8002b68:	2210      	movs	r2, #16
 8002b6a:	6888      	ldr	r0, [r1, #8]
 8002b6c:	4302      	orrs	r2, r0
    while (adc->CR & ADC_CR_ADSTP)
 8002b6e:	2010      	movs	r0, #16
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8002b70:	608a      	str	r2, [r1, #8]
    while (adc->CR & ADC_CR_ADSTP)
 8002b72:	688a      	ldr	r2, [r1, #8]
 8002b74:	4210      	tst	r0, r2
 8002b76:	d1fc      	bne.n	8002b72 <adc_lld_serve_rx_interrupt.lto_priv.59+0x182>
 8002b78:	e7a7      	b.n	8002aca <adc_lld_serve_rx_interrupt.lto_priv.59+0xda>
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8002b7a:	4804      	ldr	r0, [pc, #16]	; (8002b8c <adc_lld_serve_rx_interrupt.lto_priv.59+0x19c>)
 8002b7c:	f7fe faf8 	bl	8001170 <chSysHalt>
 8002b80:	20000700 	.word	0x20000700
 8002b84:	080037e0 	.word	0x080037e0
 8002b88:	0800384c 	.word	0x0800384c
 8002b8c:	08003978 	.word	0x08003978

08002b90 <Vector70>:
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_ADC1_HANDLER) {
 8002b90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002b92:	4656      	mov	r6, sl
 8002b94:	4644      	mov	r4, r8
 8002b96:	465f      	mov	r7, fp
 8002b98:	464d      	mov	r5, r9
 8002b9a:	b4f0      	push	{r4, r5, r6, r7}
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002b9c:	4c90      	ldr	r4, [pc, #576]	; (8002de0 <Vector70+0x250>)

  OSAL_IRQ_PROLOGUE();
 8002b9e:	4676      	mov	r6, lr
 8002ba0:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8002ba2:	079b      	lsls	r3, r3, #30
 8002ba4:	d40d      	bmi.n	8002bc2 <Vector70+0x32>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002ba6:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002ba8:	2007      	movs	r0, #7
 8002baa:	2202      	movs	r2, #2
 8002bac:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002bae:	780b      	ldrb	r3, [r1, #0]
 8002bb0:	4383      	bics	r3, r0
 8002bb2:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002bb4:	4003      	ands	r3, r0
 8002bb6:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002bb8:	4b8a      	ldr	r3, [pc, #552]	; (8002de4 <Vector70+0x254>)
 8002bba:	608b      	str	r3, [r1, #8]
    trace_next();
 8002bbc:	f7fe fac0 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002bc0:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002bc2:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002bc4:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002bc6:	2b00      	cmp	r3, #0
 8002bc8:	db02      	blt.n	8002bd0 <Vector70+0x40>
 8002bca:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002bcc:	2a00      	cmp	r2, #0
 8002bce:	d002      	beq.n	8002bd6 <Vector70+0x46>
    chSysHalt("SV#8");
 8002bd0:	4885      	ldr	r0, [pc, #532]	; (8002de8 <Vector70+0x258>)
 8002bd2:	f7fe facd 	bl	8001170 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8002bd6:	3301      	adds	r3, #1
 8002bd8:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002bda:	b662      	cpsie	i
 * @notapi
 */
void adc_lld_serve_interrupt(ADCDriver *adcp) {
  uint32_t isr;

  isr = adcp->adc->ISR;
 8002bdc:	4d83      	ldr	r5, [pc, #524]	; (8002dec <Vector70+0x25c>)
 8002bde:	6aab      	ldr	r3, [r5, #40]	; 0x28
  adcp->adc->ISR = isr;

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8002be0:	692a      	ldr	r2, [r5, #16]
 * @notapi
 */
void adc_lld_serve_interrupt(ADCDriver *adcp) {
  uint32_t isr;

  isr = adcp->adc->ISR;
 8002be2:	681f      	ldr	r7, [r3, #0]
  adcp->adc->ISR = isr;
 8002be4:	601f      	str	r7, [r3, #0]

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8002be6:	2a00      	cmp	r2, #0
 8002be8:	d00c      	beq.n	8002c04 <Vector70+0x74>
    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
 8002bea:	2110      	movs	r1, #16
 8002bec:	468a      	mov	sl, r1
 8002bee:	4239      	tst	r1, r7
 8002bf0:	d006      	beq.n	8002c00 <Vector70+0x70>
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
 8002bf2:	6ae9      	ldr	r1, [r5, #44]	; 0x2c
 8002bf4:	468b      	mov	fp, r1
 8002bf6:	6849      	ldr	r1, [r1, #4]
 8002bf8:	468c      	mov	ip, r1
 8002bfa:	6849      	ldr	r1, [r1, #4]
  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
 8002bfc:	2900      	cmp	r1, #0
 8002bfe:	d155      	bne.n	8002cac <Vector70+0x11c>
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
    }
    if (isr & ADC_ISR_AWD) {
 8002c00:	063b      	lsls	r3, r7, #24
 8002c02:	d409      	bmi.n	8002c18 <Vector70+0x88>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002c04:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002c06:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002c08:	2b00      	cmp	r3, #0
 8002c0a:	dd02      	ble.n	8002c12 <Vector70+0x82>
 8002c0c:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002c0e:	2a00      	cmp	r2, #0
 8002c10:	d02d      	beq.n	8002c6e <Vector70+0xde>
    chSysHalt("SV#9");
 8002c12:	4877      	ldr	r0, [pc, #476]	; (8002df0 <Vector70+0x260>)
 8002c14:	f7fe faac 	bl	8001170 <chSysHalt>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8002c18:	200f      	movs	r0, #15
 8002c1a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8002c1c:	6859      	ldr	r1, [r3, #4]
 8002c1e:	680a      	ldr	r2, [r1, #0]
 8002c20:	4382      	bics	r2, r0
 8002c22:	600a      	str	r2, [r1, #0]
 8002c24:	7b59      	ldrb	r1, [r3, #13]
 8002c26:	681a      	ldr	r2, [r3, #0]
 8002c28:	230e      	movs	r3, #14
 8002c2a:	408b      	lsls	r3, r1
 8002c2c:	6053      	str	r3, [r2, #4]
  adc_lld_stop_adc(adcp->adc);
 8002c2e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
 8002c30:	6893      	ldr	r3, [r2, #8]
 8002c32:	075b      	lsls	r3, r3, #29
 8002c34:	d500      	bpl.n	8002c38 <Vector70+0xa8>
 8002c36:	e094      	b.n	8002d62 <Vector70+0x1d2>
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
    }
    if (isr & ADC_ISR_AWD) {
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD);
 8002c38:	692b      	ldr	r3, [r5, #16]
 8002c3a:	689b      	ldr	r3, [r3, #8]
 8002c3c:	2b00      	cmp	r3, #0
 8002c3e:	d100      	bne.n	8002c42 <Vector70+0xb2>
 8002c40:	e0b4      	b.n	8002dac <Vector70+0x21c>
 8002c42:	2205      	movs	r2, #5
 8002c44:	1c28      	adds	r0, r5, #0
 8002c46:	702a      	strb	r2, [r5, #0]
 8002c48:	2102      	movs	r1, #2
 8002c4a:	4798      	blx	r3
 8002c4c:	782b      	ldrb	r3, [r5, #0]
 8002c4e:	2b05      	cmp	r3, #5
 8002c50:	d100      	bne.n	8002c54 <Vector70+0xc4>
 8002c52:	e0b2      	b.n	8002dba <Vector70+0x22a>
 8002c54:	2300      	movs	r3, #0
 8002c56:	612b      	str	r3, [r5, #16]
 8002c58:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002c5a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002c5c:	2b00      	cmp	r3, #0
 8002c5e:	dd03      	ble.n	8002c68 <Vector70+0xd8>
 8002c60:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002c62:	2b00      	cmp	r3, #0
 8002c64:	d100      	bne.n	8002c68 <Vector70+0xd8>
 8002c66:	e085      	b.n	8002d74 <Vector70+0x1e4>
    chSysHalt("SV#6");
 8002c68:	4862      	ldr	r0, [pc, #392]	; (8002df4 <Vector70+0x264>)
 8002c6a:	f7fe fa81 	bl	8001170 <chSysHalt>

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#9");
  }
  ch.dbg.isr_cnt--;
 8002c6e:	3b01      	subs	r3, #1
 8002c70:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002c72:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002c74:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8002c76:	079b      	lsls	r3, r3, #30
 8002c78:	d561      	bpl.n	8002d3e <Vector70+0x1ae>
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8002c7a:	360f      	adds	r6, #15
 8002c7c:	d010      	beq.n	8002ca0 <Vector70+0x110>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002c7e:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002c80:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8002c84:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002c86:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8002c8a:	2280      	movs	r2, #128	; 0x80
 8002c8c:	0452      	lsls	r2, r2, #17
 8002c8e:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8002c90:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8002c92:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8002c94:	6889      	ldr	r1, [r1, #8]
 8002c96:	6892      	ldr	r2, [r2, #8]
 8002c98:	4291      	cmp	r1, r2
 8002c9a:	d85f      	bhi.n	8002d5c <Vector70+0x1cc>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8002c9c:	4a56      	ldr	r2, [pc, #344]	; (8002df8 <Vector70+0x268>)
 8002c9e:	619a      	str	r2, [r3, #24]
#if defined(STM32_ADC_ADC1_IRQ_HOOK)
  STM32_ADC_ADC1_IRQ_HOOK
#endif

  OSAL_IRQ_EPILOGUE();
}
 8002ca0:	bc3c      	pop	{r2, r3, r4, r5}
 8002ca2:	4690      	mov	r8, r2
 8002ca4:	4699      	mov	r9, r3
 8002ca6:	46a2      	mov	sl, r4
 8002ca8:	46ab      	mov	fp, r5
 8002caa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8002cac:	4661      	mov	r1, ip
 8002cae:	6809      	ldr	r1, [r1, #0]
 8002cb0:	4688      	mov	r8, r1
 8002cb2:	210f      	movs	r1, #15
 8002cb4:	4689      	mov	r9, r1
 8002cb6:	4641      	mov	r1, r8
 8002cb8:	4648      	mov	r0, r9
 8002cba:	4381      	bics	r1, r0
 8002cbc:	4688      	mov	r8, r1
 8002cbe:	4661      	mov	r1, ip
 8002cc0:	4640      	mov	r0, r8
 8002cc2:	6008      	str	r0, [r1, #0]
 8002cc4:	4659      	mov	r1, fp
 8002cc6:	6809      	ldr	r1, [r1, #0]
 8002cc8:	200e      	movs	r0, #14
 8002cca:	468c      	mov	ip, r1
 8002ccc:	4659      	mov	r1, fp
 8002cce:	7b49      	ldrb	r1, [r1, #13]
 8002cd0:	4088      	lsls	r0, r1
 8002cd2:	4661      	mov	r1, ip
 8002cd4:	6048      	str	r0, [r1, #4]
 *
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
 8002cd6:	6898      	ldr	r0, [r3, #8]
 8002cd8:	0741      	lsls	r1, r0, #29
 8002cda:	d471      	bmi.n	8002dc0 <Vector70+0x230>
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
 8002cdc:	6893      	ldr	r3, [r2, #8]
 8002cde:	2b00      	cmp	r3, #0
 8002ce0:	d077      	beq.n	8002dd2 <Vector70+0x242>
 8002ce2:	2205      	movs	r2, #5
 8002ce4:	1c28      	adds	r0, r5, #0
 8002ce6:	702a      	strb	r2, [r5, #0]
 8002ce8:	2101      	movs	r1, #1
 8002cea:	4798      	blx	r3
 8002cec:	782b      	ldrb	r3, [r5, #0]
 8002cee:	2b05      	cmp	r3, #5
 8002cf0:	d073      	beq.n	8002dda <Vector70+0x24a>
 8002cf2:	2300      	movs	r3, #0
 8002cf4:	612b      	str	r3, [r5, #16]
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002cf6:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002cf8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002cfa:	2b00      	cmp	r3, #0
 8002cfc:	ddb4      	ble.n	8002c68 <Vector70+0xd8>
 8002cfe:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8002d00:	2b00      	cmp	r3, #0
 8002d02:	d1b1      	bne.n	8002c68 <Vector70+0xd8>
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8002d04:	2201      	movs	r2, #1
 8002d06:	6362      	str	r2, [r4, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8002d08:	696a      	ldr	r2, [r5, #20]
 8002d0a:	2a00      	cmp	r2, #0
 8002d0c:	d013      	beq.n	8002d36 <Vector70+0x1a6>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002d0e:	2120      	movs	r1, #32
 8002d10:	5c50      	ldrb	r0, [r2, r1]
 8002d12:	2803      	cmp	r0, #3
 8002d14:	d14e      	bne.n	8002db4 <Vector70+0x224>

    *trp = NULL;
    tp->u.rdymsg = msg;
 8002d16:	2001      	movs	r0, #1
 8002d18:	4240      	negs	r0, r0
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8002d1a:	616b      	str	r3, [r5, #20]
    tp->u.rdymsg = msg;
 8002d1c:	6250      	str	r0, [r2, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002d1e:	5453      	strb	r3, [r2, r1]
  cp = (thread_t *)&ch.rlist.queue;
 8002d20:	1c23      	adds	r3, r4, #0
 8002d22:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8002d24:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8002d26:	6898      	ldr	r0, [r3, #8]
 8002d28:	4288      	cmp	r0, r1
 8002d2a:	d2fb      	bcs.n	8002d24 <Vector70+0x194>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8002d2c:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8002d2e:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8002d30:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8002d32:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8002d34:	605a      	str	r2, [r3, #4]
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8002d36:	2300      	movs	r3, #0
 8002d38:	6363      	str	r3, [r4, #52]	; 0x34
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002d3a:	b662      	cpsie	i
 8002d3c:	e760      	b.n	8002c00 <Vector70+0x70>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002d3e:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002d40:	2007      	movs	r0, #7
 8002d42:	2203      	movs	r2, #3
 8002d44:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002d46:	780b      	ldrb	r3, [r1, #0]
 8002d48:	4383      	bics	r3, r0
 8002d4a:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002d4c:	4003      	ands	r3, r0
 8002d4e:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002d50:	4b24      	ldr	r3, [pc, #144]	; (8002de4 <Vector70+0x254>)
 8002d52:	608b      	str	r3, [r1, #8]
    trace_next();
 8002d54:	f7fe f9f4 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002d58:	b662      	cpsie	i
 8002d5a:	e78e      	b.n	8002c7a <Vector70+0xea>

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8002d5c:	4a27      	ldr	r2, [pc, #156]	; (8002dfc <Vector70+0x26c>)
 8002d5e:	619a      	str	r2, [r3, #24]
 8002d60:	e79e      	b.n	8002ca0 <Vector70+0x110>
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8002d62:	2310      	movs	r3, #16
 8002d64:	6891      	ldr	r1, [r2, #8]
 8002d66:	430b      	orrs	r3, r1
    while (adc->CR & ADC_CR_ADSTP)
 8002d68:	2110      	movs	r1, #16
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8002d6a:	6093      	str	r3, [r2, #8]
    while (adc->CR & ADC_CR_ADSTP)
 8002d6c:	6893      	ldr	r3, [r2, #8]
 8002d6e:	4219      	tst	r1, r3
 8002d70:	d1fc      	bne.n	8002d6c <Vector70+0x1dc>
 8002d72:	e761      	b.n	8002c38 <Vector70+0xa8>
void _dbg_check_lock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#6");
  }
  _dbg_enter_lock();
 8002d74:	2201      	movs	r2, #1
 8002d76:	6362      	str	r2, [r4, #52]	; 0x34
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8002d78:	696a      	ldr	r2, [r5, #20]
 8002d7a:	2a00      	cmp	r2, #0
 8002d7c:	d012      	beq.n	8002da4 <Vector70+0x214>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002d7e:	2120      	movs	r1, #32
 8002d80:	5c50      	ldrb	r0, [r2, r1]
 8002d82:	2803      	cmp	r0, #3
 8002d84:	d116      	bne.n	8002db4 <Vector70+0x224>

    *trp = NULL;
    tp->u.rdymsg = msg;
 8002d86:	3804      	subs	r0, #4
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8002d88:	616b      	str	r3, [r5, #20]
    tp->u.rdymsg = msg;
 8002d8a:	6250      	str	r0, [r2, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8002d8c:	5453      	strb	r3, [r2, r1]
  cp = (thread_t *)&ch.rlist.queue;
 8002d8e:	1c23      	adds	r3, r4, #0
 8002d90:	6891      	ldr	r1, [r2, #8]
  do {
    cp = cp->queue.next;
 8002d92:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8002d94:	6898      	ldr	r0, [r3, #8]
 8002d96:	4288      	cmp	r0, r1
 8002d98:	d2fb      	bcs.n	8002d92 <Vector70+0x202>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8002d9a:	6859      	ldr	r1, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8002d9c:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
 8002d9e:	6051      	str	r1, [r2, #4]
  tp->queue.prev->queue.next = tp;
 8002da0:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8002da2:	605a      	str	r2, [r3, #4]
void _dbg_check_unlock_from_isr(void) {

  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#7");
  }
  _dbg_leave_lock();
 8002da4:	2300      	movs	r3, #0
 8002da6:	6363      	str	r3, [r4, #52]	; 0x34
 8002da8:	b662      	cpsie	i
 8002daa:	e72b      	b.n	8002c04 <Vector70+0x74>
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
    }
    if (isr & ADC_ISR_AWD) {
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD);
 8002dac:	2202      	movs	r2, #2
 8002dae:	612b      	str	r3, [r5, #16]
 8002db0:	702a      	strb	r2, [r5, #0]
 8002db2:	e751      	b.n	8002c58 <Vector70+0xc8>
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8002db4:	4812      	ldr	r0, [pc, #72]	; (8002e00 <Vector70+0x270>)
 8002db6:	f7fe f9db 	bl	8001170 <chSysHalt>
 8002dba:	3b03      	subs	r3, #3
 8002dbc:	702b      	strb	r3, [r5, #0]
 8002dbe:	e749      	b.n	8002c54 <Vector70+0xc4>
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8002dc0:	4651      	mov	r1, sl
 8002dc2:	6898      	ldr	r0, [r3, #8]
 8002dc4:	4301      	orrs	r1, r0
    while (adc->CR & ADC_CR_ADSTP)
 8002dc6:	2010      	movs	r0, #16
 * @param[in] adc       pointer to the ADC registers block
 */
static void adc_lld_stop_adc(ADC_TypeDef *adc) {

  if (adc->CR & ADC_CR_ADSTART) {
    adc->CR |= ADC_CR_ADSTP;
 8002dc8:	6099      	str	r1, [r3, #8]
    while (adc->CR & ADC_CR_ADSTP)
 8002dca:	6899      	ldr	r1, [r3, #8]
 8002dcc:	4208      	tst	r0, r1
 8002dce:	d1fc      	bne.n	8002dca <Vector70+0x23a>
 8002dd0:	e784      	b.n	8002cdc <Vector70+0x14c>
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
 8002dd2:	2202      	movs	r2, #2
 8002dd4:	612b      	str	r3, [r5, #16]
 8002dd6:	702a      	strb	r2, [r5, #0]
 8002dd8:	e78d      	b.n	8002cf6 <Vector70+0x166>
 8002dda:	3b03      	subs	r3, #3
 8002ddc:	702b      	strb	r3, [r5, #0]
 8002dde:	e788      	b.n	8002cf2 <Vector70+0x162>
 8002de0:	20000700 	.word	0x20000700
 8002de4:	080038c0 	.word	0x080038c0
 8002de8:	0800382c 	.word	0x0800382c
 8002dec:	20000578 	.word	0x20000578
 8002df0:	08003834 	.word	0x08003834
 8002df4:	080037e0 	.word	0x080037e0
 8002df8:	080001d4 	.word	0x080001d4
 8002dfc:	080001c9 	.word	0x080001c9
 8002e00:	0800384c 	.word	0x0800384c
	...

08002e10 <Vector6C>:
/**
 * @brief   DMA1 streams 4, 5, 6 and 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4567_HANDLER) {
 8002e10:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002e12:	4c3b      	ldr	r4, [pc, #236]	; (8002f00 <Vector6C+0xf0>)

  OSAL_IRQ_PROLOGUE();
 8002e14:	4675      	mov	r5, lr
 8002e16:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8002e18:	079b      	lsls	r3, r3, #30
 8002e1a:	d40d      	bmi.n	8002e38 <Vector6C+0x28>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002e1c:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002e1e:	2007      	movs	r0, #7
 8002e20:	2202      	movs	r2, #2
 8002e22:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002e24:	780b      	ldrb	r3, [r1, #0]
 8002e26:	4383      	bics	r3, r0
 8002e28:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002e2a:	4003      	ands	r3, r0
 8002e2c:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002e2e:	4b35      	ldr	r3, [pc, #212]	; (8002f04 <Vector6C+0xf4>)
 8002e30:	608b      	str	r3, [r1, #8]
    trace_next();
 8002e32:	f7fe f985 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002e36:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002e38:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002e3a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e3c:	2b00      	cmp	r3, #0
 8002e3e:	db02      	blt.n	8002e46 <Vector6C+0x36>
 8002e40:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002e42:	2a00      	cmp	r2, #0
 8002e44:	d002      	beq.n	8002e4c <Vector6C+0x3c>
    chSysHalt("SV#8");
 8002e46:	4830      	ldr	r0, [pc, #192]	; (8002f08 <Vector6C+0xf8>)
 8002e48:	f7fe f992 	bl	8001170 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8002e4c:	3301      	adds	r3, #1
 8002e4e:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002e50:	b662      	cpsie	i
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t idx = (dmastp)->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8002e52:	220e      	movs	r2, #14
 8002e54:	4b2d      	ldr	r3, [pc, #180]	; (8002f0c <Vector6C+0xfc>)
 8002e56:	6819      	ldr	r1, [r3, #0]
 8002e58:	0b09      	lsrs	r1, r1, #12
 8002e5a:	4011      	ands	r1, r2
  if (flags & dmastp->channel->CCR) {
 8002e5c:	4a2c      	ldr	r2, [pc, #176]	; (8002f10 <Vector6C+0x100>)
 8002e5e:	6812      	ldr	r2, [r2, #0]
 8002e60:	420a      	tst	r2, r1
 8002e62:	d007      	beq.n	8002e74 <Vector6C+0x64>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8002e64:	030a      	lsls	r2, r1, #12
 8002e66:	605a      	str	r2, [r3, #4]
    if (dma.streams[idx].func) {
 8002e68:	4a2a      	ldr	r2, [pc, #168]	; (8002f14 <Vector6C+0x104>)
 8002e6a:	6a13      	ldr	r3, [r2, #32]
 8002e6c:	2b00      	cmp	r3, #0
 8002e6e:	d001      	beq.n	8002e74 <Vector6C+0x64>
      dma.streams[idx].func(dma.streams[idx].param, flags);
 8002e70:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8002e72:	4798      	blx	r3
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t idx = (dmastp)->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8002e74:	220e      	movs	r2, #14
 8002e76:	4b25      	ldr	r3, [pc, #148]	; (8002f0c <Vector6C+0xfc>)
 8002e78:	6819      	ldr	r1, [r3, #0]
 8002e7a:	0c09      	lsrs	r1, r1, #16
 8002e7c:	4011      	ands	r1, r2
  if (flags & dmastp->channel->CCR) {
 8002e7e:	4a26      	ldr	r2, [pc, #152]	; (8002f18 <Vector6C+0x108>)
 8002e80:	6812      	ldr	r2, [r2, #0]
 8002e82:	420a      	tst	r2, r1
 8002e84:	d007      	beq.n	8002e96 <Vector6C+0x86>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8002e86:	040a      	lsls	r2, r1, #16
 8002e88:	605a      	str	r2, [r3, #4]
    if (dma.streams[idx].func) {
 8002e8a:	4a22      	ldr	r2, [pc, #136]	; (8002f14 <Vector6C+0x104>)
 8002e8c:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8002e8e:	2b00      	cmp	r3, #0
 8002e90:	d001      	beq.n	8002e96 <Vector6C+0x86>
      dma.streams[idx].func(dma.streams[idx].param, flags);
 8002e92:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8002e94:	4798      	blx	r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002e96:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002e98:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002e9a:	2b00      	cmp	r3, #0
 8002e9c:	dd02      	ble.n	8002ea4 <Vector6C+0x94>
 8002e9e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002ea0:	2a00      	cmp	r2, #0
 8002ea2:	d002      	beq.n	8002eaa <Vector6C+0x9a>
    chSysHalt("SV#9");
 8002ea4:	481d      	ldr	r0, [pc, #116]	; (8002f1c <Vector6C+0x10c>)
 8002ea6:	f7fe f963 	bl	8001170 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 8002eaa:	3b01      	subs	r3, #1
 8002eac:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002eae:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002eb0:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8002eb2:	079b      	lsls	r3, r3, #30
 8002eb4:	d40d      	bmi.n	8002ed2 <Vector6C+0xc2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002eb6:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002eb8:	2007      	movs	r0, #7
 8002eba:	2203      	movs	r2, #3
 8002ebc:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002ebe:	780b      	ldrb	r3, [r1, #0]
 8002ec0:	4383      	bics	r3, r0
 8002ec2:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002ec4:	4003      	ands	r3, r0
 8002ec6:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002ec8:	4b0e      	ldr	r3, [pc, #56]	; (8002f04 <Vector6C+0xf4>)
 8002eca:	608b      	str	r3, [r1, #8]
    trace_next();
 8002ecc:	f7fe f938 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002ed0:	b662      	cpsie	i
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8002ed2:	350f      	adds	r5, #15
 8002ed4:	d010      	beq.n	8002ef8 <Vector6C+0xe8>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002ed6:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002ed8:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8002edc:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002ede:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8002ee2:	2280      	movs	r2, #128	; 0x80
 8002ee4:	0452      	lsls	r2, r2, #17
 8002ee6:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8002ee8:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 8002eea:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8002eec:	6889      	ldr	r1, [r1, #8]
 8002eee:	6892      	ldr	r2, [r2, #8]
 8002ef0:	4291      	cmp	r1, r2
 8002ef2:	d802      	bhi.n	8002efa <Vector6C+0xea>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8002ef4:	4a0a      	ldr	r2, [pc, #40]	; (8002f20 <Vector6C+0x110>)
 8002ef6:	619a      	str	r2, [r3, #24]
  /* Check on channel 7.*/
  dmaServeInterrupt(STM32_DMA1_STREAM7);
#endif

  OSAL_IRQ_EPILOGUE();
}
 8002ef8:	bd38      	pop	{r3, r4, r5, pc}

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8002efa:	4a0a      	ldr	r2, [pc, #40]	; (8002f24 <Vector6C+0x114>)
 8002efc:	619a      	str	r2, [r3, #24]
 8002efe:	e7fb      	b.n	8002ef8 <Vector6C+0xe8>
 8002f00:	20000700 	.word	0x20000700
 8002f04:	080038b4 	.word	0x080038b4
 8002f08:	0800382c 	.word	0x0800382c
 8002f0c:	40020000 	.word	0x40020000
 8002f10:	40020044 	.word	0x40020044
 8002f14:	2000046c 	.word	0x2000046c
 8002f18:	40020058 	.word	0x40020058
 8002f1c:	08003834 	.word	0x08003834
 8002f20:	080001d4 	.word	0x080001d4
 8002f24:	080001c9 	.word	0x080001c9
	...

08002f30 <Vector68>:
 * @note    It is declared here because this device has a non-standard
 *          DMA shared IRQ handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH23_HANDLER) {
 8002f30:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
void _trace_isr_enter(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002f32:	4c3b      	ldr	r4, [pc, #236]	; (8003020 <Vector68+0xf0>)

  OSAL_IRQ_PROLOGUE();
 8002f34:	4675      	mov	r5, lr
 8002f36:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8002f38:	079b      	lsls	r3, r3, #30
 8002f3a:	d40d      	bmi.n	8002f58 <Vector68+0x28>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002f3c:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002f3e:	2007      	movs	r0, #7
 8002f40:	2202      	movs	r2, #2
 8002f42:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002f44:	780b      	ldrb	r3, [r1, #0]
 8002f46:	4383      	bics	r3, r0
 8002f48:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002f4a:	4003      	ands	r3, r0
 8002f4c:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002f4e:	4b35      	ldr	r3, [pc, #212]	; (8003024 <Vector68+0xf4>)
 8002f50:	608b      	str	r3, [r1, #8]
    trace_next();
 8002f52:	f7fe f8f5 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002f56:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002f58:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002f5a:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002f5c:	2b00      	cmp	r3, #0
 8002f5e:	db02      	blt.n	8002f66 <Vector68+0x36>
 8002f60:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002f62:	2a00      	cmp	r2, #0
 8002f64:	d002      	beq.n	8002f6c <Vector68+0x3c>
    chSysHalt("SV#8");
 8002f66:	4830      	ldr	r0, [pc, #192]	; (8003028 <Vector68+0xf8>)
 8002f68:	f7fe f902 	bl	8001170 <chSysHalt>
  }
  ch.dbg.isr_cnt++;
 8002f6c:	3301      	adds	r3, #1
 8002f6e:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002f70:	b662      	cpsie	i
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t idx = (dmastp)->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8002f72:	220e      	movs	r2, #14
 8002f74:	4b2d      	ldr	r3, [pc, #180]	; (800302c <Vector68+0xfc>)
 8002f76:	6819      	ldr	r1, [r3, #0]
 8002f78:	0909      	lsrs	r1, r1, #4
 8002f7a:	4011      	ands	r1, r2
  if (flags & dmastp->channel->CCR) {
 8002f7c:	4a2c      	ldr	r2, [pc, #176]	; (8003030 <Vector68+0x100>)
 8002f7e:	6812      	ldr	r2, [r2, #0]
 8002f80:	420a      	tst	r2, r1
 8002f82:	d007      	beq.n	8002f94 <Vector68+0x64>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8002f84:	010a      	lsls	r2, r1, #4
 8002f86:	605a      	str	r2, [r3, #4]
    if (dma.streams[idx].func) {
 8002f88:	4a2a      	ldr	r2, [pc, #168]	; (8003034 <Vector68+0x104>)
 8002f8a:	6913      	ldr	r3, [r2, #16]
 8002f8c:	2b00      	cmp	r3, #0
 8002f8e:	d001      	beq.n	8002f94 <Vector68+0x64>
      dma.streams[idx].func(dma.streams[idx].param, flags);
 8002f90:	6950      	ldr	r0, [r2, #20]
 8002f92:	4798      	blx	r3
 */
void dmaServeInterrupt(const stm32_dma_stream_t *dmastp) {
  uint32_t flags;
  uint32_t idx = (dmastp)->selfindex;

  flags = (dmastp->dma->ISR >> dmastp->shift) & STM32_DMA_ISR_MASK;
 8002f94:	220e      	movs	r2, #14
 8002f96:	4b25      	ldr	r3, [pc, #148]	; (800302c <Vector68+0xfc>)
 8002f98:	6819      	ldr	r1, [r3, #0]
 8002f9a:	0a09      	lsrs	r1, r1, #8
 8002f9c:	4011      	ands	r1, r2
  if (flags & dmastp->channel->CCR) {
 8002f9e:	4a26      	ldr	r2, [pc, #152]	; (8003038 <Vector68+0x108>)
 8002fa0:	6812      	ldr	r2, [r2, #0]
 8002fa2:	420a      	tst	r2, r1
 8002fa4:	d007      	beq.n	8002fb6 <Vector68+0x86>
    dmastp->dma->IFCR = flags << dmastp->shift;
 8002fa6:	020a      	lsls	r2, r1, #8
 8002fa8:	605a      	str	r2, [r3, #4]
    if (dma.streams[idx].func) {
 8002faa:	4a22      	ldr	r2, [pc, #136]	; (8003034 <Vector68+0x104>)
 8002fac:	6993      	ldr	r3, [r2, #24]
 8002fae:	2b00      	cmp	r3, #0
 8002fb0:	d001      	beq.n	8002fb6 <Vector68+0x86>
      dma.streams[idx].func(dma.streams[idx].param, flags);
 8002fb2:	69d0      	ldr	r0, [r2, #28]
 8002fb4:	4798      	blx	r3
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002fb6:	b672      	cpsid	i
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002fb8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8002fba:	2b00      	cmp	r3, #0
 8002fbc:	dd02      	ble.n	8002fc4 <Vector68+0x94>
 8002fbe:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8002fc0:	2a00      	cmp	r2, #0
 8002fc2:	d002      	beq.n	8002fca <Vector68+0x9a>
    chSysHalt("SV#9");
 8002fc4:	481d      	ldr	r0, [pc, #116]	; (800303c <Vector68+0x10c>)
 8002fc6:	f7fe f8d3 	bl	8001170 <chSysHalt>
  }
  ch.dbg.isr_cnt--;
 8002fca:	3b01      	subs	r3, #1
 8002fcc:	6323      	str	r3, [r4, #48]	; 0x30
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002fce:	b662      	cpsie	i
 *
 * @notapi
 */
void _trace_isr_leave(const char *isr) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002fd0:	8f23      	ldrh	r3, [r4, #56]	; 0x38
 8002fd2:	079b      	lsls	r3, r3, #30
 8002fd4:	d40d      	bmi.n	8002ff2 <Vector68+0xc2>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002fd6:	b672      	cpsid	i
    port_lock_from_isr();
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002fd8:	2007      	movs	r0, #7
 8002fda:	2203      	movs	r2, #3
 8002fdc:	6be1      	ldr	r1, [r4, #60]	; 0x3c
 8002fde:	780b      	ldrb	r3, [r1, #0]
 8002fe0:	4383      	bics	r3, r0
 8002fe2:	4313      	orrs	r3, r2
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8002fe4:	4003      	ands	r3, r0
 8002fe6:	700b      	strb	r3, [r1, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8002fe8:	4b0e      	ldr	r3, [pc, #56]	; (8003024 <Vector68+0xf4>)
 8002fea:	608b      	str	r3, [r1, #8]
    trace_next();
 8002fec:	f7fe f8a8 	bl	8001140 <trace_next.lto_priv.45>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002ff0:	b662      	cpsie	i
 *
 * @param[in] lr        value of the @p LR register on ISR entry
 */
void _port_irq_epilogue(regarm_t lr) {

  if (lr != (regarm_t)0xFFFFFFF1U) {
 8002ff2:	350f      	adds	r5, #15
 8002ff4:	d010      	beq.n	8003018 <Vector68+0xe8>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002ff6:	b672      	cpsid	i
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8002ff8:	f3ef 8309 	mrs	r3, PSP
    /* The extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8002ffc:	3b20      	subs	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002ffe:	f383 8809 	msr	PSP, r3

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8003002:	2280      	movs	r2, #128	; 0x80
 8003004:	0452      	lsls	r2, r2, #17
 8003006:	61da      	str	r2, [r3, #28]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8003008:	6821      	ldr	r1, [r4, #0]
  tprio_t p2 = currp->prio;
 800300a:	69a2      	ldr	r2, [r4, #24]

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800300c:	6889      	ldr	r1, [r1, #8]
 800300e:	6892      	ldr	r2, [r2, #8]
 8003010:	4291      	cmp	r1, r2
 8003012:	d802      	bhi.n	800301a <Vector68+0xea>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8003014:	4a0a      	ldr	r2, [pc, #40]	; (8003040 <Vector68+0x110>)
 8003016:	619a      	str	r2, [r3, #24]

  /* Check on channel 3.*/
  dmaServeInterrupt(STM32_DMA1_STREAM3);

  OSAL_IRQ_EPILOGUE();
}
 8003018:	bd38      	pop	{r3, r4, r5, pc}

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 800301a:	4a0a      	ldr	r2, [pc, #40]	; (8003044 <Vector68+0x114>)
 800301c:	619a      	str	r2, [r3, #24]
 800301e:	e7fb      	b.n	8003018 <Vector68+0xe8>
 8003020:	20000700 	.word	0x20000700
 8003024:	0800394c 	.word	0x0800394c
 8003028:	0800382c 	.word	0x0800382c
 800302c:	40020000 	.word	0x40020000
 8003030:	4002001c 	.word	0x4002001c
 8003034:	2000046c 	.word	0x2000046c
 8003038:	40020030 	.word	0x40020030
 800303c:	08003834 	.word	0x08003834
 8003040:	080001d4 	.word	0x080001d4
 8003044:	080001c9 	.word	0x080001c9
	...

08003050 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8003050:	b570      	push	{r4, r5, r6, lr}
 8003052:	4b10      	ldr	r3, [pc, #64]	; (8003094 <nvicEnableVector+0x44>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8003054:	2403      	movs	r4, #3
 8003056:	469c      	mov	ip, r3
 8003058:	23ff      	movs	r3, #255	; 0xff
 800305a:	26c0      	movs	r6, #192	; 0xc0
 800305c:	4004      	ands	r4, r0
 800305e:	00e4      	lsls	r4, r4, #3
 8003060:	40a3      	lsls	r3, r4
 8003062:	0882      	lsrs	r2, r0, #2
 8003064:	0092      	lsls	r2, r2, #2
 8003066:	4462      	add	r2, ip
 8003068:	00b6      	lsls	r6, r6, #2
 800306a:	5995      	ldr	r5, [r2, r6]
 800306c:	439d      	bics	r5, r3
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
 800306e:	018b      	lsls	r3, r1, #6
 8003070:	40a3      	lsls	r3, r4
 8003072:	1c19      	adds	r1, r3, #0
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003074:	231f      	movs	r3, #31
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
 8003076:	4329      	orrs	r1, r5
 8003078:	5191      	str	r1, [r2, r6]
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800307a:	2201      	movs	r2, #1
 800307c:	4003      	ands	r3, r0
 800307e:	409a      	lsls	r2, r3
 8003080:	1c13      	adds	r3, r2, #0
 8003082:	22c0      	movs	r2, #192	; 0xc0
 8003084:	0940      	lsrs	r0, r0, #5
 8003086:	0080      	lsls	r0, r0, #2
 8003088:	4460      	add	r0, ip
 800308a:	0052      	lsls	r2, r2, #1
 800308c:	5083      	str	r3, [r0, r2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800308e:	6003      	str	r3, [r0, #0]
}
 8003090:	bd70      	pop	{r4, r5, r6, pc}
 8003092:	46c0      	nop			; (mov r8, r8)
 8003094:	e000e100 	.word	0xe000e100
	...

080030a0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80030a0:	b570      	push	{r4, r5, r6, lr}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80030a2:	4d11      	ldr	r5, [pc, #68]	; (80030e8 <__init_ram_areas+0x48>)
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80030a4:	1c2e      	adds	r6, r5, #0
 80030a6:	3680      	adds	r6, #128	; 0x80
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;
 80030a8:	6868      	ldr	r0, [r5, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80030aa:	68ac      	ldr	r4, [r5, #8]
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 80030ac:	682a      	ldr	r2, [r5, #0]
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80030ae:	42a0      	cmp	r0, r4
 80030b0:	d20a      	bcs.n	80030c8 <__init_ram_areas+0x28>
 80030b2:	1c03      	adds	r3, r0, #0
      *p = *tp;
 80030b4:	ca02      	ldmia	r2!, {r1}
 80030b6:	c302      	stmia	r3!, {r1}
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80030b8:	42a3      	cmp	r3, r4
 80030ba:	d3fb      	bcc.n	80030b4 <__init_ram_areas+0x14>
 80030bc:	43c3      	mvns	r3, r0
 80030be:	191c      	adds	r4, r3, r4
 80030c0:	08a4      	lsrs	r4, r4, #2
 80030c2:	3401      	adds	r4, #1
 80030c4:	00a4      	lsls	r4, r4, #2
 80030c6:	1900      	adds	r0, r0, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80030c8:	68eb      	ldr	r3, [r5, #12]
 80030ca:	4298      	cmp	r0, r3
 80030cc:	d207      	bcs.n	80030de <__init_ram_areas+0x3e>
      *p = 0;
 80030ce:	43c2      	mvns	r2, r0
 80030d0:	18d2      	adds	r2, r2, r3
 80030d2:	0892      	lsrs	r2, r2, #2
 80030d4:	3201      	adds	r2, #1
 80030d6:	0092      	lsls	r2, r2, #2
 80030d8:	2100      	movs	r1, #0
 80030da:	f000 fa4f 	bl	800357c <memset>
      p++;
    }
    rap++;
 80030de:	3510      	adds	r5, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80030e0:	42b5      	cmp	r5, r6
 80030e2:	d3e1      	bcc.n	80030a8 <__init_ram_areas+0x8>
#endif
}
 80030e4:	bd70      	pop	{r4, r5, r6, pc}
 80030e6:	46c0      	nop			; (mov r8, r8)
 80030e8:	080038cc 	.word	0x080038cc
 80030ec:	00000000 	.word	0x00000000

080030f0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80030f0:	e7fe      	b.n	80030f0 <__default_exit>
 80030f2:	46c0      	nop			; (mov r8, r8)
	...

08003100 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8003100:	4770      	bx	lr
 8003102:	46c0      	nop			; (mov r8, r8)
	...

08003110 <__core_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8003110:	4770      	bx	lr
 8003112:	46c0      	nop			; (mov r8, r8)
	...

08003120 <i2cMasterTransmitTimeout.constprop.28>:
 *                      be retrieved using @p i2cGetErrors().
 * @retval MSG_TIMEOUT  if a timeout occurred before operation end.
 *
 * @api
 */
msg_t i2cMasterTransmitTimeout(I2CDriver *i2cp,
 8003120:	b5f0      	push	{r4, r5, r6, r7, lr}
 8003122:	4657      	mov	r7, sl
 8003124:	464e      	mov	r6, r9
 8003126:	4645      	mov	r5, r8
 8003128:	b4e0      	push	{r5, r6, r7}
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               sysinterval_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) &&
 800312a:	2900      	cmp	r1, #0
 800312c:	d009      	beq.n	8003142 <i2cMasterTransmitTimeout.constprop.28+0x22>
 800312e:	2800      	cmp	r0, #0
 8003130:	d007      	beq.n	8003142 <i2cMasterTransmitTimeout.constprop.28+0x22>
 8003132:	2b00      	cmp	r3, #0
 8003134:	d001      	beq.n	800313a <i2cMasterTransmitTimeout.constprop.28+0x1a>
 8003136:	2a00      	cmp	r2, #0
 8003138:	d003      	beq.n	8003142 <i2cMasterTransmitTimeout.constprop.28+0x22>
               (txbytes > 0U) && (txbuf != NULL) &&
               ((rxbytes == 0U) || ((rxbytes > 0U) && (rxbuf != NULL))) &&
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");
 800313a:	4c6b      	ldr	r4, [pc, #428]	; (80032e8 <i2cMasterTransmitTimeout.constprop.28+0x1c8>)
 800313c:	7825      	ldrb	r5, [r4, #0]
 800313e:	2d02      	cmp	r5, #2
 8003140:	d002      	beq.n	8003148 <i2cMasterTransmitTimeout.constprop.28+0x28>
                               uint8_t *rxbuf,
                               size_t rxbytes,
                               sysinterval_t timeout) {
  msg_t rdymsg;

  osalDbgCheck((i2cp != NULL) &&
 8003142:	486a      	ldr	r0, [pc, #424]	; (80032ec <i2cMasterTransmitTimeout.constprop.28+0x1cc>)
 8003144:	f7fe f814 	bl	8001170 <chSysHalt>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003148:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 800314a:	4d69      	ldr	r5, [pc, #420]	; (80032f0 <i2cMasterTransmitTimeout.constprop.28+0x1d0>)
 800314c:	6b2e      	ldr	r6, [r5, #48]	; 0x30
 800314e:	2e00      	cmp	r6, #0
 8003150:	d102      	bne.n	8003158 <i2cMasterTransmitTimeout.constprop.28+0x38>
 8003152:	6b6f      	ldr	r7, [r5, #52]	; 0x34
 8003154:	2f00      	cmp	r7, #0
 8003156:	d002      	beq.n	800315e <i2cMasterTransmitTimeout.constprop.28+0x3e>
    chSysHalt("SV#4");
 8003158:	4866      	ldr	r0, [pc, #408]	; (80032f4 <i2cMasterTransmitTimeout.constprop.28+0x1d4>)
 800315a:	f7fe f809 	bl	8001170 <chSysHalt>

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
  i2cp->state = I2C_ACTIVE_TX;
 800315e:	2603      	movs	r6, #3
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8003160:	60a7      	str	r7, [r4, #8]
  i2cp->state = I2C_ACTIVE_TX;
 8003162:	7026      	strb	r6, [r4, #0]
 8003164:	682f      	ldr	r7, [r5, #0]
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      sysinterval_t timeout) {
  msg_t msg;
  I2C_TypeDef *dp = i2cp->i2c;
 8003166:	6b26      	ldr	r6, [r4, #48]	; 0x30
 8003168:	46b2      	mov	sl, r6
 800316a:	42af      	cmp	r7, r5
 800316c:	d004      	beq.n	8003178 <i2cMasterTransmitTimeout.constprop.28+0x58>
 800316e:	69ae      	ldr	r6, [r5, #24]
 8003170:	68bf      	ldr	r7, [r7, #8]
 8003172:	68b6      	ldr	r6, [r6, #8]
 8003174:	42be      	cmp	r6, r7
 8003176:	d35f      	bcc.n	8003238 <i2cMasterTransmitTimeout.constprop.28+0x118>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8003178:	b662      	cpsie	i
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

#if STM32_I2C_USE_DMA == TRUE
  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 800317a:	6ae7      	ldr	r7, [r4, #44]	; 0x2c
 800317c:	6a66      	ldr	r6, [r4, #36]	; 0x24
 800317e:	687f      	ldr	r7, [r7, #4]
 8003180:	603e      	str	r6, [r7, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 8003182:	60f8      	str	r0, [r7, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8003184:	6079      	str	r1, [r7, #4]

  /* RX DMA setup, note, rxbytes can be zero but we write the value anyway.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8003186:	6aa1      	ldr	r1, [r4, #40]	; 0x28
 8003188:	6a20      	ldr	r0, [r4, #32]
 800318a:	6849      	ldr	r1, [r1, #4]
 800318c:	6008      	str	r0, [r1, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 800318e:	60ca      	str	r2, [r1, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8003190:	604b      	str	r3, [r1, #4]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003192:	4b59      	ldr	r3, [pc, #356]	; (80032f8 <i2cMasterTransmitTimeout.constprop.28+0x1d8>)
 8003194:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8003196:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8003198:	6b29      	ldr	r1, [r5, #48]	; 0x30
 800319a:	2900      	cmp	r1, #0
 800319c:	d1dc      	bne.n	8003158 <i2cMasterTransmitTimeout.constprop.28+0x38>
 800319e:	6b69      	ldr	r1, [r5, #52]	; 0x34
 80031a0:	2900      	cmp	r1, #0
 80031a2:	d1d9      	bne.n	8003158 <i2cMasterTransmitTimeout.constprop.28+0x38>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80031a4:	3101      	adds	r1, #1
 80031a6:	6369      	str	r1, [r5, #52]	; 0x34
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 80031a8:	4651      	mov	r1, sl
 80031aa:	2780      	movs	r7, #128	; 0x80
 80031ac:	6989      	ldr	r1, [r1, #24]
 80031ae:	023f      	lsls	r7, r7, #8
 80031b0:	4239      	tst	r1, r7
 80031b2:	d044      	beq.n	800323e <i2cMasterTransmitTimeout.constprop.28+0x11e>
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end)) {
 80031b4:	20f4      	movs	r0, #244	; 0xf4
 80031b6:	b291      	uxth	r1, r2
 80031b8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80031ba:	30ff      	adds	r0, #255	; 0xff
 */
static inline bool chTimeIsInRangeX(systime_t time,
                                    systime_t start,
                                    systime_t end) {

  return (bool)((systime_t)((systime_t)time - (systime_t)start) <
 80031bc:	1a52      	subs	r2, r2, r1
 80031be:	b292      	uxth	r2, r2
 80031c0:	4282      	cmp	r2, r0
 80031c2:	d820      	bhi.n	8003206 <i2cMasterTransmitTimeout.constprop.28+0xe6>
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80031c4:	2200      	movs	r2, #0
 80031c6:	4694      	mov	ip, r2
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80031c8:	3201      	adds	r2, #1
 80031ca:	4690      	mov	r8, r2
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 80031cc:	4662      	mov	r2, ip
 80031ce:	636a      	str	r2, [r5, #52]	; 0x34
 80031d0:	682a      	ldr	r2, [r5, #0]
 80031d2:	42aa      	cmp	r2, r5
 80031d4:	d004      	beq.n	80031e0 <i2cMasterTransmitTimeout.constprop.28+0xc0>
 80031d6:	69ae      	ldr	r6, [r5, #24]
 80031d8:	6892      	ldr	r2, [r2, #8]
 80031da:	68b6      	ldr	r6, [r6, #8]
 80031dc:	4296      	cmp	r6, r2
 80031de:	d32b      	bcc.n	8003238 <i2cMasterTransmitTimeout.constprop.28+0x118>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80031e0:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80031e2:	b672      	cpsid	i
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80031e4:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 80031e6:	2a00      	cmp	r2, #0
 80031e8:	d1b6      	bne.n	8003158 <i2cMasterTransmitTimeout.constprop.28+0x38>
 80031ea:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 80031ec:	2a00      	cmp	r2, #0
 80031ee:	d1b3      	bne.n	8003158 <i2cMasterTransmitTimeout.constprop.28+0x38>
    chSysHalt("SV#4");
  }
  _dbg_enter_lock();
 80031f0:	4642      	mov	r2, r8
 80031f2:	636a      	str	r2, [r5, #52]	; 0x34
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 80031f4:	4652      	mov	r2, sl
 80031f6:	6992      	ldr	r2, [r2, #24]
 80031f8:	423a      	tst	r2, r7
 80031fa:	d020      	beq.n	800323e <i2cMasterTransmitTimeout.constprop.28+0x11e>
 80031fc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80031fe:	1a52      	subs	r2, r2, r1
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalTimeIsInRangeX(osalOsGetSystemTimeX(), start, end)) {
 8003200:	b292      	uxth	r2, r2
 8003202:	4282      	cmp	r2, r0
 8003204:	d9e2      	bls.n	80031cc <i2cMasterTransmitTimeout.constprop.28+0xac>
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 8003206:	2305      	movs	r3, #5
 8003208:	2001      	movs	r0, #1
 800320a:	7023      	strb	r3, [r4, #0]
 800320c:	4240      	negs	r0, r0
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 800320e:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8003210:	2b00      	cmp	r3, #0
 8003212:	d146      	bne.n	80032a2 <i2cMasterTransmitTimeout.constprop.28+0x182>
 8003214:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8003216:	2a00      	cmp	r2, #0
 8003218:	dd43      	ble.n	80032a2 <i2cMasterTransmitTimeout.constprop.28+0x182>
    chSysHalt("SV#5");
  }
  _dbg_leave_lock();
 800321a:	636b      	str	r3, [r5, #52]	; 0x34
 800321c:	682b      	ldr	r3, [r5, #0]
 800321e:	42ab      	cmp	r3, r5
 8003220:	d004      	beq.n	800322c <i2cMasterTransmitTimeout.constprop.28+0x10c>
 8003222:	69aa      	ldr	r2, [r5, #24]
 8003224:	689b      	ldr	r3, [r3, #8]
 8003226:	6892      	ldr	r2, [r2, #8]
 8003228:	429a      	cmp	r2, r3
 800322a:	d352      	bcc.n	80032d2 <i2cMasterTransmitTimeout.constprop.28+0x1b2>
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800322c:	b662      	cpsie	i
  else {
    i2cp->state = I2C_READY;
  }
  osalSysUnlock();
  return rdymsg;
}
 800322e:	bc1c      	pop	{r2, r3, r4}
 8003230:	4690      	mov	r8, r2
 8003232:	4699      	mov	r9, r3
 8003234:	46a2      	mov	sl, r4
 8003236:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003238:	4830      	ldr	r0, [pc, #192]	; (80032fc <i2cMasterTransmitTimeout.constprop.28+0x1dc>)
 800323a:	f7fd ff99 	bl	8001170 <chSysHalt>
 */
static void i2c_lld_set_address(I2CDriver *i2cp, i2caddr_t addr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 800323e:	6863      	ldr	r3, [r4, #4]
 8003240:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8003242:	6898      	ldr	r0, [r3, #8]
 8003244:	0503      	lsls	r3, r0, #20
 8003246:	d441      	bmi.n	80032cc <i2cMasterTransmitTimeout.constprop.28+0x1ac>
    dp->CR2 = (uint32_t)addr << 1U;
 8003248:	2310      	movs	r3, #16
 800324a:	6053      	str	r3, [r2, #4]
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 800324c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800324e:	685f      	ldr	r7, [r3, #4]
 8003250:	687b      	ldr	r3, [r7, #4]
  if (n > 255U) {
 8003252:	2bff      	cmp	r3, #255	; 0xff
 8003254:	d835      	bhi.n	80032c2 <i2cMasterTransmitTimeout.constprop.28+0x1a2>
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 8003256:	2100      	movs	r1, #0
 8003258:	4689      	mov	r9, r1
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 800325a:	6856      	ldr	r6, [r2, #4]
            (n << 16U) | reload;
 800325c:	041b      	lsls	r3, r3, #16
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 800325e:	46b0      	mov	r8, r6
 8003260:	4e27      	ldr	r6, [pc, #156]	; (8003300 <i2cMasterTransmitTimeout.constprop.28+0x1e0>)
 8003262:	46b4      	mov	ip, r6
 8003264:	4646      	mov	r6, r8
 8003266:	4661      	mov	r1, ip
 8003268:	400e      	ands	r6, r1
 800326a:	4649      	mov	r1, r9
 800326c:	4330      	orrs	r0, r6
 800326e:	4301      	orrs	r1, r0
            (n << 16U) | reload;
 8003270:	430b      	orrs	r3, r1
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003272:	6053      	str	r3, [r2, #4]
  /* Preparing the transfer.*/
  i2c_lld_setup_tx_transfer(i2cp);

#if STM32_I2C_USE_DMA == TRUE
  /* Enabling TX DMA.*/
  dmaStreamEnable(i2cp->dmatx);
 8003274:	2201      	movs	r2, #1
 8003276:	683b      	ldr	r3, [r7, #0]
 8003278:	4313      	orrs	r3, r2
 800327a:	603b      	str	r3, [r7, #0]

  /* Transfer complete interrupt enabled.*/
  dp->CR1 |= I2C_CR1_TCIE;
 800327c:	4653      	mov	r3, sl
 800327e:	681b      	ldr	r3, [r3, #0]
 8003280:	323f      	adds	r2, #63	; 0x3f
 8003282:	4313      	orrs	r3, r2
 8003284:	4652      	mov	r2, sl
 8003286:	6013      	str	r3, [r2, #0]
  /* Transfer complete and TX interrupts enabled.*/
  dp->CR1 |= I2C_CR1_TCIE | I2C_CR1_TXIE;
#endif

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_START;
 8003288:	6853      	ldr	r3, [r2, #4]
 800328a:	2280      	movs	r2, #128	; 0x80
 800328c:	0192      	lsls	r2, r2, #6
 800328e:	4313      	orrs	r3, r2
 8003290:	4652      	mov	r2, sl
 8003292:	6053      	str	r3, [r2, #4]
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");
 8003294:	69e2      	ldr	r2, [r4, #28]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003296:	69ab      	ldr	r3, [r5, #24]
 8003298:	2a00      	cmp	r2, #0
 800329a:	d005      	beq.n	80032a8 <i2cMasterTransmitTimeout.constprop.28+0x188>
 800329c:	4819      	ldr	r0, [pc, #100]	; (8003304 <i2cMasterTransmitTimeout.constprop.28+0x1e4>)
 800329e:	f7fd ff67 	bl	8001170 <chSysHalt>
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
    chSysHalt("SV#5");
 80032a2:	4819      	ldr	r0, [pc, #100]	; (8003308 <i2cMasterTransmitTimeout.constprop.28+0x1e8>)
 80032a4:	f7fd ff64 	bl	8001170 <chSysHalt>
  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
  tp->u.wttrp = trp;
 80032a8:	1c22      	adds	r2, r4, #0
 80032aa:	321c      	adds	r2, #28

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 80032ac:	61e3      	str	r3, [r4, #28]
  tp->u.wttrp = trp;
 80032ae:	625a      	str	r2, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80032b0:	2003      	movs	r0, #3
 80032b2:	2128      	movs	r1, #40	; 0x28
 80032b4:	f7fe fa2c 	bl	8001710 <chSchGoSleepTimeoutS>
  /* Waits for the operation completion or a timeout.*/
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);

  /* In case of a software timeout a STOP is sent as an extreme attempt
     to release the bus.*/
  if (msg == MSG_TIMEOUT) {
 80032b8:	1c43      	adds	r3, r0, #1
 80032ba:	d00d      	beq.n	80032d8 <i2cMasterTransmitTimeout.constprop.28+0x1b8>
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
  }
  else {
    i2cp->state = I2C_READY;
 80032bc:	2302      	movs	r3, #2
 80032be:	7023      	strb	r3, [r4, #0]
 80032c0:	e7a5      	b.n	800320e <i2cMasterTransmitTimeout.constprop.28+0xee>

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
 80032c2:	2180      	movs	r1, #128	; 0x80
 80032c4:	0449      	lsls	r1, r1, #17
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
    n = 255U;
 80032c6:	23ff      	movs	r3, #255	; 0xff
    reload = I2C_CR2_RELOAD;
 80032c8:	4689      	mov	r9, r1
 80032ca:	e7c6      	b.n	800325a <i2cMasterTransmitTimeout.constprop.28+0x13a>

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
    dp->CR2 = (uint32_t)addr << 1U;
  else
    dp->CR2 = (uint32_t)addr;
 80032cc:	2308      	movs	r3, #8
 80032ce:	6053      	str	r3, [r2, #4]
 80032d0:	e7bc      	b.n	800324c <i2cMasterTransmitTimeout.constprop.28+0x12c>
 80032d2:	480e      	ldr	r0, [pc, #56]	; (800330c <i2cMasterTransmitTimeout.constprop.28+0x1ec>)
 80032d4:	f7fd ff4c 	bl	8001170 <chSysHalt>
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);

  /* In case of a software timeout a STOP is sent as an extreme attempt
     to release the bus.*/
  if (msg == MSG_TIMEOUT) {
    dp->CR2 |= I2C_CR2_STOP;
 80032d8:	4653      	mov	r3, sl
 80032da:	2280      	movs	r2, #128	; 0x80
 80032dc:	685b      	ldr	r3, [r3, #4]
 80032de:	01d2      	lsls	r2, r2, #7
 80032e0:	4313      	orrs	r3, r2
 80032e2:	4652      	mov	r2, sl
 80032e4:	6053      	str	r3, [r2, #4]
 80032e6:	e78e      	b.n	8003206 <i2cMasterTransmitTimeout.constprop.28+0xe6>
 80032e8:	20000f84 	.word	0x20000f84
 80032ec:	080039a8 	.word	0x080039a8
 80032f0:	20000700 	.word	0x20000700
 80032f4:	080036c8 	.word	0x080036c8
 80032f8:	40000400 	.word	0x40000400
 80032fc:	08003958 	.word	0x08003958
 8003300:	fe00ffff 	.word	0xfe00ffff
 8003304:	08003984 	.word	0x08003984
 8003308:	080036f0 	.word	0x080036f0
 800330c:	0800399c 	.word	0x0800399c

08003310 <chSchWakeupS.constprop.20>:
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 8003310:	4b35      	ldr	r3, [pc, #212]	; (80033e8 <chSchWakeupS.constprop.20+0xd8>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003312:	b570      	push	{r4, r5, r6, lr}
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8003314:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8003316:	1c04      	adds	r4, r0, #0
  thread_t *otp = currp;
 8003318:	699d      	ldr	r5, [r3, #24]
 800331a:	2a00      	cmp	r2, #0
 800331c:	d131      	bne.n	8003382 <chSchWakeupS.constprop.20+0x72>
 800331e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003320:	2a00      	cmp	r2, #0
 8003322:	dd2e      	ble.n	8003382 <chSchWakeupS.constprop.20+0x72>

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8003324:	681a      	ldr	r2, [r3, #0]
 8003326:	68a9      	ldr	r1, [r5, #8]
 8003328:	429a      	cmp	r2, r3
 800332a:	d002      	beq.n	8003332 <chSchWakeupS.constprop.20+0x22>
 800332c:	6892      	ldr	r2, [r2, #8]
 800332e:	4291      	cmp	r1, r2
 8003330:	d32d      	bcc.n	800338e <chSchWakeupS.constprop.20+0x7e>
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8003332:	2000      	movs	r0, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8003334:	68a2      	ldr	r2, [r4, #8]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8003336:	6260      	str	r0, [r4, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8003338:	4291      	cmp	r1, r2
 800333a:	d22b      	bcs.n	8003394 <chSchWakeupS.constprop.20+0x84>
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 800333c:	2620      	movs	r6, #32
 800333e:	5daa      	ldrb	r2, [r5, r6]
 8003340:	2a00      	cmp	r2, #0
 8003342:	d021      	beq.n	8003388 <chSchWakeupS.constprop.20+0x78>
 8003344:	2a0f      	cmp	r2, #15
 8003346:	d01f      	beq.n	8003388 <chSchWakeupS.constprop.20+0x78>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.queue;
 8003348:	1c1a      	adds	r2, r3, #0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800334a:	55a8      	strb	r0, [r5, r6]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 800334c:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio > tp->prio);
 800334e:	6890      	ldr	r0, [r2, #8]
 8003350:	4281      	cmp	r1, r0
 8003352:	d3fb      	bcc.n	800334c <chSchWakeupS.constprop.20+0x3c>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8003354:	6851      	ldr	r1, [r2, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8003356:	602a      	str	r2, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
 8003358:	6069      	str	r1, [r5, #4]
  tp->queue.prev->queue.next = tp;
 800335a:	600d      	str	r5, [r1, #0]
  cp->queue.prev             = tp;
 800335c:	6055      	str	r5, [r2, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 800335e:	2120      	movs	r1, #32
 8003360:	2201      	movs	r2, #1
 8003362:	5462      	strb	r2, [r4, r1]
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8003364:	8f18      	ldrh	r0, [r3, #56]	; 0x38
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 8003366:	619c      	str	r4, [r3, #24]
 8003368:	4210      	tst	r0, r2
 800336a:	d024      	beq.n	80033b6 <chSchWakeupS.constprop.20+0xa6>
 */
__STATIC_FORCEINLINE uint32_t __get_PSP(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800336c:	f3ef 8309 	mrs	r3, PSP
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8003370:	69ea      	ldr	r2, [r5, #28]
 8003372:	3b24      	subs	r3, #36	; 0x24
 8003374:	429a      	cmp	r2, r3
 8003376:	d833      	bhi.n	80033e0 <chSchWakeupS.constprop.20+0xd0>
 8003378:	1c20      	adds	r0, r4, #0
 800337a:	1c29      	adds	r1, r5, #0
 800337c:	f7fc ff0c 	bl	8000198 <_port_switch>
  }
}
 8003380:	bd70      	pop	{r4, r5, r6, pc}
    chSysHalt("SV#11");
 8003382:	481a      	ldr	r0, [pc, #104]	; (80033ec <chSchWakeupS.constprop.20+0xdc>)
 8003384:	f7fd fef4 	bl	8001170 <chSysHalt>
thread_t *chSchReadyAheadI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003388:	4819      	ldr	r0, [pc, #100]	; (80033f0 <chSchWakeupS.constprop.20+0xe0>)
 800338a:	f7fd fef1 	bl	8001170 <chSysHalt>
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;

  chDbgCheckClassS();

  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800338e:	4819      	ldr	r0, [pc, #100]	; (80033f4 <chSchWakeupS.constprop.20+0xe4>)
 8003390:	f7fd feee 	bl	8001170 <chSysHalt>
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003394:	2520      	movs	r5, #32
 8003396:	5d61      	ldrb	r1, [r4, r5]
 8003398:	2900      	cmp	r1, #0
 800339a:	d01e      	beq.n	80033da <chSchWakeupS.constprop.20+0xca>
 800339c:	290f      	cmp	r1, #15
 800339e:	d01c      	beq.n	80033da <chSchWakeupS.constprop.20+0xca>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80033a0:	5560      	strb	r0, [r4, r5]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 80033a2:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80033a4:	6899      	ldr	r1, [r3, #8]
 80033a6:	4291      	cmp	r1, r2
 80033a8:	d2fb      	bcs.n	80033a2 <chSchWakeupS.constprop.20+0x92>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80033aa:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80033ac:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 80033ae:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 80033b0:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80033b2:	605c      	str	r4, [r3, #4]
 80033b4:	e7e4      	b.n	8003380 <chSchWakeupS.constprop.20+0x70>
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80033b6:	2607      	movs	r6, #7
 80033b8:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80033ba:	7818      	ldrb	r0, [r3, #0]
 80033bc:	43b0      	bics	r0, r6
 80033be:	4302      	orrs	r2, r0
 80033c0:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80033c2:	5c69      	ldrb	r1, [r5, r1]
 80033c4:	b2d2      	uxtb	r2, r2
 80033c6:	00c9      	lsls	r1, r1, #3
 80033c8:	4032      	ands	r2, r6
 80033ca:	430a      	orrs	r2, r1
 80033cc:	701a      	strb	r2, [r3, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 80033ce:	609c      	str	r4, [r3, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80033d0:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80033d2:	60da      	str	r2, [r3, #12]
    trace_next();
 80033d4:	f7fd feb4 	bl	8001140 <trace_next.lto_priv.45>
 80033d8:	e7c8      	b.n	800336c <chSchWakeupS.constprop.20+0x5c>
thread_t *chSchReadyI(thread_t *tp) {
  thread_t *cp;

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
 80033da:	4807      	ldr	r0, [pc, #28]	; (80033f8 <chSchWakeupS.constprop.20+0xe8>)
 80033dc:	f7fd fec8 	bl	8001170 <chSysHalt>
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80033e0:	4806      	ldr	r0, [pc, #24]	; (80033fc <chSchWakeupS.constprop.20+0xec>)
 80033e2:	f7fd fec5 	bl	8001170 <chSysHalt>
 80033e6:	46c0      	nop			; (mov r8, r8)
 80033e8:	20000700 	.word	0x20000700
 80033ec:	080036d0 	.word	0x080036d0
 80033f0:	08003964 	.word	0x08003964
 80033f4:	080039c4 	.word	0x080039c4
 80033f8:	08003978 	.word	0x08003978
 80033fc:	080036d8 	.word	0x080036d8

08003400 <I2CReadRegisterByteWithCRC.constprop.3>:
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);
    return msg;
}

msg_t I2CReadRegisterByteWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint8_t *data) {
 8003400:	b5f0      	push	{r4, r5, r6, r7, lr}
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8003402:	4f5d      	ldr	r7, [pc, #372]	; (8003578 <I2CReadRegisterByteWithCRC.constprop.3+0x178>)
 8003404:	b085      	sub	sp, #20
    msg_t msg;
    i2cflags_t err;
    uint8_t tx_buffer[1] = {reg_address};
 8003406:	ad01      	add	r5, sp, #4
 8003408:	370c      	adds	r7, #12
 800340a:	7028      	strb	r0, [r5, #0]
    uint8_t CRCInput[2];
    uint8_t crc;

    //read data from i2c bus
    i2cAcquireBus(i2cp);
    msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, 1,
 800340c:	ac02      	add	r4, sp, #8
 800340e:	1c38      	adds	r0, r7, #0
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);
    return msg;
}

msg_t I2CReadRegisterByteWithCRC(I2CDriver *i2cp, uint8_t dev_address, uint8_t reg_address, uint8_t *data) {
 8003410:	1c0e      	adds	r6, r1, #0
 8003412:	f7fd fef5 	bl	8001200 <chMtxLock>
    uint8_t CRCInput[2];
    uint8_t crc;

    //read data from i2c bus
    i2cAcquireBus(i2cp);
    msg = i2cMasterTransmitTimeout(i2cp, addr_bq76920, tx_buffer, 1,
 8003416:	2101      	movs	r1, #1
 8003418:	1c22      	adds	r2, r4, #0
 800341a:	2302      	movs	r3, #2
 800341c:	1c28      	adds	r0, r5, #0
 800341e:	f7ff fe7f 	bl	8003120 <i2cMasterTransmitTimeout.constprop.28>
 8003422:	1c05      	adds	r5, r0, #0
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8003424:	1c38      	adds	r0, r7, #0
 8003426:	f7ff f973 	bl	8002710 <chMtxUnlock>
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800342a:	231c      	movs	r3, #28
				crc ^= key;
 800342c:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800342e:	b2db      	uxtb	r3, r3
 8003430:	005a      	lsls	r2, r3, #1
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
	  CRCInput[1] = rx_buffer[0];
 8003432:	7820      	ldrb	r0, [r4, #0]
    i2cReleaseBus(i2cp);
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
 8003434:	a903      	add	r1, sp, #12
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8003436:	b2d2      	uxtb	r2, r2
 8003438:	b25b      	sxtb	r3, r3
    if (msg != MSG_OK)
      err = i2cGetErrors(i2cp);

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
	  CRCInput[1] = rx_buffer[0];
 800343a:	7048      	strb	r0, [r1, #1]
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800343c:	4057      	eors	r7, r2
 800343e:	2b00      	cmp	r3, #0
 8003440:	da00      	bge.n	8003444 <I2CReadRegisterByteWithCRC.constprop.3+0x44>
 8003442:	e086      	b.n	8003552 <I2CReadRegisterByteWithCRC.constprop.3+0x152>
 8003444:	1c13      	adds	r3, r2, #0
 8003446:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8003448:	005a      	lsls	r2, r3, #1
 800344a:	b2d2      	uxtb	r2, r2
 800344c:	b25b      	sxtb	r3, r3
				crc ^= key;
 800344e:	4057      	eors	r7, r2
 8003450:	2b00      	cmp	r3, #0
 8003452:	da00      	bge.n	8003456 <I2CReadRegisterByteWithCRC.constprop.3+0x56>
 8003454:	e079      	b.n	800354a <I2CReadRegisterByteWithCRC.constprop.3+0x14a>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8003456:	2707      	movs	r7, #7
 8003458:	b2d2      	uxtb	r2, r2
 800345a:	407a      	eors	r2, r7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800345c:	0053      	lsls	r3, r2, #1
 800345e:	b2db      	uxtb	r3, r3
				crc ^= key;
 8003460:	405f      	eors	r7, r3
 8003462:	b252      	sxtb	r2, r2
 8003464:	7849      	ldrb	r1, [r1, #1]
 8003466:	b2ff      	uxtb	r7, r7
 8003468:	2a00      	cmp	r2, #0
 800346a:	da00      	bge.n	800346e <I2CReadRegisterByteWithCRC.constprop.3+0x6e>
 800346c:	e081      	b.n	8003572 <I2CReadRegisterByteWithCRC.constprop.3+0x172>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800346e:	2207      	movs	r2, #7
 8003470:	b2df      	uxtb	r7, r3
 8003472:	4057      	eors	r7, r2
 8003474:	09ca      	lsrs	r2, r1, #7
 8003476:	d000      	beq.n	800347a <I2CReadRegisterByteWithCRC.constprop.3+0x7a>
 8003478:	1c3b      	adds	r3, r7, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 800347a:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800347c:	005a      	lsls	r2, r3, #1
 800347e:	b2d2      	uxtb	r2, r2
 8003480:	b25b      	sxtb	r3, r3
				crc ^= key;
 8003482:	4057      	eors	r7, r2
 8003484:	2b00      	cmp	r3, #0
 8003486:	da00      	bge.n	800348a <I2CReadRegisterByteWithCRC.constprop.3+0x8a>
 8003488:	e071      	b.n	800356e <I2CReadRegisterByteWithCRC.constprop.3+0x16e>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800348a:	2307      	movs	r3, #7
 800348c:	b2d7      	uxtb	r7, r2
 800348e:	407b      	eors	r3, r7
 8003490:	064f      	lsls	r7, r1, #25
 8003492:	d500      	bpl.n	8003496 <I2CReadRegisterByteWithCRC.constprop.3+0x96>
 8003494:	1c1a      	adds	r2, r3, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8003496:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8003498:	0053      	lsls	r3, r2, #1
 800349a:	b2db      	uxtb	r3, r3
 800349c:	b252      	sxtb	r2, r2
				crc ^= key;
 800349e:	405f      	eors	r7, r3
 80034a0:	2a00      	cmp	r2, #0
 80034a2:	db62      	blt.n	800356a <I2CReadRegisterByteWithCRC.constprop.3+0x16a>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80034a4:	2207      	movs	r2, #7
 80034a6:	b2df      	uxtb	r7, r3
 80034a8:	407a      	eors	r2, r7
 80034aa:	068f      	lsls	r7, r1, #26
 80034ac:	d500      	bpl.n	80034b0 <I2CReadRegisterByteWithCRC.constprop.3+0xb0>
 80034ae:	1c13      	adds	r3, r2, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80034b0:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80034b2:	005a      	lsls	r2, r3, #1
 80034b4:	b2d2      	uxtb	r2, r2
 80034b6:	b25b      	sxtb	r3, r3
				crc ^= key;
 80034b8:	4057      	eors	r7, r2
 80034ba:	2b00      	cmp	r3, #0
 80034bc:	db53      	blt.n	8003566 <I2CReadRegisterByteWithCRC.constprop.3+0x166>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80034be:	2307      	movs	r3, #7
 80034c0:	b2d7      	uxtb	r7, r2
 80034c2:	407b      	eors	r3, r7
 80034c4:	06cf      	lsls	r7, r1, #27
 80034c6:	d500      	bpl.n	80034ca <I2CReadRegisterByteWithCRC.constprop.3+0xca>
 80034c8:	1c1a      	adds	r2, r3, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80034ca:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80034cc:	0053      	lsls	r3, r2, #1
 80034ce:	b2db      	uxtb	r3, r3
 80034d0:	b252      	sxtb	r2, r2
				crc ^= key;
 80034d2:	405f      	eors	r7, r3
 80034d4:	2a00      	cmp	r2, #0
 80034d6:	db44      	blt.n	8003562 <I2CReadRegisterByteWithCRC.constprop.3+0x162>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80034d8:	2207      	movs	r2, #7
 80034da:	b2df      	uxtb	r7, r3
 80034dc:	407a      	eors	r2, r7
 80034de:	070f      	lsls	r7, r1, #28
 80034e0:	d500      	bpl.n	80034e4 <I2CReadRegisterByteWithCRC.constprop.3+0xe4>
 80034e2:	1c13      	adds	r3, r2, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80034e4:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 80034e6:	005a      	lsls	r2, r3, #1
 80034e8:	b2d2      	uxtb	r2, r2
 80034ea:	b25b      	sxtb	r3, r3
				crc ^= key;
 80034ec:	4057      	eors	r7, r2
 80034ee:	2b00      	cmp	r3, #0
 80034f0:	db35      	blt.n	800355e <I2CReadRegisterByteWithCRC.constprop.3+0x15e>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 80034f2:	2307      	movs	r3, #7
 80034f4:	b2d7      	uxtb	r7, r2
 80034f6:	407b      	eors	r3, r7
 80034f8:	074f      	lsls	r7, r1, #29
 80034fa:	d500      	bpl.n	80034fe <I2CReadRegisterByteWithCRC.constprop.3+0xfe>
 80034fc:	1c1a      	adds	r2, r3, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 80034fe:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 8003500:	0053      	lsls	r3, r2, #1
 8003502:	b2db      	uxtb	r3, r3
 8003504:	b252      	sxtb	r2, r2
				crc ^= key;
 8003506:	405f      	eors	r7, r3
 8003508:	2a00      	cmp	r2, #0
 800350a:	db26      	blt.n	800355a <I2CReadRegisterByteWithCRC.constprop.3+0x15a>
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 800350c:	2207      	movs	r2, #7
 800350e:	b2df      	uxtb	r7, r3
 8003510:	407a      	eors	r2, r7
 8003512:	078f      	lsls	r7, r1, #30
 8003514:	d500      	bpl.n	8003518 <I2CReadRegisterByteWithCRC.constprop.3+0x118>
 8003516:	1c13      	adds	r3, r2, #0
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
				crc ^= key;
 8003518:	2707      	movs	r7, #7
	{
		for(i=0x80; i!=0; i/=2)
		{
			if((crc & 0x80) != 0)
			{
				crc *= 2;
 800351a:	005a      	lsls	r2, r3, #1
 800351c:	b2d2      	uxtb	r2, r2
 800351e:	b25b      	sxtb	r3, r3
				crc ^= key;
 8003520:	4057      	eors	r7, r2
 8003522:	2b00      	cmp	r3, #0
 8003524:	db17      	blt.n	8003556 <I2CReadRegisterByteWithCRC.constprop.3+0x156>
 8003526:	1c13      	adds	r3, r2, #0
			}
			else
				crc *= 2;

			if((*ptr & i)!=0)
				crc ^= key;
 8003528:	2207      	movs	r2, #7
 800352a:	b2df      	uxtb	r7, r3
 800352c:	407a      	eors	r2, r7
 800352e:	07c9      	lsls	r1, r1, #31
 8003530:	d500      	bpl.n	8003534 <I2CReadRegisterByteWithCRC.constprop.3+0x134>
 8003532:	1c13      	adds	r3, r2, #0

    //CRC check
    CRCInput[0] = (addr_bq76920 << 1) + 1;
	  CRCInput[1] = rx_buffer[0];
    crc = CRC8(CRCInput, 2, 7);
    if (crc != rx_buffer[1])
 8003534:	7862      	ldrb	r2, [r4, #1]
 8003536:	b2db      	uxtb	r3, r3
 8003538:	429a      	cmp	r2, r3
 800353a:	d008      	beq.n	800354e <I2CReadRegisterByteWithCRC.constprop.3+0x14e>
      palSetPad(GPIOA, GPIOA_LED2);
 800353c:	2390      	movs	r3, #144	; 0x90
 800353e:	2240      	movs	r2, #64	; 0x40
 8003540:	05db      	lsls	r3, r3, #23
 8003542:	831a      	strh	r2, [r3, #24]
    else
      *data = rx_buffer[0];
    return msg;
}
 8003544:	1c28      	adds	r0, r5, #0
 8003546:	b005      	add	sp, #20
 8003548:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800354a:	1c3a      	adds	r2, r7, #0
 800354c:	e783      	b.n	8003456 <I2CReadRegisterByteWithCRC.constprop.3+0x56>
	  CRCInput[1] = rx_buffer[0];
    crc = CRC8(CRCInput, 2, 7);
    if (crc != rx_buffer[1])
      palSetPad(GPIOA, GPIOA_LED2);
    else
      *data = rx_buffer[0];
 800354e:	7030      	strb	r0, [r6, #0]
 8003550:	e7f8      	b.n	8003544 <I2CReadRegisterByteWithCRC.constprop.3+0x144>
 8003552:	1c3b      	adds	r3, r7, #0
 8003554:	e777      	b.n	8003446 <I2CReadRegisterByteWithCRC.constprop.3+0x46>
 8003556:	1c3b      	adds	r3, r7, #0
 8003558:	e7e6      	b.n	8003528 <I2CReadRegisterByteWithCRC.constprop.3+0x128>
 800355a:	1c3b      	adds	r3, r7, #0
 800355c:	e7d6      	b.n	800350c <I2CReadRegisterByteWithCRC.constprop.3+0x10c>
 800355e:	1c3a      	adds	r2, r7, #0
 8003560:	e7c7      	b.n	80034f2 <I2CReadRegisterByteWithCRC.constprop.3+0xf2>
 8003562:	1c3b      	adds	r3, r7, #0
 8003564:	e7b8      	b.n	80034d8 <I2CReadRegisterByteWithCRC.constprop.3+0xd8>
 8003566:	1c3a      	adds	r2, r7, #0
 8003568:	e7a9      	b.n	80034be <I2CReadRegisterByteWithCRC.constprop.3+0xbe>
 800356a:	1c3b      	adds	r3, r7, #0
 800356c:	e79a      	b.n	80034a4 <I2CReadRegisterByteWithCRC.constprop.3+0xa4>
 800356e:	1c3a      	adds	r2, r7, #0
 8003570:	e78b      	b.n	800348a <I2CReadRegisterByteWithCRC.constprop.3+0x8a>
 8003572:	1c3b      	adds	r3, r7, #0
 8003574:	e77b      	b.n	800346e <I2CReadRegisterByteWithCRC.constprop.3+0x6e>
 8003576:	46c0      	nop			; (mov r8, r8)
 8003578:	20000f84 	.word	0x20000f84

0800357c <memset>:
 800357c:	b570      	push	{r4, r5, r6, lr}
 800357e:	0783      	lsls	r3, r0, #30
 8003580:	d03f      	beq.n	8003602 <memset+0x86>
 8003582:	1e54      	subs	r4, r2, #1
 8003584:	2a00      	cmp	r2, #0
 8003586:	d03b      	beq.n	8003600 <memset+0x84>
 8003588:	b2ce      	uxtb	r6, r1
 800358a:	1c03      	adds	r3, r0, #0
 800358c:	2503      	movs	r5, #3
 800358e:	e003      	b.n	8003598 <memset+0x1c>
 8003590:	1e62      	subs	r2, r4, #1
 8003592:	2c00      	cmp	r4, #0
 8003594:	d034      	beq.n	8003600 <memset+0x84>
 8003596:	1c14      	adds	r4, r2, #0
 8003598:	3301      	adds	r3, #1
 800359a:	1e5a      	subs	r2, r3, #1
 800359c:	7016      	strb	r6, [r2, #0]
 800359e:	422b      	tst	r3, r5
 80035a0:	d1f6      	bne.n	8003590 <memset+0x14>
 80035a2:	2c03      	cmp	r4, #3
 80035a4:	d924      	bls.n	80035f0 <memset+0x74>
 80035a6:	25ff      	movs	r5, #255	; 0xff
 80035a8:	400d      	ands	r5, r1
 80035aa:	022a      	lsls	r2, r5, #8
 80035ac:	4315      	orrs	r5, r2
 80035ae:	042a      	lsls	r2, r5, #16
 80035b0:	4315      	orrs	r5, r2
 80035b2:	2c0f      	cmp	r4, #15
 80035b4:	d911      	bls.n	80035da <memset+0x5e>
 80035b6:	1c26      	adds	r6, r4, #0
 80035b8:	3e10      	subs	r6, #16
 80035ba:	0936      	lsrs	r6, r6, #4
 80035bc:	3601      	adds	r6, #1
 80035be:	0136      	lsls	r6, r6, #4
 80035c0:	1c1a      	adds	r2, r3, #0
 80035c2:	199b      	adds	r3, r3, r6
 80035c4:	6015      	str	r5, [r2, #0]
 80035c6:	6055      	str	r5, [r2, #4]
 80035c8:	6095      	str	r5, [r2, #8]
 80035ca:	60d5      	str	r5, [r2, #12]
 80035cc:	3210      	adds	r2, #16
 80035ce:	4293      	cmp	r3, r2
 80035d0:	d1f8      	bne.n	80035c4 <memset+0x48>
 80035d2:	220f      	movs	r2, #15
 80035d4:	4014      	ands	r4, r2
 80035d6:	2c03      	cmp	r4, #3
 80035d8:	d90a      	bls.n	80035f0 <memset+0x74>
 80035da:	1f26      	subs	r6, r4, #4
 80035dc:	08b6      	lsrs	r6, r6, #2
 80035de:	3601      	adds	r6, #1
 80035e0:	00b6      	lsls	r6, r6, #2
 80035e2:	1c1a      	adds	r2, r3, #0
 80035e4:	199b      	adds	r3, r3, r6
 80035e6:	c220      	stmia	r2!, {r5}
 80035e8:	4293      	cmp	r3, r2
 80035ea:	d1fc      	bne.n	80035e6 <memset+0x6a>
 80035ec:	2203      	movs	r2, #3
 80035ee:	4014      	ands	r4, r2
 80035f0:	2c00      	cmp	r4, #0
 80035f2:	d005      	beq.n	8003600 <memset+0x84>
 80035f4:	b2c9      	uxtb	r1, r1
 80035f6:	191c      	adds	r4, r3, r4
 80035f8:	7019      	strb	r1, [r3, #0]
 80035fa:	3301      	adds	r3, #1
 80035fc:	42a3      	cmp	r3, r4
 80035fe:	d1fb      	bne.n	80035f8 <memset+0x7c>
 8003600:	bd70      	pop	{r4, r5, r6, pc}
 8003602:	1c14      	adds	r4, r2, #0
 8003604:	1c03      	adds	r3, r0, #0
 8003606:	e7cc      	b.n	80035a2 <memset+0x26>
